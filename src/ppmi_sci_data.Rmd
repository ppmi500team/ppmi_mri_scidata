---
title: "Magnetic Resonance Imaging Data Phenotypes for the Parkinson's Progression Markers Initiative"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1
  - Leon Fonville^3,†^
  - Olivia Hampton^1,†^
  - Alex Reardon^1,†^
  - Nicholas J. Tustison^2
  - Xue Wang^1,†^
  - Linda
  - Zahra
  - Adam
  - Roger Gunn^1
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: University of Virginia, Department of Radiology and Medical Imaging, Charlottesville, VA, FIXME, USE"
  - "3: Invicro, FIMXE, UK"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: 
  pdf_document:
    keep_tex: true
    template: null
#    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmiscidata.bib
classoption: table
# header-includes:
#  - \usepackage{jabbrv}
linenumbers: true
urlcolor: blue
# nocite: '@*'
link-citations: true
---


```{r samplesizes,echo=FALSE,eval=TRUE}
redomerge=TRUE
```


```{r ppmimerge, echo=FALSE,eval=redomerge}
library(plyr)
library(subtyper)
library(forcats)
library(lmerTest)
library(lme4)
library(ggplot2)
if ( ! exists("clin2b") ) {
  rdir=path.expand('~/code/multidisorder/data/')
  rdir=path.expand('~/Downloads/ppmi_pym_data/')
  if ( ! exists("pymf") ) {
    pymfns = data.frame( 
      fns=c( 
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRNext_v1.2.7.csv')  ),
      rez=c("OR","SRF","SRP") )
    print(paste("ANTsPyMM Pipeline : ", myrez ) )
    pym = read.csv(  pymfns$fn[pymfns$rez == myrez ] )
    pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
    pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
    pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
    pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
    rm(pym)
    }
  demog=read.csv(paste0(rdir,"Demographics_06Feb2024.csv"))
  curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20230612_rev.csv')
  saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv')
  if ( ! file.exists( saafn ) ) {
    saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023.csv')
    }
  saa=read.csv( saafn )
  ppmidemog0=read.csv( curfn )
  clin2b = merge_ppmi_imaging_clinical_demographic_data(
    demog, ppmidemog0, pymf, pymversion=myrez, saa )
  # add tracker
  tracker = read.csv(paste0(rdir,"ppmi_2_0_internal_scan_tracking_report_v12-2024-02-08.csv"))

  tracker = tracker[ tracker$Modality == "MR", ]
  tracker$EVENT_ID=tracker$Visit
  tracker$EVENT_ID[ grep("Baseline",tracker$EVENT_ID)]="BL"
  tracker$date=NA
  momap=data.frame( num=c( paste0("0",1:9), "10", "11", "12") )
  rownames(momap)=c("JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC")
  for ( k in 1:nrow(tracker) ) {
    fixedev=unlist(strsplit( tracker$Visit[k], "/"))
    if ( length( fixedev ) > 1 ) fixedev=fixedev[length( fixedev )]
    tracker$EVENT_ID[k]=fixedev
    fixeddt = unlist(strsplit( tracker$Scan.Date[k],"-"))
    fixeddt[2] = momap[ fixeddt[2], 'num' ]
    fixeddt = paste0( fixeddt[3] , fixeddt[2], fixeddt[1] )
    tracker$date[k]=fixeddt
    }
  trackersub = tracker[, c("Subject.ID","date" )]
  trackersub$imaging_protocol=2
  names(trackersub)=c("PATNO","date", "imaging_protocol" )
  clin2b=merge( clin2b, trackersub, by=c("PATNO","date"), all.x=TRUE )
  clin2b$imaging_protocol[ is.na(clin2b$imaging_protocol) ]=1
  # add LRRK2 
  lrrk2 = read.csv( paste0(rdir,'CSFSAA_LRRK2_MRI_SAMPLES_08Jan2024/Data-Table1.csv'))
  lrrk2$SAAGroup[ lrrk2$SAAGroup == " " ]=NA
  clin2b$LRRK2_study=NA
  uids = lrrk2$PATNO
  lrrk2cols = colnames(lrrk2)
  lrrk2cols=lrrk2cols[ !(lrrk2cols %in% "PATNO") ]
  newcols = paste0("LRRK2_", lrrk2cols )
  clin2b[,newcols]=NA
  for ( k in 1:length(uids) ) {
    clin2bsel = clin2b$PATNO == uids[k]
    if ( sum( clin2bsel ) > 0 ) {
      # print(paste("have",u))
      clin2b[clin2bsel,newcols]=lrrk2[k,lrrk2cols]
    } # else print(paste("miss",u))
  }
  clin2b$LRRK2_study = !is.na( clin2b$LRRK2_cohort)
 summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_dwi_mean +T1Hier_evratio + noise + snr + msk_vol,data=clin2b) )
 summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+T1Hier_resnetGrade +T1Hier_evratio + cnr + noise,data=clin2b) )
 summary( lm( LRRK2_MRIPROTOCOL ~  cnr + noise  + msk_vol + spc0+	spc1+	spc2,data=clin2b) )
}
ppmi = clin2b
ppmi$imaging_protocol=factor(ppmi$imaging_protocol)

```


```{r maketrim,echo=FALSE,eval=!exists("ppmitrim")}
ntokeep = 2950
ppmitrim = ppmi[ head( order(ppmi$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
updnames = getNamesFromDataframe("upd",ppmi,exclusions=c("BL","delta"))
msnames = getNamesFromDataframe("pm_",ppmi,exclusions=c("BL","delta"))
lrrk2names= getNamesFromDataframe("LRRK2_",ppmi,exclusions=c("BL","delta","LRRK2_MRIPROTOCOL"))
ppmitrim = antspymm_predictors( ppmitrim, TRUE )
t1namesctx = getNamesFromDataframe( c("T1Hier","LRAVG",'dktcortex','thk'), ppmitrim)
t1namescit = getNamesFromDataframe( c("T1Hier","LRAVG",'deep','vol'), ppmitrim)
t1namesnbm = getNamesFromDataframe( c("T1Hier","LRAVG",'nbm','vol'), ppmitrim)
t1namesbst = getNamesFromDataframe( c("T1Hier",'brainstem','vol'), ppmitrim, exclusions=c("tissues","lobes"))[-1]
t1namescrb = getNamesFromDataframe( c("T1Hier",'cerebellu','LRAVG','vol'), ppmitrim, exclusions=c("tissues","lobes","dktregion"))
t1namesctxa = gsub("LRAVG","Asym",t1namesctx)
t1namescita = gsub("LRAVG","Asym",t1namescit)
t1namesnbma = gsub("LRAVG","Asym",t1namesnbm)
t1namescrba = gsub("LRAVG","Asym",t1namescrb)
t1vars = c(t1namesbst,t1namesctx,t1namescit,t1namesnbm,t1namescrb,t1namesctxa,t1namescita,t1namesnbma,t1namescrba)
ppmitrim0 = ppmitrim[ , c("subjectID","age_BL",'commonSex', "hy_BL", "duration_yrs","LEDD","moca",updnames, msnames, 'joinedDX','AsynStatus', "DXSubAsyn", "educ","race",'tau','ptau','abeta', 'yearsbl', 'EVENT_ID', 'date', lrrk2names,  'filename', 'brainVolume', t1vars, 'imaging_protocol', 'T1Hier_resnetGrade' ) ]

# write.csv( ppmitrim0, '~/Downloads/ppmitrim0_SR_first_extended.csv',row.names=FALSE)
# head( ppmitrim0, 2 )
# isbl=subtyper::fs(ppmitrim$yearsbl==0 & ppmitrim$joinedDX == 'PDSporadic')
# temp=ppmitrim[isbl,]
# trimT1 = dcurvarsel( temp, c(t1namesctx,t1namescit), 1 )

# get numbers for abstract
viztbl = table( ppmitrim0$joinedDX, ppmitrim0$EVENT_ID )
isbl=ppmitrim0$yearsbl==0
npd=viztbl["PDSporadic","BL"]
npdf=sum(viztbl["PDSporadic",c("V04","V06","V08","V10","V12")])
ngpd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('PDGBA','PDLRRK2','PDSNCA' )))
ncn=viztbl["CN","BL"]
nprepd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('ProdromalGBA','ProdromalLRRK2' ,'ProdromalSNCA','ProdromalSporadic' )))
vizfll=mean( ppmitrim0$yearsbl[!isbl] )
vizfll=insight::format_value( vizfll )
# tt = table( table( ppmitrim0$subjectID[!isbl] ) )

```

# Abstract

The Parkinson's Progression Markers Initiative (PPMI) delivers multiple modality MRI (M3RI) and biomarker data for a comprehensive longitudinal study of Parkinson's Disease (PD).  These provide quantitative indices of deep brain and cortical structure (T1-weighted MRI), axonal integrity (diffusion-weighted imaging) and resting brain function (resting state functional MRI).  Integrating and uniformly analyzing M3RI alongside non-imaging biological and clinical data is challenging due to the distinct nature of each modality. This study systematically organizes this complex data into a structured format, provides a PD-focused evaluation of the methodologies and evidence for technical robustness of the approach.  The cohort encompasses `r npd` idiopathic PD, `r ngpd` genetic PD, `r nprepd` presymptomatic PD and `r ncn` control subjects at baseline with followup at a mean of `r vizfll` years.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy bodies, primarily composed of misfolded alpha-synuclein, and appearing in the substantia nigra at an early stage [@fearnley_ageing_1991]. The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [@lee_mechanisms_2006;@dickson_neuropathology_2009;@calabresi_alpha-synuclein_2023]. The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [@shahnawaz_discriminating_2020; @siderowf_assessment_2023].

Analyzing the link between SAA status and longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking pathology, symptoms and imaging [@nemmi_totally_2019; @tremblay_sex_2020; @markello_multimodal_2021].

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI from 2010 to 2023, focusing on T1-weighted, diffusion-weighted, and resting-state functional MRI for analyzing neurodegenerative diseases. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [@avants_pediatric_2015; 
@stone_functional_2020; @tustison_antsx_2020]

To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] and an additional easily accessible M3RI young control cohort [@avants_pediatric_2015].  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate the neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [@schwarz_t1-weighted_2011;@aquino_substantia_2014;@ryman_mri_2020]. Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [@peran_magnetic_2010] but also in LRRK2-PD [@tolosa_lrrk2_2020]. Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [@hacker_resting_2012;@kim_abnormal_2017]. Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain, pointing towards a more integrative approach to understanding PD [@menke_mri_2009;@markello_multimodal_2021] and the role of alpha-synuclein in these effects [@simuni_biological_2024].

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs are computed with [ANTsPyMM](https://pypi.org/project/antspymm/) and depend on standard anatomical and functional hierarchies that are well-established in the field and consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dMwRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables easily merge with the associated demographics, SAA status, clinical data such as the Unified Parkinson's Disease Rating Scale (UPDRS) [@disease_unified_2003] and standard PPMI DAT-SPECT summary measurements [@bega_clinical_2021; @droby_aberrant_2022]. Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.


# Methods

![Overview of ANTsPyMM outputs for T1-weighted MRI, diffusion MRI and resting state fMRI.  Panel (a) shows example input data; the package does not require all modalities to be present -- only T1w.  It also handles FLAIR and neuromelanin, not covered here.  Panel (b) illustrates core T1w outputs across several inter-related and PD relevant systems in the brain.  Panel (c) shows the standard outputs associated with DTI. Whole brain tractography is also output but no evaluation results are available to contextualize its performance and, as such, we do not recommend its use.  Panel (d) summarizes the various rsfMRI outputs for processing parameter set number 122 referred to with a prefix `rsfMRI_fcnxpro122`.  Output from sets [134 and 129](https://github.com/ANTsX/ANTsPyMM/blob/4d10c3a7c4a962c00a3c198ba0e00f35da25776d/antspymm/mm.py#L6496-L6506) are also available.](../figs/antspymm_3.jpg)

## MRI data collection 

MRI data collection occurred between 2010 and an August 2023 cutoff date for these data.  Two phases of MRI collection occurred in PPMI; the first collected T1w and later DTI as part of exploratory investigations.  In 2020, a new phase of collection sought to improve both MRI quality and consistency and expand the number of modalities collected.  The details of the sequences used is covered elsewhere **Lino - FIXME IS IT? CITATION?*. The "phase" of data collection is captured in the variable `imaging_protocol`.  Table FIXME summarizes the cohort characteristics.

### Semi-automated quality assessment

Each T1w image was reviewed by a `resnetGrader` (a deep learning model trained to predict image quality) [@avants2022] as well as inspected visually for usability.  The visual inspection is performed by BA and serves as a sanity check to the automated method.  The `resnetGrader` successfully filtered unusable data and we selected a  quality cutoff at `r min(ppmitrim$T1Hier_resnetGrade)` to filter out low quality images.  Similarly, the rsfMRI and DTI were visually inspected in `post hoc` fashion.  This process involved visually inspecting each estimated FA image and each estimated default mode network connectivity map and its associated mean BOLD image.  Particular focus was paid to cases with high motion and/or low SNR.

## Neuroanatomical coordinate systems

The statistical interpretation of processed images is aided by automatic anatomic labeling with pre-specified coodinate systems or maps overlaid on each subject's neuroimage. We leverage a recent homotopic parcellation [@FIXME], the Desikan-Killiany-Tourville (DKT) system [@FIXME], the CIT168 atlas [@FIXME], the Johns Hopkins University (JHU) white matter labels [@FIXME], the Schmahmann cerebellar parcellation [@FIXME], brain stem labels [@FIXME], a medial temporal lobe schema [@FIXME] and labels derived from probabilistic maps of the basal forebrain [@FIXME].  These systems are described in detail in the data dictionary and associated documentation. These coordinate system enable PD researchers to interrogate a variety of hypotheses related to, for example, functional networks, cholinergic networks, the striatum or dopaminergic systems.

### T1-weighted MRI processing

T1-weighted MRI processing is described in detail in @tustison_antsx_2021. This open-source software ecosystem includes tools for image registration, segmentation, and super resolution as customized for the human brain.  The derived measurements are tabulated by the neuroanatomical coordinates defined above and include cortical and subcortical measurements and morphological measurements of the hippocampus, basal forebrain and cerebellum.  The processing results of this stage are key to consistent processing of concomitant rsfMRI and DWI. We provide both original resolution (OR) and super-resolution (SR) results as part of this effort.  For SR processing, the network is applied -- first -- over the whole head T1w image to double resolution along all axes.  Otherwise, SR and OR processing are identical.  See Figure FIXME for examples of these outputs. Outputs from the T1 processing are denoted by prefixes `T1Hier` and `T1w`.

![Example ANTsPyMM SR outputs applied to T1-weighted MRI (upper left) and diffusion MRI. T1w is super resolved to 0.5mm isotropic and DTI to 1mm.](../figs/sr_comparison.jpg)

### Diffusion weighted MRI processing

Diffusion tensor imaging (DTI) processing leverages best practices from both ANTsX [@FIXMEPTBP] and the collaborative DTI-focused project [DiPy](https://www.frontiersin.org/articles/10.3389/fninf.2014.00008/full). This pipeline is specifically designed to utilize DWI acquisitions with either a single or opposed phase encoding directions. The functionality has been developed to address a broad spectrum of preprocessing requirements, such as motion correction, denoising, dewarping and gradient reorientation, and enhancement through super-resolution techniques, culminating in an optimized DTI reconstruction. Additionally, it integrates atlas-based labeling and registration processes, thereby enhancing the anatomical interpretability of the DTI metrics.  Figure FIXME summarizes the pipeline which follows these steps:

![Overview of the DTI processing pipeline based on ANTsX and DiPy.](../figs/dti_pipe.jpg)

1. **Input Preparation**: The pipeline accepts either a single DWI or a pair of DWI with reversed phase encoding. It also requires associated b-values and b-vectors for each direction, alongside a T1-weighted image and a brain mask for improved spatial accuracy in inter-modality registration.

2. **Initial Reconstruction and Motion Correction**: By default, the DWI data is denoised before performing motion correction. Motion correction aligns DWI volumes within and across acquisitions to a reference mean B0 and mean DWI, reducing artifacts due to subject movement.

3. **Dewarping and Super-Resolution**: Dewarping is applied to correct for distortions between the DWI space and the T1-weighted image. Optionally, SR is applied after dewarping but before the DiPy based reconstruction process.

4. **Reconstruction of DTI Metrics**: The function employs weighted least squares to reconstruct DTI metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD) from the preprocessed DWI data. This step is pivotal in quantifying the diffusion properties of brain tissue. 

5. **Atlas-Based Labeling and Registration**: Utilizing the Johns Hopkins University (JHU) atlas and corresponding labels, the pipeline performs spatial registration of the DTI to the atlas space. This process facilitates anatomical localization and quantification of DTI metrics within predefined brain regions. 

6. **Output Generation**: The pipeline yields a comprehensive output including the reconstructed DTI metrics, summary statistics of these metrics within atlas-defined regions, the spatial registration information, and additional diagnostic metrics such as framewise displacement and signal-to-noise ratio (SNR) assessments spatially and temporally for both B0 and DWI. An example output volumetric tensor image with labels is in Figure FIXME.

Outputs from the DWI processing are denoted by prefixes `DTI_`.

![Example super resolution processing for DTI highligting the multiple coordinate systems that are available to aid interpretation.](../figs/dti_SR.jpg)


### Resting state functional MRI processing 

Resting state functional MRI (rsfMRI) processing builds on prior multi-view techniques performed in this same ecosystem [(avants2015)](https://www.nature.com/articles/sdata20153) [avants2016](https://doi.org/10.1016/j.neurobiolaging.2018.10.002).  The procedure is based on the findings described in three comprehensive evaluation studies [@FIXME] and is designed to compute both functional activity and correlation maps utilizing the recently proposed homotopic labels to delineate major network systems [@FIXME]. The methodology described below is grounded in contemporary understanding of resting-state fMRI analysis and incorporates recommendations from seminal works regarding optimal preprocessing for minimizing motion artifacts and other sources of noise (Ciric et al., 2017; Parkes et al., 2018). As such, our processing reflects a comprehensive approach to resting-state fMRI IDP extraction for real-world multi-site studies of neurodegenerative disease.  Overall, the methods aim to facilitate the reliable extraction of functional connectivity patterns that are consistent with underlying neural mechanisms.  Similar to the DWI processing, the procedure accepts either a single image or a pair of images with reversed phase encoding direction.  The steps are outlined in Figure FIXME:

![Overview of the rsfMRI processing pipeline based on ANTsX.](../figs/fmri_pipe.jpg)

1. **Input Preparation**: Inputs include the raw BOLD fMRI time-series data, a reference volumetric subject-specific fMRI template, and T1-weighted anatomical images all from the same subject. These inputs are foundational for aligning functional data with anatomical landmarks and for ensuring that subsequent analyses are anatomically informed.  By default, the input fMRI is upsampled to 3mm isotropic resolution and 8 initial volumes are discarded to allow for both signal and subject stabilization.

2. **Preprocessing**: Initial steps include motion correction, application of a despiking algorithm (a `python` implementation of AFNI's 3dDespike [@FIMXE]), and anatomical registration to align the fMRI data with the T1-weighted image.  If a pair of images is passed, these are concatenated along the time axis.

3. **Noise Reduction**: Anatomical CompCor (aCompCor) is used to mitigate physiological and other noise sources. This is based on recommendations from studies examining the impact of preprocessing strategies on functional connectivity (Ciric et al., 2017; Parkes et al., 2018).

4. **Band-pass Filtering and activity calculation**: The application of a specific frequency range for filtering aligns with recommendations from Shirer et al. (2015) and Parkes et al. (2018), emphasizing the importance of selecting appropriate frequency bands for resting-state analysis.  The default frequency bands are based on empirical evaluation studies described below.

5. **Censoring**: Select volumes are censored based on both motion-based and intensity-based outlier detection.  The parameters for this stage derive from empirical evaluation studies on publicly available data as discussed below.  Both *censored* and *imputed* versions of the time series are created.  A summary of censoring results is recorded in several ways but perhaps most relevant are the variables `*minutes_original_data` and `*minutes_censored_data` which provides the length in minutes of the original versus processed data.

6. **Network Correlation Analysis**: This step involves calculating correlation matrices for identified resting-state networks, utilizing labels described above.  Both inter and intra-network correlation values are computed for each of the sub-networks provided by the homotopic parcellation.  

7. **Functional activity**: is computed with three models: mfALFF, mALFF and mPerAf as described in [@FIXME].  These are versions of fALFF, ALFF and PerAf where each is divided by the global mean in the brain.  Summary values are averaged within each of 500 labels in the homotopic label set which facilitates left/right asymmetry and mean values which are critical to studying diseases with laterality effects.

Due to the relatively diverse needs of researchers and the variety of rsfMRI that is generally present in public data, we run the above processing with three different sets of parameters (sets 122, 129 and 134) for censoring based on motion and intensity outlierness.  These three parameter choices led to rsfMRI IDPs that were the top performers in terms of reliability and predictive power out of 78 that we tested empirically.  See [this repository](https://github.com/stnava/antspymm_reproducibility) and the technical validation section for further details. Outputs from the DWI processing are denoted by prefixes `rsfMRI_`.


# Data Records

The neuroimaging and associated standard PPMI demographics and clinical data is hosted in the LONI Imaging Data Archive (LONI IDA). The former is stored in DICOM format and the latter in tabular .csv format.  Additionally, data dictionaries describing all non-imaging column headers are available on the LONI IDA.

We attach the neuroimaging data to the PPMI Curated Data Cut Curated (v.2023-06-12 `PPMI_Curated_Data_Cut_Public_20230612_rev`) available on the LONI IDA.  Code for this merging process is available via the [subtyper package](https://stnava.github.io/subtyper/) specifically the function [merge_ppmi_imaging_clinical_demographic_data](https://stnava.github.io/subtyper/reference/merge_ppmi_imaging_clinical_demographic_data.html).  The M3RI IDPs are described in detail [here](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) and are available in a data table within the `ANTsPyMM` repository (csv format).  The full tabular IDPs for both OR and SR outputs are available at [this location](FIXME).  We also provide a "trim" version [here](FIXME) that is intended to allow users to "get started" with these data without being overwhelmed by the sheer number of variables.  We base demonstrations below on the trim version of these PPMI IDPs.

# Technical Validation

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges FIXME. We further this by demonstrating ANTsX reproducibility and reliability through analysis of three traveling subject cohorts and a young control cohort. By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) across different scanner types and imaging modalities. The young control cohort, using the pediatric template of brain perfusion (PTBP) data, validates the utility of combining multi-modality tabular data processed by ANTsX to enhance predictions of population characteristics. In essence, our additional analyses furnish numerical benchmarks for reliability and predictive accuracy and may be extended to other contexts.

## Multi-site reproducibility

## Multi-view prediction 

## PPMI case studies

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  Magnetic resonance imaging (MRI) is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. 

Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), dMRI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

The tabulated multi-modality MRI dataset derived from deeply validated open source methods represents a significant leap forward in PD M3MRI research. It simplifies the analysis of complex imaging data, potentially accelerating the discovery of novel insights into PD's progression and effects. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.


```{r pkgs,echo=FALSE,eval=TRUE,messages=FALSE,cache=TRUE}
set.seed( 0 )
library(plyr)
library(ggplot2)
library( GoodmanKruskal )
library(forcats)
library(heatmap3)
library(permute)
library(interactions)
library(reghelper)
library(MGMM) # GMM methods (FIXME)
library(WeightedCluster) # cluster quality (FIXME)
library(tidyverse)
library(clValid)
library( cluster.datasets )
library(magrittr)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ggfortify)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="html" )
tblcmd = ztable
buildsci=TRUE
```

```{r functions,echo=FALSE,eval=TRUE,warnings=FALSE,messages=FALSE,cache=FALSE}

normalizersfmri = function( dd, applyit='none' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE,cache=FALSE}
if ( ! exists( "is_test" ) ) is_test = FALSE
if ( ! exists( "ppmi" ) ) {
  ppmifn = "../data/latest_ppmi_plus.csv"; myrez='or'
  ppmifn = "../data/latest_ppmi_plus_sr.csv"; myrez='sr'
  ppmifn = "../data/latest_ppmi_plus_sr_fmri_up.csv"; myrez='sr'
  ppmifn = '/tmp/ppmi.csv'
  ppmi = read.csv(ppmifn)
  ppmi = fillBaselineColumn( ppmi,
        c('brainVolume','hy','MOCA'), 
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
  mylevs = c( 
    "CN", "ProdromalLRRK2", "ProdromalGBA", "ProdromalSporadic", 
        "PDPRKN", "PDLRRK2", "PDGBA", "PDSporadic",
        "CBSPSP", "L_SD", "SV", "PNFA", "bvFTD",
        "SMC",  "MCI", "AD" ) 
  ppmi$joinedDX[ !(ppmi$joinedDX %in% mylevs) ]=NA
  ppmi$joinedDX = factor( ppmi$joinedDX, levels=mylevs )

}
```

### mixed effects diagnosis : T1

```{r quicklmdx,echo=FALSE,eval=buildsci,fig.width=9,fig.height=3.5,warnings=FALSE,messages=FALSE}
######################################################################
num=c(122,129,134)[1] # resting state protocol numbers ###############
######################################################################
dxform="~  (1|PATNO)+ (1|SITE) + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO) + imaging_protocol + age_BL + commonSex "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_mean + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
dxsel2 = ppmi$DXSubAsyn %in% c(
  negate, posate, ispd )
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
mylevsx1=c( "CN", "ProdromalSporadic", "PDSporadic", "MCI", "AD" )
# keep the "best" ntokeep examples
mydog = ppmi[ head( order(ppmi$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
ysel = mydog$yearsbl <= 4.5 
mydog = mydog[ mydog$studyName %in% c('PPMI','ADNI') & ysel &
#  ppmi$DXSubAsyn %in%  mylevsx0[c(1,2,3)]&  
#  ppmi$joinedDX %in%  mylevsx1[c(1,2,3)] &  
#  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2" ) ) &
  subtyper::fs( mydog$joinedDX %in% c( "CN","PDLRRK2","PDSporadic" ) ),]
mydog = normalizersfmri( mydog )
mydog$joinedDX <- fct_relevel(mydog$joinedDX, "CN")
mydog$DXSubAsyn <- fct_relevel(mydog$DXSubAsyn, "CNNegative")
###############################################
mydog$TDX = NA #as.character( mydog$DXSubAsyn )
dolrrk2=FALSE
if ( dolrrk2 ) {
  mydog$TDX = mydog$DXSubAsyn
  mydog$TDX[ mydog$LRRK2_study == FALSE ] = NA
  mydx='PDLRRK2'
} else {
  mydog$TDX[ mydog$AsynStatus == 'Negative' & mydog$joinedDX == 'CN' ]='CN'
# mydog$TDX[ mydog$DXSubAsyn %in% ispd ]='otherPositive'
#  mydog$TDX[ mydog$DXSubAsyn  == 'PDLRRK2Positive' ]='LRRK2PD+'
#  mydx='PDLRRK2+'
#  mydog$TDX[ mydog$DXSubAsyn  == 'PDSporadicNegative' ]='DXPD-'
  mydog$TDX[ mydog$DXSubAsyn  == 'PDSporadicPositive' ]='DXPD+'
  mydx='PDSp+'
}
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_n_outliers < 100 ) &
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5 )


mydog = antspymm_predictors(mydog, TRUE )
idps = antspymm_predictors(mydog, TRUE, TRUE )
subjectcount = table( mydog$commonID )
# mysubs = names(  subjectcount > 1 )
# mydog = mydog[ mydog$commonID %in% mysubs , ]
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass')
rsfnames = c( 
  getNamesFromDataframe( c("rsf","LRAVG",num,'_falff'), mydog, exclusions=xcl ),
  getNamesFromDataframe( c("rsf","Asym",num,'_falff'), mydog, exclusions=xcl ) )
rsfnamescnx = getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_"),  ppmi, exclusions=xcl )
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'joinedDX'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
mydog = mydog[ !is.na( mydog[,dxvar]), ]
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), mydog ),
  getNamesFromDataframe( c("DTI","Asym"), mydog ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),mydog, exclusions=c("left","right")), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),mydog, exclusions=c("left","right")) )
######################################
# print( table( mydog[,dxvar]))
mydog = fillBaselineColumn( mydog,
        c( idpst1, rsfnamescnx, rsfnames, dtinamesasymlr, 'hy' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX == 'CN' ]=0
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX != 'CN' ]=2
mydog$hy_BL = factor( mydog$hy_BL )
######################################
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
#  nmstotest = idpst1[ multigrep( c("dktcortex","thk"),idpst1,intersect=T)]
#  nmstotest = sample( nmstotest, 4 )
  mycorr='none'
}

dxdfT1=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdfT1)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( vois[2], " ~ hy_BL + ", vois[1], "+", dxform )
  bform = paste( vois[2], " ~ 1 + ", vois[1], "+", dxform )
  bform = paste( voi, " ~ T1Hier_resnetGrade + LRRK2_MRIPROTOCOL + ", dxform )
  bform = paste( voi, " ~ (LRRK2_MRIPROTOCOL) + ", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean + DTI_dti_tsnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+ spc0 +spc1+", dxform )
  bform = paste( voi, " ~ brainVolume_BL + T1Hier_resnetGrade+spc0+spc2+", dxform )
  newform = paste( bform, " * ", dxvar  )
  temp2 = mydog[ !is.na( mydog[,voi]), ]
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scale_variables_in_equation( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdfT1[n,'voi']=voi
  dxdfT1[n,'anv']=anvp
  dxdfT1[n,'tyears']=mycoffs[ 'yearsbl', 4]
  dxdfT1[n,'tcross']=mycoffs[ nrow(mycoffs)-1, 4]
  dxdfT1[n,'tlong']=mycoffs[ nrow(mycoffs), 4]
  dxdfT1[n,'res']=myrez
  dxdfT1[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( anvp < 1e-4 ) {
    print( mycoffs )
    print( dxdfT1[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( voi, myrez, " + ", mydx,  " : ", anvp ) )
    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
table(psel)
##########################################################
```

```{r dxresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
table(psel)
if ( sum( psel ) == 0  ) psel = rep(TRUE,nrow(dxdfT1))
dxdfT1sel = dxdfT1[psel,]
dxdfT1sel[,'dx']=mydx
dxdfT1sel$anv = insight::format_p(  dxdfT1sel$anv, digits=4  )
dxdfT1sel[, !(colnames(dxdfT1sel) %in% c("singular"))] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```



### mixed effects diagnosis : DTI

```{r quicklmdxDT,echo=FALSE,eval=buildsci,fig.width=9,fig.height=3.5,warnings=FALSE,messages=FALSE}
if ( is_test ) nmstotest=sample( dtinamesasymlr, 20) else nmstotest=dtinamesasymlr
dxdfDTI=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdfDTI)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( voi, " ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ ", dxform )
  bform = paste( voi, " ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+ (1|PATNO) + age_BL + commonSex    + yearsbl " )
  bform = paste( voi, " ~DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+ imaging_protocol + (1|PATNO) + age_BL + commonSex    + yearsbl " )
  newform = paste( bform, " * ", dxvar  )
  qcclow = quantile( mydog$DTI_mean_fa.splenium_of_corpus_callosum.jhu_icbm_labels_1mm, 0.01,na.rm=T )
  qcorlow = quantile( mydog$DTI_mean_fa.superior_corona_radiata.LRAVG.jhu_icbm_labels_1mm, 0.01,na.rm=T )
  qcorhi = quantile( mydog$DTI_mean_fa.superior_corona_radiata.LRAVG.jhu_icbm_labels_1mm, 0.99,na.rm=T )
  temp2 = mydog[ !is.na( mydog[,voi]) & 
    subtyper::fs(mydog$DTI_dti_FD_mean < 5.0) &
    subtyper::fs(mydog$DTI_mean_fa.splenium_of_corpus_callosum.jhu_icbm_labels_1mm > qcclow )&
    subtyper::fs(mydog$DTI_mean_fa.superior_corona_radiata.LRAVG.jhu_icbm_labels_1mm > qcorlow)&
    subtyper::fs(mydog$DTI_mean_fa.superior_corona_radiata.LRAVG.jhu_icbm_labels_1mm < qcorhi), ]
  temp2 = scale_variables_in_equation( temp2, newform )
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scale_variables_in_equation( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdfDTI[n,'voi']=voi
  dxdfDTI[n,'anv']=anvp
  dxdfDTI[n,'tyears']=mycoffs[ 'yearsbl', 4]
  dxdfDTI[n,'tcross']=mycoffs[ nrow(mycoffs)-1, 4]
  dxdfDTI[n,'tlong']=mycoffs[ nrow(mycoffs), 4]
  dxdfDTI[n,'res']=myrez
  dxdfDTI[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( anvp < 0.001 ) {
    print( mycoffs )
    print( dxdfDTI[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( voi, myrez, " + ", mydx,  " : ", anvp ) )
    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}
##########################################################
```

```{r dxresultsDT,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
###########################################################
psel = subtyper::fs( p.adjust( dxdfDTI$anv, 'BH' ) <= .05 )
dxdfDTI[ multigrep(c('mean_fa',"fornix"),dxdfDTI$voi,intersect=TRUE),'voi']='fa_fornix'
dxdfDTI[ multigrep(c('mean_md',"fornix"),dxdfDTI$voi,intersect=TRUE),'voi']='md_fornix'
dxdfDTI[ multigrep(c('mean_md',"anterior_limb_of_internal_capsule"),dxdfDTI$voi,intersect=TRUE),'voi']='md_al_int_cap'
dxdfDTI[ multigrep(c('mean_fa',"posterior_thalamic_radiation_"),dxdfDTI$voi,intersect=TRUE),'voi']='fa_post_thal_rad'
dxdfDTI[  multigrep(c('mean_md',"posterior_thalamic_radiation_"),dxdfDTI$voi,intersect=TRUE),'voi']='md_post_thal_rad'
dxdfDTI[  multigrep(c('mean_fa',"occipital_fasciculus_"),dxdfDTI$voi,intersect=TRUE),'voi']='fa_superior_fronto_occipital_fasciculus'
dxdfDTI[  multigrep(c('mean_md',"occipital_fasciculus_"),dxdfDTI$voi,intersect=TRUE),'voi']='md_superior_fronto_occipital_fasciculus'
dxdfDTI$voi=gsub(".jhu_icbm_labels_1mm","",dxdfDTI$voi,fixed=TRUE)
dxdfDTI$voi=gsub("DTI_","",dxdfDTI$voi,fixed=TRUE)
dxdfDTI$voi=gsub("dti_","",dxdfDTI$voi,fixed=TRUE)
dxdfDTI$voi=gsub("mean_","",dxdfDTI$voi,fixed=TRUE)
if ( sum( psel ) == 0  ) psel = rep(TRUE,nrow(dxdfDTI))
dxdfDTIsel = dxdfDTI[psel,]
dxdfDTIsel[,'dx']=mydx
dxdfDTIsel$anv = insight::format_p(  dxdfDTIsel$anv, digits=4  )
dxdfDTIsel[, !(colnames(dxdfDTIsel) %in% c("singular"))] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```


### mixed effects UPDRS changes over time: resting state

```{r quicklmcog,echo=FALSE,eval=buildsci,fig.width=9,fig.height=4.0,warnings=FALSE,messages=FALSE}
####################################################################
signas = c( "SIGNA_Architect", "SIGNA_EXCITE" ,   "GENESIS_SIGNA"  )
mylevsx2=c( "CN", "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "PDSporadic" )
mylevsx2=c(   "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
nmidps = getNamesFromDataframe( c("NM2DMT"), mydog, 
  exclusions=c(xcl,"_q","min","sd","pt","count","_BL","_delta","coordinate"))
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass',"_BL", "outlier_threshold")
#########################################################
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
# dxvar = 'joinedDX'
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), mydog, exclusions=c('_BL',"_delta" )),
  getNamesFromDataframe( c("DTI","Asym"), mydog, exclusions=c('_BL',"_delta") ) )
#######################################################
rsfnames = c( 
  idps[  multigrep(c("rsf","LRAVG",num,'_falff'), idps, intersect=TRUE ) ],
  idps[  multigrep(c("rsf","Asym",num,'_falff'), idps, intersect=TRUE ) ]
)
rsfnamescnx = getNamesFromDataframe( c(paste0(c("rsfMRI_fcnxpro"),num),"_2_"),  ppmi, exclusions=xcl )
#######
fdnames = getNamesFromDataframe( "_FD_", mydog  )
cogs = getNamesFromDataframe( c("updrs","score"), mydog, exclusions=c(4,'_BL',"_delta") )
col2sbl = unique(c( idpst1, dtinamesasymlr, rsfnames, rsfnamescnx,  fdnames, cogs ))
mydog = fillBaselineColumn( mydog,
        col2sbl,
        'PATNO', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
#########################################################
#########################################################
mydog$hy_BL = factor( mydog$hy_BL )
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
stadfrsf=data.frame()
nmstotest = sort( rsfnamescnx )
nmstotest = sort( rsfnames )
qth=1e-4
if ( is_test ) {
  nmstotest = sample( rsfnames, 25 )
  nmstotest = nmstotest[ -grep("Occ",nmstotest)]
  qth=0.01
}
for ( cog in sort(cogs) ) {
  for ( voi in nmstotest ) {
    n = nrow(stadfrsf)+1
    voi = paste0(voi,"_BL")
    motname = paste( 
      paste0( "rsfMRI_fcnxpro",num,"_n_outliers_BL"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL") )
    cogformcommon=paste( cog, "  ~ (1|PATNO) + AsynStatus + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + brainVolume_BL + ", motname, " + age_BL + commonSex + AsynStatus + yearsbl" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + T1Hier_resnetGrade  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
#    cogformcommon=paste( cog  , "~  (1|PATNO) + commonSex + brainVolume_BL + ( yearsbl )")
    temp2 = mydog[ !is.na( mydog[,voi]) , ]
    temp2[,voi]=psych::winsor( temp2[,voi], 0.005)
    temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
    newform = paste(  cogformcommon, " * ", voi )
    if ( nrow(temp2) > 100 ) {    
    temp2 = scale_variables_in_equation( temp2, newform )
    bmdl=suppressMessages(lmer( cogformcommon, data=temp2 ))
    mdl=suppressMessages(lmer( newform, data=temp2 ))
    mycoffs = coefficients( summary( mdl ) )
    anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
    stadfrsf[n,'cog']=cog
    stadfrsf[n,'voi']=voi
    stadfrsf[n,'anv']=anvp
    stadfrsf[n,'res']=myrez
    stadfrsf[n,'singular']=isSingular(mdl)
    if ( anvp < qth ) {
#      print( mycoffs[ , -c(1:3)] )
  #    print( voi )
      anvp = insight::format_p( anvp, digits=4 )
      ttl=( paste( voi, myrez, " + ", cog,  " : ", anvp ) )
 #     mygg = visreg::visreg( mdl, 'yearsbl', by=voi, gg=T )
 #     threewayinteraction( temp2, 'yearsbl', cog,  'AsynStatus', voi, showpoints=F )
#      print(prplot( mdl,  voi, 'yearsbl',ttl, colorvar='commonSex', addpoints=1))
      print(prplot( mdl, 'yearsbl', voi, ttl, ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      visreg::visreg( mdl, 'yearsbl', by=voi, main=ttl  )
    }
  } }
}
#####################
qdf=data.frame()
for ( cog in cogs ) {
  mypvs = stadfrsf$anv
  mypvs[ stadfrsf$cog != cog  ] = NA
  psel = subtyper::fs( p.adjust( mypvs, mycorr ) <= 0.05 )
  siganat = stadfrsf$voi[ psel ]
  if ( sum(psel) > 0 )
    qdf = rbind( qdf, stadfrsf[psel,] )
  }
###########################################################################
###########################################################################
###########################################################################
```

```{r cogresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
if ( "anv" %in% colnames(qdf) ) {
  qdf$anv = insight::format_p(  qdf$anv, digits=4  )
  qdf[,c("cog","voi","anv","res")] %>%
    knitr::kable("latex", booktabs = TRUE) %>%
    kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
}
```

### mixed models


```{r lmerextab,echo=FALSE,eval=FALSE,fig.width=12,fig.height=6,messages=FALSE,warnings=FALSE,cache=FALSE}
knitr::opts_chunk$set(cache.path = odir )
###################################################
pvaluedf = tvaluedf = data.frame()
meffdall = data.frame()
ct = 0
subtypes = c( 'LRRK2', 'Sporadic' ) # GBA
# subtypes = c('LRRK2' ) # GBA
for (  subtype in subtypes ) {
    dxs = c("CNNegative", paste0("PD",subtype,c("Negative","Positive") ) )
    ssel = subtyper::fs( clin$DXSubAsyn %in% dxs ) & commonsel
    studydata = clin[ssel,]
    print( table(round(studydata$yearsbl), studydata$DXSubAsyn) )
    sage=data.frame( stats::poly( studydata$age_BL , 2 ) )
    colnames(sage)=c("Age1","Age2")
    studydata=cbind(studydata,sage)
    studydata$SEX = factor( studydata$SEX )
    if ( FALSE ) {
        studydata$DXSubAsyn = paste0( studydata$DXSubAsyn, studydata$SEX )
        dxs2=c()
        for ( dx in dxs ) dxs2=c(dxs2,paste0(dx,levels(studydata$SEX)))
        dxs=dxs2
        }
    studydata[,'DXSubAsyn']=factor(studydata[,'DXSubAsyn'],levels=dxs)
    studydata$duration_yrs = as.numeric( studydata$duration_yrs )
    studydata$cnxtot = rowSums( studydata[,cnxnames] )
    studydata[,cnxnames]=studydata[,cnxnames]/studydata$cnxtot
    normalizeit=FALSE
    if ( normalizeit ) {
        studydata[,mdnames]=studydata[,mdnames]/studydata$meanmd
        studydata[,thknames]=studydata[,thknames]/studydata$meanthick
        }
    testnames = unique( c( t1names, dtinames, rsfnames ) )
    if ( winsval == 0.0 ) {
        isna=is.na( studydata[,testnames] )
        temp = ANTsR::robustMatrixTransform(studydata[,testnames])
        temp[ isna ]=NA
        studydata[,testnames]=temp
        }
    ####################################
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    testnames = c( 
        getNamesFromDataframe( "Asym" , studydata ),
        getNamesFromDataframe( "LRAVG" , studydata ) )
    countdtinz=rep(NA,length(testnames))
    for ( x in 1:length(testnames) ) {
        countdtinz[x]=sum( !is.na(studydata[,testnames[x]]) & studydata[,testnames[x]] > 0)
    }
    testnames=testnames[ countdtinz > 100 ]
#    testnames = testnames[ -grep("Asym",testnames)]
    studydata$meanthick = rowMeans( studydata[,thknames])
    studydata$meanmd = rowMeans( studydata[,mdnames])
    testnames = c( testnames, midnames )
    studydata = fillBaselineColumn( studydata,
        c('meanthick','meanmd','brainVolume',testnames,'hy','MOCA'), 
        'PATNO', 'imaging_EVENT_ID', 'V0', 
        fast=T, verbose=F )[[1]]
    for ( x in  c('meanthick','meanmd','brainVolume',testnames) ) {
#        studydata=baseimpute( studydata, x )
#        studydata=visitimpute( studydata, x, 2 )
        }
    if ( FALSE )
        testnames = c( 
            "T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168",
            'T1Hier_vol_bn_str_pu_LRAVGdeep_cit168','DTI_mean_md_Asym_rostral_middle_frontal')
    for ( testvols in testnames ) {
        ct = ct + 1
        studydata$testvol = studydata[ ,testvols]
        studydata$testvol_BL = studydata[ ,paste0(testvols,"_BL")]
        studydata$testvol_delta = studydata[ ,paste0(testvols,"_delta")]
        studydata$testvol_delta = psych::winsor(studydata$testvol_delta,tr=winsval)
        studydata$SEX = factor( studydata$SEX )
        toscale = c('snr','psnr','EVR','age_BL','DTI_dti_FD_mean','T1Hier_resnetGrade','DTI_dti_tsnr_b0_mean','testvol_BL','brainVolume_BL','EDUCYRS', 'MOCA_BL', 'hy_BL' )
        studydata$EDUCYRS=as.numeric(studydata$EDUCYRS)
        studydata[,toscale]=scale(studydata[,toscale])
        studydata$EDUCYRS = scale(ANTsRCore::antsrimpute(as.numeric( studydata$EDUCYRS )))
        covars=covars0
        covarsx=covars0x
        if ( length(grep("DTI_",testvols)>1 ) ) {
            covars=paste(covars0,dticovars)
            covarsx=paste(covars0x,dticovars)
        }
        bform=paste( covars, " + yearsbl ")
        myform=paste( covars, " + yearsbl * ( DXSubAsyn )")
        # https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3281513/
        # section: Advantages and Disadvantages of Fixed Main Effect for Site
        bformx=paste( "testvol~",covarsx, " + yearsbl ")
        myformx=paste( "testvol~",covarsx, " + yearsbl * ( DXSubAsyn )")
        isblsub = studydata$PATNO[ studydata$imaging_EVENT_ID=='V0' ]
        isfsub = studydata$PATNO[ studydata$imaging_EVENT_ID !='V0' ]
        isboth = intersect( isblsub, isfsub )
        studydatasub = studydata[ studydata$PATNO %in% isboth,]
        bmdl = try( lmer( bform,data=studydata ) )
        mdl = try( lmer( myform,data=studydata ) )
        bmdlx = lmer( bformx,data=studydata )
        mdlx = lmer( myformx,data=studydata )
        if ( FALSE ) {
            # simple regression for BL vs follow
            lmdata = data.frame( )
            fillvars = all.vars( as.formula( myform ) )
            rmers = multigrep( c("testvol_delta","testvol","PATNO",#"yearsbl",
                "DTI_dti_tsnr_b0_mean","mrimfg"), fillvars, intersect=FALSE )
            lmform = paste( fillvars[1], "~(1|PATNO)+testvol_BL+",paste(fillvars[-rmers],collapse="+"))
            mdlLM = lmer( lmform,data=studydatasub)
#            mycoffsX = coefficients(summary( mdlLM ))
#            if ( any(tail(mycoffsX[,"Pr(>|t|)"],2) < 0.005 )) {
#                print( visreg::visreg(mdlLM,'DXSubAsyn',gg=TRUE)+ggtitle(testvols))
#                print( mycoffsX )
#                print( testvols )
#                }
            }
        if ( !is( mdl, "try-error" ) ) {
            mycoffx = coefficients(summary(mdlx))[-c(1:2),-c(1:2)]
            mycoffx = mycoffx[ grep(subtype,rownames(mycoffx)), ]
            mycoffx = mycoffx[ -grep("yearsbl",rownames(mycoffx)),]
            mycoff = coefficients(summary(mdl))[-c(1:2),-c(1:2)]
#            mycoff = mycoff[ grep(subtype,rownames(mycoff)), ]
            mycoff = rbind(
                mycoffx[grep(subtype,rownames(mycoffx)),],
                mycoff[multigrep(c("yearsbl",subtype),rownames(mycoff),intersect=T),])
            if ( nrow( pvaluedf ) == 0 ) {
                myoc = rownames(mycoff)
                myoc = gsub("yearsbl:","y.",myoc)
                myoc = gsub("Negative","Neg",myoc)
                myoc = gsub("Positive","Pos",myoc)
                myoc = gsub("DXSubAsyn","",myoc)
                myoc = gsub(paste0("PD",subtypes[1]),"",myoc)
                outcomes = c("subtype",  myoc )
                noutcomes = length(outcomes)
                pvaluedf = data.frame( matrix(ncol=noutcomes) )
                colnames(pvaluedf )=outcomes
                tvaluedf=pvaluedf
            }
            tvaluedf[ct, outcomes] = c(subtype,mycoff[,"t value"])
            pvaluedf[ct, outcomes] = c(subtype,mycoff[,"Pr(>|t|)"])
            anvx = anova(bmdlx,mdlx)$Pr[2]
            anv = anova(bmdl,mdl)$Pr[2]
            pvaluedf[ct,'anova'] = anv
            pvaluedf[ct,'anovax'] = anvx
            tvaluedf[ct,'anat'] = pvaluedf[ct,'anat']=testvols
            if (  pvaluedf[ct,'anova'] < qthresh | pvaluedf[ct,'anovax'] < qthresh  )
                {
                nstring = getnstring( 'DXSubAsyn')
                pvformattedx=insight::format_p( anvx, stars=TRUE, digits=4 )
                pvformatted=insight::format_p( pvaluedf[ct,'anova'], stars=TRUE, digits=4 )
                cat( paste0( "\n\n****************************************************************\n\n" ) )
                cat( paste0( testvols," anv ", pvaluedf[ct,'anova'], " ****************\n\n" ) )
                print( mycoff[,-1] )
                mydegfree = round( (mycoff[,'df']) )
                meff = effectsize::t_to_d( mycoff[,'t value'], mydegfree )
                rownames(meff) = rownames(mycoff)
                myrownames = rownames(mycoff)
                myrownames = gsub("yearsbl","years",myrownames)
                myrownames = gsub("DXSubAsynPD","",myrownames)
                meffd = data.frame(meff)
                meffd$eff=myrownames
                meffd$anat = testvols
                meffd$dx = "Pos"
                meffd$dx[ grep("Neg",myrownames)]='Neg'
                if ( nrow(meffdall) == 0 ) meffdall=meffd else meffdall = rbind(meffdall,meffd)
                print( ggbarplot( meffd, 'eff','d', color='dx', fill='dx', 
                    palette='npg' ) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Long and cross effect sizes (d):",testvols)) + geom_errorbar(aes(ymin=CI_low, ymax=CI_high), width=.1,
                    position=position_dodge(.5))  )
                mypal = 'lancet'
                (prplot( mdlx,'yearsbl',  'DXSubAsyn',color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformattedx,"\n",nstring))) %>% print()
#                (prplot( mdl,  'yearsbl', 'DXSubAsyn', color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformatted,"\n",unlist(strsplit(nstring,"\n"))[2]))) %>% print()
                studydatasub$yearr=round( studydatasub$yearsbl )
                temp = table( studydatasub[,'PATNO'] )
                tsel = ( studydatasub$yearr %in% c(0,1,2,4) ) & 
                    studydatasub$PATNO %in% names(temp)[temp>=2]
                yername=gsub("T1Hier_","",testvols)
                yername=gsub("DTI_","",yername)
                yername=gsub("dktregions","",yername)
                yername=gsub("jhu","",yername)
                if ( TRUE ) {
                    nlevs = length( levels( studydatasub[,'DXSubAsyn'] ))
                    manualColors = pal_lancet("lanonc", alpha = 0.9)(nlevs)
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol_delta",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : change")) +
                        scale_colour_manual(values = manualColors ) )
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : raw")) +
                        scale_colour_manual(values = manualColors ) )
#                    ggscatter( studydata, 'yearsbl', "brainVolume", facet.by='DXSubAsyn', color='DXSubAsyn', add='reg.line', conf.int=T, cor.coef=T, parse=T, palette=manualColors ) %>% print()

                    # now test the TPL hypotheses
                    testcog=TRUE
                    if ( testcog ) {
                        subcohort = studydatasub[ studydatasub$DXSubAsyn != 'CNNegative',]
                        subcohortbl = studydatasub[ studydatasub$DXSubAsyn !=     
                            'CNNegative' &
                            studydatasub$imaging_EVENT_ID == 'V0', ]
                        myst = trainSubtypeUni( subcohortbl, "testvol",
                            c("Alow","Amid","Ahigh"), quantiles = c(0.33,0.66) )
                        subcohort = predictSubtypeUni( subcohort, myst, 'PATNO', 
                            'imaging_EVENT_ID', 'V0')
                        for ( cog in coggers ) {
                            cogform=paste( cog , "~", commcov, "+AsynStatus+subtype*yearsbl" )
                            cogmdl = try( lmer( cogform, data=subcohort ) )
                            cogcoff=coefficients(summary(cogmdl))
                            cogcoff=cogcoff[grep("subtype",rownames(cogcoff)),]
                            if ( any( cogcoff[,"Pr(>|t|)"] < 0.001 ) ) {
                                message(paste(testvols,cog))
                                print(paste("COGGER",cog))
                                print( cogcoff[,-c(1:2)] )
                                cogpvform = insight::format_p( 
                                    min(cogcoff[,"Pr(>|t|)"]),
                                    stars=TRUE, digits=4 )
                                (prplot( cogmdl,'yearsbl',  'subtype',color='subtype', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,"COGGER",cog,"\n",cogpvform))) %>% print()
                                pvaluedf[ct,cog]=min(cogcoff[,"Pr(>|t|)"])
                            }
                        }
                    }

                }
            }
        }
    }
    cat("****************\n\n")
} # subtype loop
##########################################################
##########################################################
if ( FALSE )
for ( subtype in subtypes[1:2] ) {
    print(subtype)
    pvaluedfsub = pvaluedf[ pvaluedf$subtype == subtype, ]
    sel=p.adjust( pvaluedfsub[,'anova'], corrmet ) <= 0.05
    print( pvaluedfsub[ sel, c("Neg","Pos","Y.Neg","Y.Pos","anat")] )
    cat(">>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<\n\n")
}
##########################################################
##########################################################
```


# Usage Notes

An example of processing used here is shown in the github respository [https://github.com/stnava/ANTPD_antspymm](https://github.com/stnava/ANTPD_antspymm) where we combine easily accessible multi-view neuroimaging with our open source methods for demonstration purposes.  All images referred to in this research were processed in a style identical to this example.


# Code availability

ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM). The version used for this work is `1.2.7` along with tensorflow `2.11.0`, antspyx `0.4.2`, antspynet `0.2.3` and antspyt1w `0.9.1`.

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work.

# Author contributions statement

...

# Competing interests

...

# Figures & Tables

Figures, tables, and their legends, should be included in the appropriate section of the document. Figures and tables can be referenced using Markdown syntax.

Figure: Legend (350 words max). Example legend text.

| Condition | n  | p     |
|-----------|----|-------|
| A         | 5  | 0.1   |
| B         | 10 | 0.01  |
Table: Legend (350 words max). Example legend text.


