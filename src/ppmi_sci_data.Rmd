---
title: "Magnetic Resonance Imaging Data Phenotypes for the Parkinson's Progression Markers Initiative"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1
  - Leon Fonville^3,†^
  - Olivia Hampton^1,†^
  - Alex Reardon^1,†^
  - Nicholas J. Tustison^2
  - Philip A. Cook^4
  - Xue Wang^1,†^
  - Linda
  - Zahra
  - Adam
  - Barbara?
  - Roger Gunn?
  - Kathleen L Poston?
  - Ken?
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: University of Virginia, Department of Radiology and Medical Imaging, Charlottesville, VA, FIXME, USE"
  - "3: Invicro, FIMXE, UK"
  - "4: UPENN, FIMXE, Philly"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: 
  pdf_document:
    keep_tex: true
    template: null
#    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmiscidata.bib
classoption: table
header-includes:
  - \usepackage{multirow}
  - \usepackage{rotating}
linenumbers: true
urlcolor: blue
# nocite: '@*'
link-citations: true
---


```{r samplesizes,echo=FALSE,eval=TRUE}
redomerge=TRUE
if ( ! exists("buildsci"))buildsci=FALSE
```


```{r ppmimerge, echo=FALSE,eval=redomerge}
library(ztable)
library(moonBook)
library(plyr)
library(subtyper)
library(forcats)
library(lmerTest)
library(lme4)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(mclust)
library(MASS)
library(dCUR)
library(mlr3learners)
library(ANTsR)
library(mlr3verse)
if ( ! exists("clin2b") ) {
  rdir=path.expand('~/code/multidisorder/data/')
  rdir=path.expand('~/Downloads/ppmi_pym_data/')
  if ( ! exists("pymf") ) {
    pymfns = data.frame( 
      fns=c( 
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRNext_v1.2.7.csv')  ),
      rez=c("OR","SRF","SRP") )
    print(paste("ANTsPyMM Pipeline : ", myrez ) )
    pym = read.csv(  pymfns$fn[pymfns$rez == myrez ] )
    pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
    pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
    pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
    pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
    rm(pym)
    }
  adni = read.csv( path.expand("~/code/multidisorder/data/adni_gwas/ADNIMERGE_10Feb2024_antspymm_v1.2.7.csv") )
  studynames=c("ADNI", "NIFD4RTNI", "PPMI","UKBB","A4")
  dxnames= c("DX_bl", "DX", "DXSub", "DX", "DX" )
  sexnames=c("PTGENDER","SEX","SEX","sex_f31_0_0","PTGENDER")
  agenames=c("AGE","Age_BL","age_BL","subjectAge_BL","PTAGE")
  edunames=c("PTEDUCAT","EDUCATION","EDUCYRS","age_completed_full_time_education_f845_0_0","PTEDUCAT")
  sidnames=c("PTID","LONI_ID","PATNO","eid","sid")
  viznames=c("Years.bl","deltaTime","yearsbl","Years.bl","Years.bl")
  adni$commonSex = adni$PTGENDER
  adni$commonEdu = adni$PTEDUCAT
  adni$commonID = adni$subjectID = adni$PTID
  adni$age_BL = adni$age = adni$AGE
  adni$yearsbl = adni$Years_bl
  adni$joinedDX = adni$DX_bl
  adni$joinedDX[ grep("MCI",adni$joinedDX)]="MCI"
  adni$joinedDX[ adni$joinedDX == ""]=NA
  adni$studyName='ADNI'
  adniasynfn = path.expand( "~/code/multidisorder/data/adni_gwas/AMPRION_ASYN_SAA_13Nov2023.csv")
  adniasyn = read.csv( adniasynfn )
  names( adniasyn )[ names(adniasyn) == 'Result']='AsynStatus'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Detected-1','Detected-2')) , 'AsynStatus'] = 'Positive'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Not_Detected','Indeterminate')), 'AsynStatus' ] = 'Negative'
  # map 
  adni$AsynStatus=NA
  uids = unique( adniasyn$RID[!is.na(adniasyn$AsynStatus)])
  for ( k in 1:nrow(adniasyn) ) {
        losel = subtyper::fs( adni$RID == adniasyn$RID[k] )
        if ( sum(losel) > 0 ) {        
            adni$AsynStatus[ losel ] = adniasyn$AsynStatus[k]
        }
    }
  demog=read.csv(paste0(rdir,"Demographics_06Feb2024.csv"))
  curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20230612_rev.csv')
  saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv')
  if ( ! file.exists( saafn ) ) {
    saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023.csv')
    }
  saa=read.csv( saafn )
  ppmidemog0=read.csv( curfn )
  clin2b = merge_ppmi_imaging_clinical_demographic_data(
    demog, ppmidemog0, pymf, pymversion=myrez, saa )
  # add tracker
  tracker = read.csv(paste0(rdir,"ppmi_2_0_internal_scan_tracking_report_v12-2024-02-08.csv"))

  tracker = tracker[ tracker$Modality == "MR", ]
  tracker$EVENT_ID=tracker$Visit
  tracker$EVENT_ID[ grep("Baseline",tracker$EVENT_ID)]="BL"
  tracker$date=NA
  momap=data.frame( num=c( paste0("0",1:9), "10", "11", "12") )
  rownames(momap)=c("JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC")
  for ( k in 1:nrow(tracker) ) {
    fixedev=unlist(strsplit( tracker$Visit[k], "/"))
    if ( length( fixedev ) > 1 ) fixedev=fixedev[length( fixedev )]
    tracker$EVENT_ID[k]=fixedev
    fixeddt = unlist(strsplit( tracker$Scan.Date[k],"-"))
    fixeddt[2] = momap[ fixeddt[2], 'num' ]
    fixeddt = paste0( fixeddt[3] , fixeddt[2], fixeddt[1] )
    tracker$date[k]=fixeddt
    }
  trackersub = tracker[, c("Subject.ID","date" )]
  trackersub$imaging_protocol=2
  names(trackersub)=c("PATNO","date", "imaging_protocol" )
  clin2b=merge( clin2b, trackersub, by=c("PATNO","date"), all.x=TRUE )
  clin2b$imaging_protocol[ is.na(clin2b$imaging_protocol) ]=1
  # add LRRK2 
  lrrk2 = read.csv( paste0(rdir,'CSFSAA_LRRK2_MRI_SAMPLES_08Jan2024/Data-Table1.csv'))
  lrrk2$SAAGroup[ lrrk2$SAAGroup == " " ]=NA
  clin2b$LRRK2_study=NA
  uids = lrrk2$PATNO
  lrrk2cols = colnames(lrrk2)
  lrrk2cols=lrrk2cols[ !(lrrk2cols %in% "PATNO") ]
  newcols = paste0("LRRK2_", lrrk2cols )
  clin2b[,newcols]=NA
  for ( k in 1:length(uids) ) {
    clin2bsel = clin2b$PATNO == uids[k]
    if ( sum( clin2bsel ) > 0 ) {
      # print(paste("have",u))
      clin2b[clin2bsel,newcols]=lrrk2[k,lrrk2cols]
    } # else print(paste("miss",u))
  }
  clin2b$LRRK2_study = !is.na( clin2b$LRRK2_cohort)
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_dwi_mean +T1Hier_evratio + noise + snr + msk_vol,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+T1Hier_resnetGrade +T1Hier_evratio + cnr + noise,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~  cnr + noise  + msk_vol + spc0+	spc1+	spc2,data=clin2b) )
  clin2b$subjectID = as.character(clin2b$subjectID)
  clin2b$imageID = as.character(clin2b$imageID)
  clin2b$dtid1 = as.character(clin2b$dtid1)
  clin2b$dtid2 = as.character(clin2b$dtid2)
  clin2b$rsfid1 = as.character(clin2b$rsfid1)
  clin2b$rsfid2 = as.character(clin2b$rsfid2)
  clin2b=dplyr::bind_rows( clin2b, adni )
  nna=!is.na( clin2b$AsynStatus )
  clin2b$DXSubAsyn[nna]=paste0( clin2b$joinedDX[nna], clin2b$AsynStatus[nna] )
  clin2b$DXSubAsyn[ clin2b$DXSubAsyn == "NANegative"]=NA
  clin2b$commonEdu[ clin2b$commonEdu == 1] = 12
  clin2b$commonEdu[ clin2b$commonEdu == 2] = 16
  clin2b$commonEdu[ clin2b$commonEdu == 3] = 20
}
ppmi = clin2b
ppmi$brainVolume = ppmi$T1Hier_vol_hemisphere_lefthemispheres + ppmi$T1Hier_vol_hemisphere_righthemispheres
ppmi$brainVolume = ppmi$brainVolume / mean(ppmi$brainVolume)
ppmi$imaging_protocol[ ppmi$studyName=='ADNI']=3
ppmi$imaging_protocol=factor(ppmi$imaging_protocol)
ppmi[ ppmi$studyName=='ADNI', 'age_BL']=ppmi[ ppmi$studyName=='ADNI', 'AGE']

```


```{r maketrim,echo=FALSE,eval=!exists("ppmitrim")}
ppmi = antspymm_predictors( ppmi, TRUE )
ntokeep = 2950
ppmitrim = ppmi[ ppmi$studyName == 'PPMI',]
ppmitrim = ppmitrim[ head( order(ppmitrim$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
updnames = getNamesFromDataframe("upd",ppmi,exclusions=c("BL","delta"))
msnames = getNamesFromDataframe("pm_",ppmi,exclusions=c("BL","delta"))
lrrk2names= getNamesFromDataframe("LRRK2_",ppmi,exclusions=c("BL","delta","LRRK2_MRIPROTOCOL"))
t1namesctx = getNamesFromDataframe( c("T1Hier","LRAVG",'dktcortex','thk'), ppmitrim)
t1namescit = getNamesFromDataframe( c("T1Hier","LRAVG",'deep','vol'), ppmitrim)
t1namesnbm = getNamesFromDataframe( c("T1Hier","LRAVG",'nbm','vol'), ppmitrim)
t1namesbst = getNamesFromDataframe( c("T1Hier",'brainstem','vol'), ppmitrim, exclusions=c("tissues","lobes"))[-1]
t1namescrb = getNamesFromDataframe( c("T1Hier",'cerebellu','LRAVG','vol'), ppmitrim, exclusions=c("tissues","lobes","dktregion"))
t1namesctxa = gsub("LRAVG","Asym",t1namesctx)
t1namescita = gsub("LRAVG","Asym",t1namescit)
t1namesnbma = gsub("LRAVG","Asym",t1namesnbm)
t1namescrba = gsub("LRAVG","Asym",t1namescrb)
t1vars = c(t1namesbst,t1namesctx,t1namescit,t1namesnbm,t1namescrb,t1namesctxa,t1namescita,t1namesnbma,t1namescrba)
ppmitrim0 = ppmitrim[ , c("subjectID","age_BL",'commonSex', "hy_BL", "duration_yrs","LEDD","moca",updnames, msnames, 'joinedDX','AsynStatus', "DXSubAsyn", "educ","race",'tau','ptau','abeta', 'yearsbl', 'EVENT_ID', 'date', lrrk2names,  'filename', 'brainVolume', t1vars, 'imaging_protocol', 'T1Hier_resnetGrade' ) ]

# write.csv( ppmitrim0, '~/Downloads/ppmitrim0_SR_first_extended.csv',row.names=FALSE)
# head( ppmitrim0, 2 )
# isbl=subtyper::fs(ppmitrim$yearsbl==0 & ppmitrim$joinedDX == 'PDSporadic')
# temp=ppmitrim[isbl,]
# trimT1 = dcurvarsel( temp, c(t1namesctx,t1namescit), 1 )

# get numbers for abstract
viztbl = table( ppmitrim0$joinedDX, ppmitrim0$EVENT_ID )
isbl=ppmitrim0$yearsbl==0
npd=viztbl["PDSporadic","BL"]
npdf=sum(viztbl["PDSporadic",c("V04","V06","V08","V10","V12")])
ngpd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('PDGBA','PDLRRK2','PDSNCA' )))
ncn=viztbl["CN","BL"]
nprepd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('ProdromalGBA','ProdromalLRRK2' ,'ProdromalSNCA','ProdromalSporadic' )))
vizfll=mean( ppmitrim0$yearsbl[!isbl] )
vizfll=insight::format_value( vizfll )
# tt = table( table( ppmitrim0$subjectID[!isbl] ) )

```

# Abstract

The Parkinson's Progression Markers Initiative (PPMI) delivers multiple modality MRI (M3RI) and biomarker data for a comprehensive longitudinal study of Parkinson's Disease (PD).  These provide quantitative indices of deep brain and cortical structure (T1-weighted MRI), axonal integrity (diffusion-weighted imaging) and resting brain function (resting state functional MRI).  Integrating and uniformly analyzing M3RI alongside non-imaging biological and clinical data is challenging due to the distinct nature of each modality. This study systematically organizes this complex data into a structured format, provides a PD-focused evaluation of the methodologies and evidence for technical robustness of the approach.  The cohort encompasses `r npd` idiopathic PD, `r ngpd` genetic PD, `r nprepd` presymptomatic PD and `r ncn` control subjects at baseline with followup at a mean of `r vizfll` years.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy bodies, primarily composed of misfolded alpha-synuclein, and appearing in the substantia nigra at an early stage [@fearnley_ageing_1991]. The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [@lee_mechanisms_2006;@dickson_neuropathology_2009;@calabresi_alpha-synuclein_2023]. The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [@shahnawaz_discriminating_2020; @siderowf_assessment_2023].

Analyzing the link between SAA status and longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking pathology, symptoms and imaging [@nemmi_totally_2019; @tremblay_sex_2020; @markello_multimodal_2021].

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI from 2010 to 2023, focusing on T1-weighted, diffusion-weighted, and resting-state functional MRI for analyzing neurodegenerative diseases. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [@avants_pediatric_2015; 
@stone_functional_2020; @tustison_antsx_2020]

To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] and an additional easily accessible M3RI young control cohort [@avants_pediatric_2015].  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate the neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [@schwarz_t1-weighted_2011;@aquino_substantia_2014;@ryman_mri_2020]. Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [@peran_magnetic_2010] but also in LRRK2-PD [@tolosa_lrrk2_2020]. Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [@hacker_resting_2012;@kim_abnormal_2017]. Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain, pointing towards a more integrative approach to understanding PD [@menke_mri_2009;@markello_multimodal_2021] and the role of alpha-synuclein in these effects [@simuni_biological_2024].

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs are computed with [ANTsPyMM](https://pypi.org/project/antspymm/) and depend on standard anatomical and functional hierarchies that are well-established in the field and consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dwMRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables easily merge with the associated demographics, SAA status, clinical data such as the Unified Parkinson's Disease Rating Scale (UPDRS) [@disease_unified_2003] and standard PPMI DAT-SPECT summary measurements [@bega_clinical_2021; @droby_aberrant_2022]. Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.


# Methods

![Overview of ANTsPyMM outputs for T1-weighted MRI, diffusion MRI and resting state fMRI.  Panel (a) shows example input data; the package does not require all modalities to be present -- only T1w.  It also handles arterial spin labeling (perfusion), FLAIR and neuromelanin, not covered here.  Panel (b) illustrates core T1w outputs across several inter-related and PD relevant systems in the brain.  Panel (c) shows the standard outputs associated with DTI. Whole brain tractography is also output but no evaluation results are available to contextualize its performance and, as such, we do not recommend its use.  Panel (d) summarizes the various rsfMRI outputs for processing parameter set number 122 referred to with a prefix `rsfMRI_fcnxpro122`.](../figs/antspymm_3.jpg)

## MRI data collection 

MRI data collection occurred between 2010 and an August 2023 cutoff date for these data.  Two phases of MRI collection occurred in PPMI; the first collected T1w and later DTI as part of exploratory investigations.  In 2020, a new phase of collection sought to improve both MRI quality and consistency and expand the number of modalities collected.  The details of the sequences used is covered elsewhere **Lino - FIXME IS IT? CITATION?*. The "phase" of data collection is captured in the variable `imaging_protocol`.  Table FIXME summarizes the cohort characteristics.


```{r tblprep,eval=TRUE,echo=FALSE,cache=FALSE}
###
toadd = c(  "age_BL", "commonSex", 'race',  'hy_BL', 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD', 'imaging_protocol')
biomarkers = c('abeta', 'tau',  'nfl_serum', 'mean_striatum' )
tblcols = unique( c( toadd, 'joinedDX' ))
joinedem=ppmi[ppmi$yearsbl==0,tblcols]
joinedem$hasDTI=!is.na(ppmi[ppmi$yearsbl==0,'DTI_dti_FD_mean'])
joinedem$hasfMRI=!is.na(ppmi[ppmi$yearsbl==0,'rsfMRI_fcnxpro129_FD_mean'])
names(joinedem)[1]=tblcols[1]='age'
names(joinedem)[2]=tblcols[2]='Sex'
wsaa=which(names(joinedem)=='AsynStatus' )
names(joinedem)[wsaa]=tblcols[wsaa]='CSFSAA'
tblcols=colnames(joinedem)
tblcols=gsub("_",".",tblcols)
tblcols=gsub(".mean","",tblcols)
tblcols=gsub("DTI.","",tblcols)
tblcols=gsub("rsfMRI.fcnxpro122.","rsfMRI.",tblcols)
names(joinedem)=tblcols
joinedem$race = as.character( joinedem$race )
joinedem[ is.na(joinedem$race), 'race' ] = 'not.spec.'
joinedem$joinedDX = gsub("Prodromal",'AR',joinedem$joinedDX)
joinedem$joinedDX=as.character(joinedem$joinedDX)
joinedem$joinedDX[ 
  multigrep( c("ARSporadic"), joinedem$joinedDX )]='SporadicAR'
joinedem$joinedDX[ 
  multigrep( c("ARGBA", "ARLRRK2",  "ARSNCA"), joinedem$joinedDX )]='GenAR'
joinedem$joinedDX[ 
  multigrep( c("PDGBA",    "PDLRRK2", "PDPRKN", "PDSNCA"), joinedem$joinedDX )]='GenPD'
joinedem$joinedDX[ 
  multigrep( c("PDSporadic"), joinedem$joinedDX )]='SporadicPD'
mlevs = c( "CN", "GenAR", "SporadicAR","GenPD", "SporadicPD")
joinedem$joinedDX = factor( joinedem$joinedDX, levels = mlevs )
mytbl = joinedem[,c(tblcols)]
mycap="Table 1. Baseline cohort for subjects with T1w IDPs and non-missing diagnosis."
####
```

```{r clusterCharARtbl,eval=TRUE,echo=FALSE,cache=FALSE,results='asis'}
sttblPD=ztable(mytable(joinedDX~.,data=mytbl[,tblcols]))

# Print the ztable object, ensuring it's treated as LaTeX code
print(sttblPD, type = "latex",size=4,caption=mycap,sidewaystable=TRUE)


```


```{r tbl1instead,eval=FALSE,echo=FALSE,cache=FALSE,results='asis'}
library(table1) # https://cran.r-project.org/web/packages/table1/vignettes/table1-latex.pdf
x=table1(~ . | joinedDX, data=mytbl[!is.na(mytbl$joinedDX),], topclass="Rtable1-zebra",caption=mycap)
t1kable(x)
```

### Semi-automated quality assessment

Each T1w image was reviewed by a `resnetGrader` (a deep learning model trained to predict image quality) [@avants2022] as well as inspected visually for usability.  The visual inspection is performed by BA and serves as a sanity check to the automated method.  The `resnetGrader` successfully filtered unusable data and we selected a  quality cutoff at `r min(ppmitrim$T1Hier_resnetGrade)` to filter out low quality images.  Similarly, the rsfMRI and DTI were visually inspected in `post hoc` fashion.  This process involved visually inspecting each estimated FA image and each estimated default mode network connectivity map and its associated mean BOLD image.  Particular focus was paid to cases with high motion and/or low SNR.

## Neuroanatomical coordinate systems

The statistical interpretation of processed images is aided by automatic anatomic labeling with pre-specified coodinate systems or maps overlaid on each subject's neuroimage. We leverage a recent homotopic parcellation [@FIXME], the Desikan-Killiany-Tourville (DKT) system [@FIXME], the CIT168 atlas [@FIXME], the Johns Hopkins University (JHU) white matter labels [@FIXME], the Schmahmann cerebellar parcellation [@FIXME], brain stem labels [@FIXME], a medial temporal lobe schema [@FIXME] and labels derived from probabilistic maps of the basal forebrain [@FIXME].  These systems are described in detail in the data dictionary and associated documentation. These coordinate system enable PD researchers to interrogate a variety of hypotheses related to, for example, functional networks, cholinergic networks, the striatum or dopaminergic systems.

### T1-weighted MRI processing

T1-weighted MRI processing is described in detail in @tustison_antsx_2021. This open-source software ecosystem includes tools for image registration, segmentation, and super-resolution (SR) as customized for the human brain.  The derived measurements are tabulated by the neuroanatomical coordinates defined above and include cortical and subcortical measurements and morphological measurements of the hippocampus, basal forebrain and cerebellum.  The processing results of this stage are key to consistent processing of concomitant rsfMRI and DWI. We provide both original resolution (OR) and SR results as part of this effort.  For SR processing, the network is applied -- first -- over the whole head T1w image to double resolution along all axes.  Otherwise, SR and OR processing are identical. SR training with 3D perceptual losses is documented in the `python` package [siq](https://pypi.org/project/siq/) and is based on `tensorflow` implementations of a volumetric deep back projection network (DBPN) [@FIXME].  See Figure FIXME for examples of these outputs. Outputs from the T1 processing are denoted by prefixes `T1Hier` and `T1w`.

![Example ANTsPyMM SR outputs applied to T1-weighted MRI (upper left) and diffusion MRI. T1w is super resolved to 0.5mm isotropic and DTI to 1mm.](../figs/sr_comparison.jpg)

### Diffusion weighted MRI processing

Diffusion tensor imaging (DTI) processing leverages best practices from both ANTsX [@FIXMEPTBP] and the collaborative DTI-focused project [DiPy](https://www.frontiersin.org/articles/10.3389/fninf.2014.00008/full). This pipeline is specifically designed to utilize DWI acquisitions with either a single or opposed phase encoding directions. The functionality has been developed to address a broad spectrum of preprocessing requirements, such as motion correction, denoising, dewarping and gradient reorientation, and enhancement through SR techniques, culminating in an optimized DTI reconstruction. Additionally, it integrates atlas-based labeling and registration processes, thereby enhancing the anatomical interpretability of the DTI metrics.  Figure FIXME summarizes the pipeline which follows these steps:

![Overview of the DTI processing pipeline based on ANTsX and DiPy.](../figs/dti_pipe.jpg)

1. **Input Preparation**: The pipeline accepts either a single DWI or a pair of DWI with reversed phase encoding. It also requires associated b-values and b-vectors for each direction, alongside a T1-weighted image and a brain mask for improved spatial accuracy in inter-modality registration.

2. **Initial Reconstruction and Motion Correction**: By default, the DWI data is denoised before performing motion correction. Motion correction aligns DWI volumes within and across acquisitions to a reference mean B0 and mean DWI, reducing artifacts due to subject movement.

3. **Dewarping and Super-Resolution**: Dewarping is applied to correct for distortions between the DWI space and the T1-weighted image. Optionally, SR is applied after dewarping but before the DiPy based reconstruction process.

4. **Reconstruction of DTI Metrics**: The function employs weighted least squares to reconstruct DTI metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD) from the preprocessed DWI data. This step is pivotal in quantifying the diffusion properties of brain tissue. 

5. **Atlas-Based Labeling and Registration**: Utilizing the Johns Hopkins University (JHU) atlas and corresponding labels, the pipeline performs spatial registration of the DTI to the atlas space. This process facilitates anatomical localization and quantification of DTI metrics within predefined brain regions. 

6. **Output Generation**: The pipeline yields a comprehensive output including the reconstructed DTI metrics, summary statistics of these metrics within atlas-defined regions, the spatial registration information, and additional diagnostic metrics such as framewise displacement and signal-to-noise ratio (SNR) assessments spatially and temporally for both B0 and DWI. An example output volumetric tensor image with labels is in Figure FIXME.

Outputs from the DWI processing are denoted by prefixes `DTI_`.

![Example SR processing for DTI highligting the multiple coordinate systems that are available to aid interpretation.](../figs/dti_SR.jpg)


### Resting state functional MRI processing 

Resting state functional MRI (rsfMRI) processing builds on prior multi-view techniques performed in this same ecosystem [(avants2015)](https://www.nature.com/articles/sdata20153) [avants2016](https://doi.org/10.1016/j.neurobiolaging.2018.10.002).  The procedure is based on the findings described in three comprehensive evaluation studies [@FIXME] and is designed to compute both functional activity and correlation maps utilizing the recently proposed homotopic labels to delineate major network systems [@FIXME]. The methodology described below is grounded in contemporary understanding of resting-state fMRI analysis and incorporates recommendations from seminal works regarding optimal preprocessing for minimizing motion artifacts and other sources of noise (Ciric et al., 2017; Parkes et al., 2018). As such, our processing reflects a comprehensive approach to resting-state fMRI IDP extraction for real-world multi-site studies of neurodegenerative disease.  Overall, the methods aim to facilitate the reliable extraction of functional connectivity patterns that are consistent with underlying neural mechanisms.  Similar to the DWI processing, the procedure accepts either a single image or a pair of images with reversed phase encoding direction.  The steps are outlined in Figure FIXME:

![Overview of the rsfMRI processing pipeline based on ANTsX.](../figs/fmri_pipe.jpg)

1. **Input Preparation**: Inputs include the raw BOLD fMRI time-series data, a reference volumetric subject-specific fMRI template, and T1-weighted anatomical images all from the same subject. These inputs are foundational for aligning functional data with anatomical landmarks and for ensuring that subsequent analyses are anatomically informed.  By default, the input fMRI is upsampled to 3mm isotropic resolution and 8 initial volumes are discarded to allow for both signal and subject stabilization.

2. **Preprocessing**: Initial steps include motion correction, application of a despiking algorithm (a `python` implementation of AFNI's 3dDespike [@FIMXE]), and anatomical registration to align the fMRI data with the T1-weighted image.  If a pair of images is passed, these are concatenated along the time axis.

3. **Noise Reduction**: Anatomical CompCor (aCompCor) is used to mitigate physiological and other noise sources. This is based on recommendations from studies examining the impact of preprocessing strategies on functional connectivity (Ciric et al., 2017; Parkes et al., 2018).

4. **Band-pass Filtering and activity calculation**: The application of a specific frequency range for filtering aligns with recommendations from Shirer et al. (2015) and Parkes et al. (2018), emphasizing the importance of selecting appropriate frequency bands for resting-state analysis.  The default frequency bands are based on empirical evaluation studies described below.

5. **Censoring**: Select volumes are censored based on both motion-based and intensity-based outlier detection.  The parameters for this stage derive from empirical evaluation studies on publicly available data as discussed below.  Both *censored* and *imputed* versions of the time series are created.  A summary of censoring results is recorded in several ways but perhaps most relevant are the variables `*minutes_original_data` and `*minutes_censored_data` which provides the length in minutes of the original versus processed data.

6. **Network Correlation Analysis**: This step involves calculating correlation matrices for identified resting-state networks, utilizing labels described above.  Both inter and intra-network correlation values are computed for each of the sub-networks provided by the homotopic parcellation.  

7. **Functional activity**: is computed with three models: mfALFF, mALFF and mPerAf as described in [@FIXME].  These are versions of fALFF, ALFF and PerAf where each is divided by the global mean in the brain.  Summary values are averaged within each of 500 labels in the homotopic label set which facilitates left/right asymmetry and mean values which are critical to studying diseases with laterality effects.

Due to the relatively diverse needs of researchers and the variety of rsfMRI that is generally present in public data, we run the above processing with three different sets of parameters (sets [122, 134 and 129](https://github.com/ANTsX/ANTsPyMM/blob/4d10c3a7c4a962c00a3c198ba0e00f35da25776d/antspymm/mm.py#L6496-L6506)) for censoring based on motion and intensity outlierness.  These three parameter choices led to rsfMRI IDPs that were the top performers in terms of reliability and predictive power out of 78 that we tested empirically.  See [this repository](https://github.com/stnava/antspymm_reproducibility) and the technical validation section for further details. Outputs from the rsfMRI processing are denoted by prefixes `rsfMRI_fcnxpro122` for 122 and similarly for 129 and 134.

# Data Records

Describe how we meet FAIR principles

The neuroimaging and associated standard PPMI demographics and clinical data is hosted in the [LONI Imaging Data Archive (LONI IDA)](http://ida.loni.usc.edu). The former is stored in DICOM format and the latter in tabular .csv format.  Additionally, data dictionaries describing all non-imaging column headers are available on the LONI IDA.

We attach the neuroimaging data to the PPMI Curated Data Cut Curated (v.2023-06-12 `PPMI_Curated_Data_Cut_Public_20230612_rev`) available on the LONI IDA.  Code for this merging process is available via the [subtyper package](https://stnava.github.io/subtyper/) specifically the function [merge_ppmi_imaging_clinical_demographic_data](https://stnava.github.io/subtyper/reference/merge_ppmi_imaging_clinical_demographic_data.html).  The M3RI IDPs are described in detail [here](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) and are available in a data table within the `ANTsPyMM` repository (csv format).  The full tabular IDPs for both OR and SR outputs are available at [this location](FIXME).  We also provide a "trim" version [here](FIXME) that is intended to allow users to "get started" with these data without being overwhelmed by the sheer number of variables.  We base demonstrations below on the trim version of these PPMI IDPs.

# Technical Validation

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges FIXME. We further this by demonstrating ANTsX reproducibility and reliability through analysis of three traveling subject cohorts and a young control cohort. By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) across different scanner types and imaging modalities. The young control cohort, using the pediatric template of brain perfusion (PTBP) data, validates the utility of combining multi-modality tabular data processed by ANTsX to enhance predictions of population characteristics. In essence, our additional analyses furnish numerical benchmarks for reliability and predictive accuracy and may be extended to other contexts.

## Multi-site reproducibility

Traveling subject studies involve scanning the same subjects on multiple MRI scanners at different locations. These studies help in assessing consistency and/or agreement of image quantification where the only variables are the machines themselves. This is crucial for understanding power in multi-site studies of natural history or intervention and for ensuring that the observed changes in brain structure or function are due to actual physiological changes rather than variations in the imaging process itself. 

In this study, we employ traveling cohort data to assess the agreement of imaging derived phentoypes (IDPs) pooled across multiple sites for the purposes of statistical inference. These data will establish expectations of repeatability for T1w, DTI and rsfMRI as measured by ANTsPyMM processing.  Thus, we use these data to characterize the consistency and reliability of these tools when applied to data that has known systematic biases due to site and scanner differences.  The results confirm that findings and conclusions drawn from ANTsPyMM are reliable and not overwhelmed by scanner-specific differences or inconsistencies.  This knowledge is critical for a foundational framework such as ANTsX upon which scientific studies, machine learning platforms and other methodological comparisons are based. These cohorts represent variability in both MRI manufacturer and MRI model (high variability) that would exceed standard (within-scanner, within-site) test-retest analysis.  Results therefore provide a lower-bound on reliability; i.e. within-site (e.g. longitudinal) studies would be expected to have higher reliability in general.

![Summary reproducibility results from aggregated traveling subject data. T1 IDPs represent high reproducibility in all categories (cerebellum, CIT168, cortical volume, cortical thickness, basal forebrain and medial temporal lobe).  DTI IDPs are also highly reproducible with FA in the cortical gray matter (gm) nearly equaling that of major white matter regions in the JHU atlas. Resting state connectivity shows good to excellent reproducibility; PerAF, fALFF and ALFF are relatively less reproducible -- on average -- though variability is also high.](../figs/antspymm_repro.png)


We find that ANTsPyMM IDPs derived from the same subjects imaged at different sites with MRI from various manufacturers show overall good to high reliability with a few exceptions within resting state correlations.  This provides empirical evidence that multiple modality MRI may be used to derive quantitative phenotypes on which predictive models may be based.  Statistical control for site effects should still be applied at the population level.

## Multi-view prediction 

We classify PD and control cases based on the available data using a standard machine learning (ML) paradigm available in the `mlr3verse` [@FIXME].  MLR3 allows systematic comparison of cross-validated performance between different ML models as well as feature sets.  As such, we compare performance between (a) T1w only versus (b) T1w plus DTI features as a function of either OR or SR calculations.  These results demonstrate that both joint modeling (DTI and T1 together) and SR improve classification accuracy over T1 alone or OR features.  Figure FIXME demonstrates a comparison of T1 only performance versus T1 plus DTI performance in terms of both raw and balanced accuracy using SR features.  Only better performing models are shown including: glmnet [@FIXME], imbalanced random forests [@FIXME], naive bayes classifier [@FIXME] and classic random forests [@FIXME].  The "featureless" model is the baseline classifier (no imaging features are used).

```{r classified,echo=FALSE,eval=FALSE,fig.width=6,fig.height=9,message=FALSE,warning=FALSE,cache=FALSE}
############################
ppmi = antspymm_predictors(ppmi, TRUE )
ppmi$age_BL = antsrimpute( ppmi$age_BL )
ysel = ppmi$yearsbl >= 0 & !is.na( ppmi$T1Hier_thk_r_i_iicerebellum) & !is.na(ppmi$T1Hier_volLRAVGi_iicerebellum) & subtyper::fs( ppmi$T1Hier_resnetGrade > 1.01 )
ysel = ppmi$yearsbl == 0 & !is.na( ppmi$T1Hier_thk_r_i_iicerebellum) & !is.na(ppmi$T1Hier_volLRAVGi_iicerebellum) & subtyper::fs( ppmi$T1Hier_resnetGrade > 1.01 )
dtvec = ppmi$DTI_mean_fa.body_of_corpus_callosum.jhu_icbm_labels_1mm
seldti = subtyper::fs( dtvec >= quantile(dtvec,0.005, na.rm=TRUE) )
selfl = !is.na( ppmi$T2Flair_flair_wmh_prior )
selfmri=!is.na(  ppmi$rsfMRI_fcnxpro122_VisPeri_2_SalVentAttnA) & 
  !is.na(ppmi$rsfMRI_fcnxpro122_ContA_2_ContA) & 
  subtyper::fs(ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5)
ppmi$DXbasic = NA
ppmi$DXbasic[ grep("CN",ppmi$joinedDX)]='CN'
ppmi$DXbasic[ grep("Prodromal",ppmi$joinedDX)]='AR'
ppmi$DXbasic[ grep("PD",ppmi$joinedDX)]='PD'
ppmi$DXbasic[ grep("AD",ppmi$joinedDX)]='AD'
ppmi$DXbasic[ grep("MCI",ppmi$joinedDX)]='MCI'
cohortCCbl = ppmi[ ysel, ]
# now match ADNI + ppmi 
selcn = subtyper::fs( cohortCCbl$joinedDX=='CN' )
tarsam = sum( subtyper::fs(cohortCCbl$studyName=='PPMI' & selcn ))
mm = match_cohort_pair( 
  cohortCCbl[ cohortCCbl$studyName=='ADNI' & selcn,],
  cohortCCbl[ cohortCCbl$studyName=='PPMI'& selcn,], 
  c('age_BL'), option='rand', restrict_df1=0.05, 
  num_iterations=1000,
  sample_size=tarsam,verbose=T)
matcheddemog  = cohortCCbl$studyName=='PPMI' | rownames(cohortCCbl)  %in% mm
cohortCCbl=cohortCCbl[ matcheddemog, ]
t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI','age_BL'],
  cohortCCbl[ cohortCCbl$studyName=='ADNI','age_BL'] )
t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI' & cohortCCbl$joinedDX=='CN','age_BL'],
  cohortCCbl[ cohortCCbl$studyName=='ADNI'& cohortCCbl$joinedDX=='CN','age_BL'] )
# t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI'&selcn,'age_BL'],
#  cohortCCbl[ mm,'age_BL'] )

dxv='joinedDX'
dxs = c("CN","PDSporadic")
dxv='AsynStatus'
dxs = c("Negative","Positive")
dxv='DXbasic'
dxs = c("CN","PD")
dxv='DXSubAsyn'
dxs = c("PDSporadicNegative","PDSporadicPositive")
dxs = c("ProdromalSporadicNegative","ProdromalSporadicPositive")
dxs = c("CNNegative","PDSporadicPositive")
############################
cohortCCbl = cohortCCbl[ cohortCCbl[,dxv] %in% dxs , ]
cohortCCbl$DXbio = 0
cohortCCbl$DXbio[  cohortCCbl[,dxv] == dxs[2] ] = 1
cohortCCbldt = cohortCCbldt[ cohortCCbldt[,dxv] %in% dxs , ]
cohortCCbldt$DXbio = 0
cohortCCbldt$DXbio[  cohortCCbldt[,dxv] == dxs[2] ] = 1
cohortCCblrsf = cohortCCblrsf[ cohortCCblrsf[,dxv] %in% dxs , ]
cohortCCblrsf$DXbio = 0
cohortCCblrsf$DXbio[  cohortCCblrsf[,dxv] == dxs[2] ] = 1
idps = antspymm_predictors(cohortCCbl, TRUE, TRUE )
idps = idps[ -grep("rsfMRI_fcnxpro129",idps)]
idps = idps[ -grep("rsfMRI_fcnxpro134",idps)]
idps = idps[ -grep("unclass",idps)]
idps = idps[ -grep("T1Hier_RandBasis",idps)]
idps = idps[ -grep("die_hth",idps)]
# idps = idps[ multigrep( c("Asym","LRAVG"), idps ) ]
idpst1 = unique( c( 
  idps[ multigrep( c("T1Hier","LRAVG","cerebellum","thk"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","dktcortex","thk"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","deep_cit168","vol"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","Asym","deep_cit168","vol"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","nbm","vol"),idps,intersect=TRUE)],
#  idps[ multigrep( c("T1Hier","Asym","nbm","vol"),idps,intersect=TRUE)],
  getNamesFromDataframe( c("vol","brainste"), ppmi, exclusions=c("lobe","issu","cleanup")) ) )
idpsdt = unique( c( 
    idps[ multigrep(c("DTI","mean_md","LRAVG"),idps,intersect=TRUE)],
    idps[ multigrep(c("DTI","mean_fa","LRAVG"),idps,intersect=TRUE)] ) )
xcl = antspymm_nuisance_names()
idpsrsfmri = c(
  getNamesFromDataframe( c("rsfMRI_fcnxpro122","_2_"), ppmi, exclusions=xcl ),
  getNamesFromDataframe( c("rsfMRI_fcnxpro122","_falff"), ppmi, exclusions=xcl ) )
print(table( cohortCCbl[,dxv]))
idpnas = rep(0,length(idps))
for ( k in 1:length( idps ) ) idpnas[k]=sum(is.na(cohortCCbl[,idps[k]]))
idpvars = apply( cohortCCbl[,idps], MARGIN=2, FUN=var )
names(idpvars)=idps
cohortCCbl$imaging_protocol = as.numeric( cohortCCbl$imaging_protocol )
if ( ! exists("nrep") ) nrep = 50
# idpst1 = dcurvarsel( cohortCCbl, idpst1, 0.5 )
# idpsdt = dcurvarsel( cohortCCbldt, idpsdt, 0.5 )
# idpsrsfmri = dcurvarsel( cohortCCblrsf, idpsrsfmri, 0.5 )
#########################
mycx = mlr3classifiers()
# mycx = mycx[ !( mycx %in% c("classif.gbm", "classif.ksvm", "classif.fnn",  "classif.kknn", "classif.rpart", "classif.xgboost", "classif.ranger") ) ]
mycx = mycx[ !( mycx %in% c("classif.gbm",  "classif.fnn", "classif.rpart", "classif.ranger") ) ]
mycx = c( mycx, "classif.featureless" )
mybal = 'over'
srate = 0.95
dxtbl=table( cohortCCbl[,'DXbio'] )
mysamp = floor(  max(dxtbl)/min(dxtbl)) 
cohortCCbl$sex=0
cohortCCbl$sex[cohortCCbl$commonSex=='Male']=1
if ( FALSE ) {
#  for ( z in c(idpst1,idpsdt,idpsrsfmri) ) {
  for ( z in c(idpst1) ) {
    loform = paste0( z , "~studyName" )
    cohortCCbl = adjustByCovariates(cohortCCbl,loform )
      # groupVariable='DXbasic',group='CN')
  }
  idpst1 = paste0(idpst1,"_adjusted")
#  idpsdt = paste0(idpsdt,"_adjusted")
#  idpsrsfmri = paste0(idpsrsfmri,"_adjusted")
}
#######
cohortCCbl[,idpst1] = antsrimpute( cohortCCbl[,idpst1])
cohortCCbl$study = 0
cohortCCbl$study[ cohortCCbl$studyName == 'ADNI']=1
mycvbs0 = mlr3classifiercv(
       cohortCCbl[ cohortCCbl$DXbio == 0, ],
       tcols = c("study", 'sex','age_BL', idpst1 ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbl$subjectID[ cohortCCbl$DXbio == 0],
       verbose = FALSE
     )
aggbs0 = aggregate( bacc ~ mdl, mycvbs0, mean )
aggbs0
mycvbs = mlr3classifiercv(
       cohortCCbl,
       tcols = c("DXbio", 'sex','age_BL' ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbl$subjectID,
       verbose = FALSE
     )
aggbs = aggregate( bacc ~ mdl, mycvbs, mean )
cohortCCbl=cohortCCbl[cohortCCbl$studyName=='PPMI', ]
mycvt1 = mlr3classifiercv(
       cohortCCbl,
       tcols = c("DXbio", 'sex', idpst1 ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
#       subjectIDs = cohortCCbl$subjectID,
       verbose = FALSE
     )
aggt1 = aggregate( bacc ~ mdl, mycvt1, mean )
aggt1
myadj = c(idpst1 , idpsdt )
cohortCCbldt[,myadj] = antsrimpute( cohortCCbldt[,myadj])
mycvdt = mlr3classifiercv(
       cohortCCbldt,
       tcols = c("DXbio", 'sex','age_BL', myadj ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbldt$subjectID,
       verbose = FALSE
     )
aggdt = aggregate( bacc ~ mdl, mycvdt, mean )
myadj = c(idpst1,idpsdt,idpsrsfmri)
cohortCCblrsf[,myadj] = antsrimpute( cohortCCblrsf[,myadj])
mycvrs = mlr3classifiercv(
       cohortCCblrsf,
       tcols = c("DXbio",'sex','age_BL', myadj  ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCblrsf$subjectID,
       verbose = FALSE
     )
aggrs = aggregate( bacc ~ mdl, mycvrs, mean )
print( aggbs )
print( aggt1 )
print( aggdt )
print( aggrs )
#########################
dxs=gsub("Prodromal","AR",dxs)
dxs=gsub("Positive","+",dxs)
dxs=gsub("Negative","-",dxs)
g1t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 alone:", dxs[1], "vs",  dxs[2])))
g2t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none') + ggtitle(paste("Raw Acc. T1 alone:", dxs[1], "vs",  dxs[2])))
# g1=( ggstatsplot::ggbetweenstats( mycv, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
# g2=( ggstatsplot::ggbetweenstats( mycv, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))

bbase=( ggstatsplot::ggbetweenstats( mycvbs, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. Age + Sex:", dxs[1], "vs",  dxs[2])))
t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 :", dxs[1], "vs",  dxs[2])))
t1b=( ggstatsplot::ggbetweenstats( mycvt1, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 :", dxs[1], "vs",  dxs[2])))
dt=( ggstatsplot::ggbetweenstats( mycvdt, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
dtb=( ggstatsplot::ggbetweenstats( mycvdt, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
rs=( ggstatsplot::ggbetweenstats( mycvrs, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI + rsf:", dxs[1], "vs",  dxs[2])))
rsb=( ggstatsplot::ggbetweenstats( mycvrs, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI + rsf:", dxs[1], "vs",  dxs[2])))

# mygg = grid.arrange( grobs=list(g1t1,g1,g2t1,g2), nrow=4, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
mygg1 = grid.arrange( grobs=list(t1,dt,rs), nrow=3, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
mygg2 = grid.arrange( grobs=list(t1b,dtb,rsb), nrow=3, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
print( mygg1 )
print( mygg2 )

```


```{r interpretit,echo=FALSE,eval=FALSE,fig.width=9,fig.height=5}
library(ggpubr)
library(randomForestSRC)
datcol=c(idpst1, idpsdt, idpsrsfmri)
datcol=c(idpst1 )
datcols=shorten_pymm_names(datcol )
myx=cohortCCbl
colnames(myx)[  colnames(myx) %in% datcol ] = datcols
myx=myx[,c("study",'age_BL','commonSex', 'imaging_protocol', datcols )]
myx$commonSex=factor(myx$commonSex)

rfobj <- rfsrc(study ~ ., data = myx,forest=TRUE)
myvimp = vimp(rfobj)
newimp = data.frame( feature=names(myvimp$importance), importance=as.numeric(myvimp$importance ))
newimp = newimp[ order(newimp$importance,decreasing=T),]
newimp$type=substr(newimp$feature,0,3)
newimp$type=gsub("_","",newimp$type)
print( ggbarplot( head(newimp,20), 'feature','importance', fill='type', palette='npg' ) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Feature importance ",paste(dxs,collapse=' vs '))) ) 

if ( FALSE  ) {
  tsk = as_task_classif( x = cohortCCbl[ , c("DXbio", datcols )], target='DXbio',  id='pd' )
  lrn_gbm = lrn("classif.imbalanced_rfsrc", predict_type = "prob")
  split = partition(tsk)
  lrn_gbm$train( tsk, row_ids = split$train )
  predictor = Predictor$new(lrn_gbm, data = cohortCCbl[,datcols], y = cohortCCbl[,'DXbio'])
  importance = FeatureImp$new(predictor, loss = "ce", n.repetitions = 10 )
  importance$resultsfull = importance$results
  importance$results = importance$results[1:25,] 
  importance$plot()
  # newimp = data.frame( importance$results[1:25,]  )
  # print( ggbarplot( newimp, 'feature','importance',  palette='npg', ylim=c(1,1.2) ) + 
  #  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Feature importance ",paste(dxs,collapse=' vs '))) + geom_errorbar(aes(ymin=importance.05, ymax=importance.95), width=.1,
  #                    position=position_dodge(.5))  ) 
}
```


```{r interpretit2,eval=FALSE,echo=FALSE,fig.width=10,fig.height=6,message=FALSE,warning=FALSE}
library(ggpubr)
library(randomForestSRC)
datcol=c(idpst1, idpsdt, idpsrsfmri)
datcol=c(idpst1 )
datcols=shorten_pymm_names(datcol )
datcols=gsub("_adjusted","",datcols)
datcols=gsub("_adjuste","",datcols)
datcols=gsub("_adjust","",datcols)
datcols=gsub("_adjus","",datcols)
datcols=gsub("_adju","",datcols)
datcols=gsub("_adj","",datcols)
datcols=gsub("_ad","",datcols)
outcome='DXbio'
outcome='study'
myx=cohortCCbl
myx$study=0
myx$study[myx$studyName=='ADNI']=1
colnames(myx)[  colnames(myx) %in% datcol ] = datcols
opreds = c('age_BL','commonSex', datcol )
myx=myx[,c(outcome,'age_BL','commonSex',  datcols )]
myx$commonSex=factor(myx$commonSex)
# rfobj <- rfsrc(DXbio ~ ., data = myxtr)
# rfobj <- rfsrc.fast(DXbio ~ ., data = myxtr)
mypartition = dataPartition( myx$age_BL, 0.8  )
myx[,outcome] = factor( myx[,outcome])
# myrf=rfsrc( DXbio ~ ., data=myx[mypartition$train,], importance=T, forest=TRUE  )
myrf=imbalanced( study ~ ., data=myx[mypartition$train,], importance=T)#, ntree = 5000  )
###### from getting started guide
# oo <- subsample(myrf, verbose = FALSE)
###### take a delete-d-jackknife procedure for example
# vimpCI <- extract.subsample(oo)$var.jk.sel.Z
###### Confidence Intervals for VIMP
# plot.subsample(oo)
# take the variable "Month" for example for partial plot
# plot.variable(myrf, xvar.names = "Month", partial = TRUE)
###########################################################
vv = myrf$importance[,1]
nms=names(vv)
myimp = data.frame( 
    nms=names(vv),
    imp=vv)
myimp$type = 'cit'
myimp$type[1:2]='demog'
myimp$type[ grep("deep",opreds)]='deep'
myimp$type[ grep("brainstem",opreds)]='brainstem'
myimp$type[ grep("bf",opreds)]='nbm'
myimp$type[ grep("cerebell",opreds)]='cerebellum'
myimp$type[ grep("cortex",opreds)]='cortex'
myimp$type[ grep("mtl",opreds)]='mtl'
rownames(myimp)=NULL
library(ggpubr)
myimp = myimp[ order( myimp$imp, decreasing=TRUE),]
ggbarplot(head(myimp,14), x = "nms", y = "imp",
          fill = "type",               # change fill color by cyl
          color = "white",            # Set bar border colors to white
          palette = "jco",            # jco journal color palett. see ?ggpar
          sort.val = "desc",          # Sort the value in dscending order
          sort.by.groups = FALSE,     # Don't sort inside each group
          x.text.angle = 90           # Rotate vertically x axis texts
          )
get.imbalanced.performance( myrf, confusion=T )
##################################
qq = predict( myrf, newdata=myx[mypartition$test,], type='probabilities' )
##################################
```

```{r interpretit2auc,eval=FALSE,echo=FALSE,fig.width=10,fig.height=6,message=FALSE,warning=FALSE,results='asis'}
## ggplot it
library(pROC)
# Create the ROC object
predictions = as.numeric(qq$class)
predictions = qq$predicted[,2]
roc_obj <- roc(myx[mypartition$test,'DXbio'], predictions )

# Plot the ROC curve with smoothing
plot(roc_obj, print.auc=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE, smooth=TRUE)
# plot(roc_obj, main="Smoothed ROC Curve", col="#1c61b6", print.auc=TRUE)
lines(smooth(roc_obj), col="#ff0000")  # Add smoothed ROC curve

if ( FALSE ) {
  library(evalmod)
  library(ggplot2)
  library(precrec)
  sscurves <- evalmod(scores = predictions, 
      labels = myx[mypartition$test,'DXbio'], x_bins=10000 )
  aucs <- auc(sscurves)
  autoplot( sscurves, show_cb = F )
  # Use knitr::kable to display the result in a table format
  knitr::kable(aucs,"latex", booktabs = TRUE) %>%
    kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
}
```

## PPMI case studies

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  Magnetic resonance imaging (MRI) is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. 

Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), dMRI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

The tabulated multi-modality MRI dataset derived from deeply validated open source methods represents a significant leap forward in PD M3MRI research. It simplifies the analysis of complex imaging data, potentially accelerating the discovery of novel insights into PD's progression and effects. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.

basal forebrain [in LRRK2](https://www.sciencedirect.com/science/article/pii/S0969996123001973)


```{r pkgs,echo=FALSE,eval=TRUE,message=FALSE,cache=TRUE}
set.seed( 0 )
library(plyr)
library(ggplot2)
library( GoodmanKruskal )
library(forcats)
library(heatmap3)
library(permute)
library(interactions)
library(reghelper)
library(MGMM) # GMM methods (FIXME)
library(WeightedCluster) # cluster quality (FIXME)
library(tidyverse)
library(clValid)
library( cluster.datasets )
library(magrittr)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ggfortify)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="latex" )
tblcmd = ztable
```

```{r functions,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,cache=FALSE}

normalizersfmri = function( dd, applyit='mean' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,cache=FALSE}
if ( ! exists( "is_test" ) ) is_test = TRUE
```

## Diagnostic effects in pre-defined structural, white matter and resting functional measurements

```{r quicklmdxsetup,echo=FALSE,eval=buildsci,fig.width=9,fig.height=6,warning=FALSE,message=FALSE}
######################################################################
num=c(122,129,134)[1] # resting state protocol numbers ###############
######################################################################
dxform="~  (1|PATNO)+ (1|SITE) + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|subjectID) + (1|imaging_protocol) + age_BL + commonSex "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_mean + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
dxsel2 = ppmi$DXSubAsyn %in% c(
  negate, posate, ispd )
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
# mylevsx1=c( "CN", "ProdromalSporadic", "PDSporadic", "MCI", "AD" )
# keep the "best" ntokeep examples
# mydog = ppmi[ head( order(ppmi$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
mydog = ppmi[ ppmi$T1Hier_resnetGrade > 1.02 ,  ]
ysel = mydog$yearsbl <= 4.5 
mydog = mydog[ mydog$studyName %in% c('PPMI','ADNI') & ysel &
#  ppmi$DXSubAsyn %in%  mylevsx0[c(1,2,3)]&  
#  ppmi$joinedDX %in%  mylevsx1[c(1,2,3)] &  
#  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2" ) ) &
  subtyper::fs( mydog$joinedDX %in% c( "CN", "MCI", "PDGBA","PDLRRK2","PDSporadic" ) ),]
mydog = normalizersfmri( mydog )
mydog$joinedDX <- fct_relevel(mydog$joinedDX, "CN")
mydog$DXSubAsyn <- fct_relevel(mydog$DXSubAsyn, "CNNegative")
###############################################
mydog$TDX = NA #as.character( mydog$DXSubAsyn )
dolrrk2=FALSE
if ( dolrrk2 ) {
  mydog$TDX = mydog$DXSubAsyn
  mydog$TDX[ mydog$LRRK2_study == FALSE ] = NA
  mydx='PDLRRK2'
} else {
  mydog$TDX[ subtyper::fs(mydog$AsynStatus == 'Negative' & mydog$joinedDX == 'CN') ]='CN'
# mydog$TDX[ mydog$DXSubAsyn %in% ispd ]='otherPositive'
  mydog$TDX[ mydog$DXSubAsyn  == 'PDLRRK2Positive' ]='PDLRRK2+'
  mydog$TDX[ mydog$DXSubAsyn  == 'PDGBAPositive' ]='PDGBA+'
  mydx='PDLRRK2+'
  mydx='PDGBA+'
 # mydog$TDX[ mydog$DXSubAsyn  == 'PDSporadicNegative' ]='DXPD-'
  mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDSporadicPositive') ]='PDSp+'
  mydx='PDSp+'
}
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_n_outliers < 100 ) &
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5 )
mydog = antspymm_predictors(mydog, TRUE )
idps = antspymm_predictors(mydog, TRUE, TRUE )
subjectcount = table( mydog$commonID )
# mysubs = names(  subjectcount > 1 )
# mydog = mydog[ mydog$commonID %in% mysubs , ]
xcl = antspymm_nuisance_names()
rsfnames = c( 
  getNamesFromDataframe( c("rsf","LRAVG",num,'_falff'), mydog, exclusions=xcl ),
  getNamesFromDataframe( c("rsf","Asym",num,'_falff'), mydog, exclusions=xcl ) )
rsfnamescnx = c( 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","efaul"),  ppmi, exclusions=xcl ), 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","imbi"),  ppmi, exclusions=xcl ),   
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","efaul","imbi"),  ppmi, exclusions=xcl )
  )
rsfnamescnx = getNamesFromDataframe( c("pro122", "_2_" , "SomMot" ), ppmi, exclusions=c(xcl,'efaul','Dors','SalVe','imbi')  )
rsfnamescnx = rsfnamescnx[ grep("rsfMRI_fcnxpro122_SomMot", rsfnamescnx) ]
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','Limbic'),  ppmi, exclusions=xcl ),
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','SalVent'),  ppmi, exclusions=xcl ) )
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
# idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'joinedDX'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
mydog = mydog[ !is.na( mydog[,dxvar]), ]
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), mydog ),
  getNamesFromDataframe( c("DTI","Asym"), mydog ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),mydog, exclusions=c("left","right")), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),mydog, exclusions=c("left","right")) )
######################################
# print( table( mydog[,dxvar]))
mydog = fillBaselineColumn( mydog,
        c( idpst1, rsfnamescnx, rsfnames, dtinamesasymlr, 'hy', 'brainVolume' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX == 'CN' ]=0
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX != 'CN' ]=2
mydog$hy_BL = factor( mydog$hy_BL )
######################################
motname = paste( 
      paste0( "rsfMRI_fcnxpro",num,"_n_outliers"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_mean") )
motnamedt = "DTI_dti_FD_mean"
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
#  nmstotest = idpst1[ multigrep( c("dktcortex","thk"),idpst1,intersect=T)]
#  nmstotest = sample( nmstotest, 4 )
  mycorr='none'
}
# decide on some really good regions to test/show
ctx = c( "T1Hier_vol_Asym_superior_parietaldktcortex", "T1Hier_vol_Asym_inferior_parietaldktcortex", 
getNamesFromDataframe( c("vol","Asym", "dktcortex","entral"),mydog)
 ) # need ref
snc = c( "T1Hier_vol_mtg_sn_snc_Asymdeep_cit168",   
  "T1Hier_vol_bn_str_pu_Asymdeep_cit168", 
  "T1Hier_vol_bn_gp_gpi_Asymdeep_cit168", 
  "T1Hier_vol_bn_gp_gpe_Asymdeep_cit168", 
  getNamesFromDataframe( c("vol","Asym", "nbm"),mydog) )
#  getNamesFromDataframe( c("mtl", "LR"),mydog) )
dtivars = c( "superior_longitudinal_fasciculus", "_snc", 
  "superior_corona_radiata", "fornix", "_capsule", 
  # "parahippocampal", 
  "str_pu")
nmstotest = c( ctx, snc )
nmstotest = unique( c( 
  nmstotest, 
  gsub("Asym","LRAVG",nmstotest), 
  dtinamesasymlr[ multigrep( dtivars, dtinamesasymlr )],
  rsfnamescnx ) )
```

### Table of pre-defined regions tested

```{r predefregions,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
idpids = nmstotest[ multigrep( c("LRAVG","rsfM"),nmstotest)]
myregions = data.frame( IDP=shorten_pymm_names(idpids))
myregions$modality[ grep("rsf", myregions$IDP)]='rsfMRI'
myregions$modality[ grep("dti", myregions$IDP)]='DTI'
myregions$modality[ grep("t1", myregions$IDP)]='T1w'
myregions2=myregions
myregions2$IDP=gsub('_','.',myregions$IDP)
myregions2T1 = myregions2[ myregions2$modality == 'T1w', ]
myregions2DTI = myregions2[ myregions2$modality == 'DTI', ]
myregions2RSF = myregions2[ myregions2$modality == 'rsfMRI', ]
myregionszT1z=ztable(myregions2T1)
myregionszRSFz=ztable(myregions2RSF)
myregionszDTIz=ztable(myregions2DTI)
mycap='Pre-defined PD regions in ANTsPyMM: T1w (L/R average and asym)'
print(myregionszT1z, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
mycap='Pre-defined PD regions in ANTsPyMM: DTI (L/R average and asym)'
print(myregionszDTIz, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
mycap='Pre-defined PD regions in ANTsPyMM: rsfMRI (bilateral connectivity)'
print(myregionszRSFz, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
# myregions %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```

```{r quicklmdx,echo=FALSE,eval=buildsci,fig.width=9,fig.height=4.5,warning=FALSE,message=FALSE}
dxdfT1=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdfT1)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( vois[2], " ~ hy_BL + ", vois[1], "+", dxform )
  bform = paste( vois[2], " ~ 1 + ", vois[1], "+", dxform )
  bform = paste( voi, " ~ T1Hier_resnetGrade + LRRK2_MRIPROTOCOL + ", dxform )
  bform = paste( voi, " ~ (LRRK2_MRIPROTOCOL) + ", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean + DTI_dti_tsnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+ spc0 +spc1+", dxform )
  bform = paste( voi, " ~ 1 + T1Hier_resnetGrade+spc0+spc2+", dxform )
  bform = paste( vois[2], " ~ " , vois[1], "+brainVolume_BL + T1Hier_resnetGrade+", dxform )
  othdxform=dxform
  if ( antspymm_vartype(voi) == "rsfMRI" ) othdxform=paste0(motname,"+",dxform)
  if ( antspymm_vartype(voi) == "DTI" ) othdxform=paste0(motnamedt,"+",dxform)
  bform = paste( voi, " ~ brainVolume_BL + T1Hier_resnetGrade+", othdxform )
  newform = paste( bform, " * ", dxvar  )
  temp2 = mydog[ !is.na( mydog[,voi]) & mydog$age_BL < 70005 & 
    mydog$studyName %in% c('PPMI'), ]
  # for ( x in  all.vars( as.formula(newform)) ) { print(x) ; print(table( is.na( temp2[,x]))) }
  temp2 = scale_variables_in_equation( temp2, newform )
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scale_variables_in_equation( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdfT1[n,'voi']=voi
  dxdfT1[n,'anv']=anvp
  othercols = rownames(mycoffs)
  othercols=c( "yearsbl" , othercols[grep("TDX",othercols)] )
  othercolsnm=gsub("TDX","",othercols)
  othercolsnm=gsub(":",".",othercolsnm)
  chnd = effectsize::t_to_d( mycoffs[ othercols, 't value'], mycoffs[ othercols, 'df']  )
  dxdfT1[n,paste0("d.",othercolsnm)]=chnd[,1]
#  dxdfT1[,paste0("p.",othercolsnm)]=mycoffs[ othercols, 5]
  dxdfT1[n,'res']=myrez
  dxdfT1[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( gsub("_",".",shorten_pymm_names(voi)) %in% c("t1.vol.mtg.sn.sncdeep.cit168","dti.mean.md.sup.longitudinal.fasciculus.","dti.fa.sup.corona.radiata.asym","t1.vol.nbm.antbf","rsf.defaulta.2.visperi") ) {
    # print( mycoffs )
    # print( dxdfT1[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( shorten_pymm_names(voi), "PD+ : ", anvp ) )
    print( interactions::interact_plot( mdl, 'yearsbl',  'TDX', main.title=ttl, interval=TRUE, plot.points =FALSE, facet.modx=TRUE, int.type = c("confidence", "prediction")[1], partial.residuals=F,y.label ='') )
#    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
##########################################################
```

### Table of significant diagnostic group effects

```{r dxresults,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
if ( sum( psel ) == 0  ) psel = rep(TRUE,nrow(dxdfT1))
dxdfT1sel = dxdfT1[psel,]
dxdfT1sel$voi = shorten_pymm_names( dxdfT1sel$voi )
dxdfT1sel = dxdfT1sel[ order( dxdfT1sel$anv ), ]
dxdfT1sel$anv = insight::format_p(  dxdfT1sel$anv, digits=4  )
dxdfT1selcols = colnames(dxdfT1sel)[1:9]

# Print the ztable object, ensuring it's treated as LaTeX code
dxdfT1selz=dxdfT1sel[, dxdfT1selcols]
colnames(dxdfT1selz)=gsub("yearsbl","y",colnames(dxdfT1selz))
colnames(dxdfT1selz)=gsub("PD","",colnames(dxdfT1selz))
dxdfT1selz$voi=gsub("_",".",dxdfT1selz$voi,fixed=TRUE)
dxdfT1selz=ztable(dxdfT1selz)
mycap='Significant (fwe) longitudinal diagnostic group effects: T1w, DTI and rsfMRI.'
print(dxdfT1selz, type = "latex",size=2,caption=mycap,sidewaystable=TRUE)

# dxdfT1sel[, dxdfT1selcols] %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```



## Baseline IDP to longitudinal UPDRS effects in pre-defined structural, white matter and resting functional measurements


```{r quicklmcog,echo=FALSE,eval=buildsci,fig.width=12,fig.height=8,warning=FALSE,message=FALSE}
#########################################################
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
cogs = getNamesFromDataframe( c("updrs","score"), mydog, exclusions=c(4,'_BL',"_delta","tot") )
# cogs = getNamesFromDataframe( c("updrs","score","tot"), mydog, exclusions=c(4,'_BL',"_delta") )[1]
col2sbl = unique(c( idpst1, dtinamesasymlr, rsfnames, rsfnamescnx,  fdnames, cogs, nmstotest ))
mydogp = fillBaselineColumn( mydog,
        col2sbl,
        'subjectID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydogp$hy_BL = factor( mydogp$hy_BL )
stadfrsf=data.frame()
for ( cog in  cogs  ) {
  for ( voi in nmstotest ) {
    n = nrow(stadfrsf)+1
    voi = paste0(voi,"_BL")
    maxy=5.0
    if ( antspymm_vartype( voi ) == "T1" ) motname=""
    if ( antspymm_vartype( voi ) == "rsfMRI" )  {
      motname = paste( paste0( "rsfMRI_fcnxpro",num,"_n_outliers_BL"), " + ",
        paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL"))
      motname = paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL")
      maxy=2.5
      }
    if ( antspymm_vartype( voi ) == "DTI" )  {
      motname = "DTI_dti_FD_mean_BL"
      maxy=3.0
    }
    cogformcommon=paste( cog, "  ~ (1|PATNO) + ",motname," + AsynStatus + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + brainVolume_BL + ", motname, " + age_BL + commonSex + AsynStatus + yearsbl" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|imaging_protocol)+ (1|PATNO) + T1Hier_resnetGrade  + duration_yrs + ",motname," + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )*TDX + ( yearsbl )" )
#    cogformcommon=paste( cog  , "~  (1|PATNO) + commonSex + brainVolume_BL + ( yearsbl )")
    temp2 = mydogp[ !is.na( mydogp[,voi]) & mydogp$TDX != "CN" & mydogp$yearsbl <= maxy, ]
#    temp2 = mydogp[ !is.na( mydogp[,voi]) & mydogp$TDX == "PDSp+" & mydogp$yearsbl <= maxy, ]
    temp2[,voi]=psych::winsor( temp2[,voi], 0.005)
    temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
    voix = shorten_pymm_names( voi )
    voix = gsub("_fcnxpro129", "",voix)
    temp2[,voix]=temp2[,voi]
    newform = paste(  cogformcommon, " * TDX * ", voix )
    newform = paste(  cogformcommon, " * ", voix )
    if ( nrow(temp2) > 100 ) {    
    temp2 = scale_variables_in_equation( temp2, newform )
    bmdl=suppressMessages(lmer( cogformcommon, data=temp2 ))
    mdl=suppressMessages(lmer( newform, data=temp2 ))
    mycoffs = coefficients( summary( mdl ) )
    anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
    stadfrsf[n,'cog']=cog
    stadfrsf[n,'voi']=voix
    stadfrsf[n,'anv']=anvp
    stadfrsf[n,'res']=myrez
    stadfrsf[n,'singular']=isSingular(mdl)
    if (  anvp < 3e-4 ) {
      cogdel = paste0(cog,"_delta")
  #    print( mycoffs[ , -c(1:3)] )
  #    print( voi )
      anvp = insight::format_p( anvp, digits=4 )
      anvp1 = insight::format_p( mycoffs[voix,'Pr(>|t|)'], digits=4 )
      anvp2 = insight::format_p( mycoffs[paste0("yearsbl:",voix),'Pr(>|t|)'], digits=4 )
      ttl=( paste(  voix, myrez, " + ", cog,  " : o", anvp ) )
      ttl1=( paste(  voix, myrez, " + ", cog,  " : m ", anvp1 ) )
      ttl2=( paste(  voix, myrez, " + ", cog,  " : y ", anvp2 ) )
      ttl3=c(voix,'higher strat.','lower strat.')
      temp2$TDX=as.character( temp2$TDX )
      temp2$TDX[ temp2$TDX == 'PDGBA+']='GB+'
      temp2$TDX[ temp2$TDX == 'PDLRRK2+']='LR+'
      temp2$TDX[ temp2$TDX == 'PDSp+']='sp+'
      gg1=( jtools::effect_plot( mdl, 
        !!sym(voix), # mod2='TDX',  
        main.title=ttl1, interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F  ) + theme(legend.position = "top")  )
      gg2=( interactions::interact_plot( mdl, 
        'yearsbl', # mod2='TDX',  
        main.title=ttl2, interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F,modx=!!sym(voix)  ) + theme(legend.position = "top")  )
      grid.arrange( grobs=list(gg1,gg2), nrow=2, top=ttl)
#      suppressMessages( threewayinteraction(  temp2, 'yearsbl', cogdel, 'TDX', voix, anatshow=ttl3 ) )
#      print( threewayinteraction( temp2, 'yearsbl', 'TDX', anat=voi ) )
 #     mygg = visreg::visreg( mdl, 'yearsbl', by=voi, gg=T )
 #     threewayinteraction( temp2, 'yearsbl', cog,  'AsynStatus', voi, showpoints=F )
#      print(prplot( mdl,  voi, 'yearsbl',ttl, colorvar='commonSex', addpoints=1))
#      gg0=(prplot( mdl, 'yearsbl', voi, '', ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      gg1=(prplot( mdl, voi, 'yearsbl', '', ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      grid.arrange( grobs=list(gg0,gg1),nrow=2, top=ttl)
#      visreg::visreg( mdl, 'yearsbl', by=voi, main=ttl  )

#    print( interactions::interact_plot( mdl, 'yearsbl', voi, main.title=ttl, interval=TRUE, plot.points =FALSE, facet.modx=TRUE, int.type = c("confidence", "prediction")[1], partial.residuals=F,y.label ='') )

    }
  } }
}
#####################
sigth=0.05
# for ( cog in cogs ) 
{
  mypvs = stadfrsf$anv
#  mypvs[ stadfrsf$cog != cog  ] = NA
  psel = subtyper::fs( p.adjust( mypvs, 'BY' ) <= sigth )
  psel2 = subtyper::fs( p.adjust( mypvs, 'BH' ) <= sigth )
  stadfrsf[psel2,'sig']='fdr'
  stadfrsf[psel,'sig']='fwe'
  if ( sum(psel ) > 0 )
    temp=stadfrsf[psel|psel2,]
    qdfsig=temp
#    qdf = rbind( qdf, temp )
  }
qdfsig = qdfsig[ order( qdfsig$anv ), ]
qdfsig$voi = shorten_pymm_names( qdfsig$voi )
qdfsig$anv = insight::format_p(  qdfsig$anv, digits=4  )
qdfcols =  c("cog", "voi" , "anv" ,'sig')
qdfsig = qdfsig[,qdfcols]
qdfsig$voi=gsub("_",".",qdfsig$voi,fixed=TRUE)
qdfsig$cog=gsub("_",".",qdfsig$cog,fixed=TRUE)
qdfsig = qdfsig[!duplicated(qdfsig),]
###########################################################
###########################################################################
```


### Table of significant clinical-IDP group effects

```{r updrsresults,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}

# Print the ztable object, ensuring it's treated as LaTeX code
qdfsigz=ztable(qdfsig)
mycap='Significant (fwe,fdr) IDP-UPDRS longitudinal effects for PDSp+: T1w, DTI and rsfMRI'
print(qdfsigz, type = "latex",size=3,caption=mycap,sidewaystable=FALSE)

# knitr::kable(qdfsig, "latex", booktabs = TRUE, caption='Significant IDP-UPDRS longitudinal  effects: T1w, DTI and rsfMRI') %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```




# Usage Notes

An example of processing used here is shown in the github respository [https://github.com/stnava/ANTPD_antspymm](https://github.com/stnava/ANTPD_antspymm) where we combine easily accessible multi-view neuroimaging with our open source methods for demonstration purposes.  All images referred to in this research were processed in a style identical to this example.


# Code availability

ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM). The version used for this work is `1.2.7` along with tensorflow `2.11.0`, antspyx `0.4.2`, antspynet `0.2.3` and antspyt1w `0.9.1`.

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work.

# Author contributions statement

...

# Competing interests

...

# Figures & Tables

Figures, tables, and their legends, should be included in the appropriate section of the document. Figures and tables can be referenced using Markdown syntax.

Figure: Legend (350 words max). Example legend text.

| Condition | n  | p     |
|-----------|----|-------|
| A         | 5  | 0.1   |
| B         | 10 | 0.01  |
Table: Legend (350 words max). Example legend text.


