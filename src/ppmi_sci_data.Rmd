---
title: "Magnetic Resonance Imaging Data Phenotypes for the Parkinson's Progression Markers Initiative"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1
  - Leon Fonville^3,†^
  - Olivia Hampton^1,†^
  - Alex Reardon^1,†^
  - Nicholas J. Tustison^2
  - Philip A. Cook^4
  - Xue Wang^1,†^
  - Linda
  - Zahra
  - Adam
  - Barbara?
  - Roger Gunn?
  - Kathleen L Poston?
  - Ken?
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: University of Virginia, Department of Radiology and Medical Imaging, Charlottesville, VA, FIXME, USE"
  - "3: Invicro, FIMXE, UK"
  - "4: UPENN, FIMXE, Philly"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: 
  pdf_document:
    keep_tex: true
    template: null
#    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmiscidata.bib
classoption: table
header-includes:
  - \usepackage{multirow}
  - \usepackage{rotating}
linenumbers: true
urlcolor: blue
# nocite: '@*'
link-citations: true
---


```{r samplesizes,echo=FALSE,eval=TRUE}
redomerge=TRUE
if ( ! exists("buildsci"))buildsci=FALSE
```


```{r ppmimerge, echo=FALSE,eval=redomerge}
library(ztable)
library(moonBook)
library(plyr)
library(subtyper)
library(forcats)
library(lmerTest)
library(lme4)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(mclust)
library(MASS)
library(dCUR)
library(mlr3learners)
library(ANTsR)
library(mlr3verse)
if ( ! exists("clin2b") ) {
  rdir=path.expand('~/code/multidisorder/data/')
  rdir=path.expand('~/Downloads/ppmi_pym_data/')
  if ( ! exists("pymf") ) {
    pymfns = data.frame( 
      fns=c( 
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v1.2.7.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRNext_v1.2.7.csv')  ),
      rez=c("OR","SRF","SRP") )
    print(paste("ANTsPyMM Pipeline : ", myrez ) )
    pym = read.csv(  pymfns$fn[pymfns$rez == myrez ] )
    pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
    pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
    pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
    pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
    rm(pym)
    }
  adni = read.csv( path.expand("~/code/multidisorder/data/adni_gwas/ADNIMERGE_10Feb2024_antspymm_v1.2.7.csv") )
  studynames=c("ADNI", "NIFD4RTNI", "PPMI","UKBB","A4")
  dxnames= c("DX_bl", "DX", "DXSub", "DX", "DX" )
  sexnames=c("PTGENDER","SEX","SEX","sex_f31_0_0","PTGENDER")
  agenames=c("AGE","Age_BL","age_BL","subjectAge_BL","PTAGE")
  edunames=c("PTEDUCAT","EDUCATION","EDUCYRS","age_completed_full_time_education_f845_0_0","PTEDUCAT")
  sidnames=c("PTID","LONI_ID","PATNO","eid","sid")
  viznames=c("Years.bl","deltaTime","yearsbl","Years.bl","Years.bl")
  adni$commonSex = adni$PTGENDER
  adni$commonEdu = adni$PTEDUCAT
  adni$commonID = adni$subjectID = adni$PTID
  adni$age_BL = adni$age = adni$AGE
  adni$yearsbl = adni$Years_bl
  adni$joinedDX = adni$DX_bl
  adni$joinedDX[ grep("MCI",adni$joinedDX)]="MCI"
  adni$joinedDX[ adni$joinedDX == ""]=NA
  adni$studyName='ADNI'
  adniasynfn = path.expand( "~/code/multidisorder/data/adni_gwas/AMPRION_ASYN_SAA_13Nov2023.csv")
  adniasyn = read.csv( adniasynfn )
  names( adniasyn )[ names(adniasyn) == 'Result']='AsynStatus'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Detected-1','Detected-2')) , 'AsynStatus'] = 'Positive'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Not_Detected','Indeterminate')), 'AsynStatus' ] = 'Negative'
  # map 
  adni$AsynStatus=NA
  uids = unique( adniasyn$RID[!is.na(adniasyn$AsynStatus)])
  for ( k in 1:nrow(adniasyn) ) {
        losel = subtyper::fs( adni$RID == adniasyn$RID[k] )
        if ( sum(losel) > 0 ) {        
            adni$AsynStatus[ losel ] = adniasyn$AsynStatus[k]
        }
    }
  demog=read.csv(paste0(rdir,"Demographics_06Feb2024.csv"))
  curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20230612_rev.csv')
  saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv')
  if ( ! file.exists( saafn ) ) {
    saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023.csv')
    }
  saa=read.csv( saafn )
  ppmidemog0=read.csv( curfn )
  clin2b = merge_ppmi_imaging_clinical_demographic_data(
    demog, ppmidemog0, pymf, pymversion=myrez, saa )
  # add tracker
  tracker = read.csv(paste0(rdir,"ppmi_2_0_internal_scan_tracking_report_v12-2024-02-08.csv"))

  tracker = tracker[ tracker$Modality == "MR", ]
  tracker$EVENT_ID=tracker$Visit
  tracker$EVENT_ID[ grep("Baseline",tracker$EVENT_ID)]="BL"
  tracker$date=NA
  momap=data.frame( num=c( paste0("0",1:9), "10", "11", "12") )
  rownames(momap)=c("JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC")
  for ( k in 1:nrow(tracker) ) {
    fixedev=unlist(strsplit( tracker$Visit[k], "/"))
    if ( length( fixedev ) > 1 ) fixedev=fixedev[length( fixedev )]
    tracker$EVENT_ID[k]=fixedev
    fixeddt = unlist(strsplit( tracker$Scan.Date[k],"-"))
    fixeddt[2] = momap[ fixeddt[2], 'num' ]
    fixeddt = paste0( fixeddt[3] , fixeddt[2], fixeddt[1] )
    tracker$date[k]=fixeddt
    }
  trackersub = tracker[, c("Subject.ID","date" )]
  trackersub$imaging_protocol=2
  names(trackersub)=c("PATNO","date", "imaging_protocol" )
  clin2b=merge( clin2b, trackersub, by=c("PATNO","date"), all.x=TRUE )
  clin2b$imaging_protocol[ is.na(clin2b$imaging_protocol) ]=1
  # add LRRK2 
  lrrk2 = read.csv( paste0(rdir,'CSFSAA_LRRK2_MRI_SAMPLES_08Jan2024/Data-Table1.csv'))
  lrrk2$SAAGroup[ lrrk2$SAAGroup == " " ]=NA
  clin2b$LRRK2_study=NA
  uids = lrrk2$PATNO
  lrrk2cols = colnames(lrrk2)
  lrrk2cols=lrrk2cols[ !(lrrk2cols %in% "PATNO") ]
  newcols = paste0("LRRK2_", lrrk2cols )
  clin2b[,newcols]=NA
  for ( k in 1:length(uids) ) {
    clin2bsel = clin2b$PATNO == uids[k]
    if ( sum( clin2bsel ) > 0 ) {
      # print(paste("have",u))
      clin2b[clin2bsel,newcols]=lrrk2[k,lrrk2cols]
    } # else print(paste("miss",u))
  }
  clin2b$LRRK2_study = !is.na( clin2b$LRRK2_cohort)
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_dwi_mean +T1Hier_evratio + noise + snr + msk_vol,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+T1Hier_resnetGrade +T1Hier_evratio + cnr + noise,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~  cnr + noise  + msk_vol + spc0+	spc1+	spc2,data=clin2b) )
  clin2b$subjectID = as.character(clin2b$subjectID)
  clin2b$imageID = as.character(clin2b$imageID)
  clin2b$dtid1 = as.character(clin2b$dtid1)
  clin2b$dtid2 = as.character(clin2b$dtid2)
  clin2b$rsfid1 = as.character(clin2b$rsfid1)
  clin2b$rsfid2 = as.character(clin2b$rsfid2)
  clin2b=dplyr::bind_rows( clin2b, adni )
  nna=!is.na( clin2b$AsynStatus )
  clin2b$DXSubAsyn[nna]=paste0( clin2b$joinedDX[nna], clin2b$AsynStatus[nna] )
  clin2b$DXSubAsyn[ clin2b$DXSubAsyn == "NANegative"]=NA
  clin2b$commonEdu[ clin2b$commonEdu == 1] = 12
  clin2b$commonEdu[ clin2b$commonEdu == 2] = 16
  clin2b$commonEdu[ clin2b$commonEdu == 3] = 20
}
ppmi = clin2b
ppmi$T1Hier_midbrain_pons_ratio = ppmi$T1Hier_vol_midbrainbrainstem / ppmi$T1Hier_vol_ponsbrainstem
ppmi$SITE = factor( ppmi$SITE )
ppmi$brainVolume = ppmi$T1Hier_vol_hemisphere_lefthemispheres + ppmi$T1Hier_vol_hemisphere_righthemispheres
ppmi$brainVolume = ppmi$brainVolume / mean(ppmi$brainVolume)
ppmi$imaging_protocol[ ppmi$studyName=='ADNI']=3
ppmi$imaging_protocol=factor(ppmi$imaging_protocol)
ppmi[ ppmi$studyName=='ADNI', 'age_BL']=ppmi[ ppmi$studyName=='ADNI', 'AGE']

```


```{r maketrim,echo=FALSE,eval=!exists("ppmitrim")}
ppmi = antspymm_predictors( ppmi, TRUE )
ntokeep = 2950
ppmitrim = ppmi[ ppmi$studyName == 'PPMI',]
ppmitrim = ppmitrim[ head( order(ppmitrim$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
updnames = getNamesFromDataframe("upd",ppmi,exclusions=c("BL","delta"))
msnames = getNamesFromDataframe("pm_",ppmi,exclusions=c("BL","delta"))
lrrk2names= getNamesFromDataframe("LRRK2_",ppmi,exclusions=c("BL","delta","LRRK2_MRIPROTOCOL"))
t1namesctx = getNamesFromDataframe( c("T1Hier","LRAVG",'dktcortex','thk'), ppmitrim)
t1namescit = getNamesFromDataframe( c("T1Hier","LRAVG",'deep','vol'), ppmitrim)
t1namesnbm = getNamesFromDataframe( c("T1Hier","LRAVG",'nbm','vol'), ppmitrim)
t1namesbst = getNamesFromDataframe( c("T1Hier",'brainstem','vol'), ppmitrim, exclusions=c("tissues","lobes"))[-1]
t1namescrb = getNamesFromDataframe( c("T1Hier",'cerebellu','LRAVG','vol'), ppmitrim, exclusions=c("tissues","lobes","dktregion"))
t1namesctxa = gsub("LRAVG","Asym",t1namesctx)
t1namescita = gsub("LRAVG","Asym",t1namescit)
t1namesnbma = gsub("LRAVG","Asym",t1namesnbm)
t1namescrba = gsub("LRAVG","Asym",t1namescrb)
t1vars = c(t1namesbst,t1namesctx,t1namescit,t1namesnbm,t1namescrb,t1namesctxa,t1namescita,t1namesnbma,t1namescrba)
ppmitrim0 = ppmitrim[ , c("subjectID","age_BL",'commonSex', "hy_BL", "duration_yrs","LEDD","moca",updnames, msnames, 'joinedDX','AsynStatus', "DXSubAsyn", "educ","race",'tau','ptau','abeta', 'yearsbl', 'EVENT_ID', 'date', lrrk2names,  'filename', 'brainVolume', t1vars, 'imaging_protocol', 'T1Hier_resnetGrade' ) ]

# write.csv( ppmitrim0, '~/Downloads/ppmitrim0_SR_first_extended.csv',row.names=FALSE)
# head( ppmitrim0, 2 )
# isbl=subtyper::fs(ppmitrim$yearsbl==0 & ppmitrim$joinedDX == 'PDSporadic')
# temp=ppmitrim[isbl,]
# trimT1 = dcurvarsel( temp, c(t1namesctx,t1namescit), 1 )

# get numbers for abstract
viztbl = table( ppmitrim0$joinedDX, ppmitrim0$EVENT_ID )
isbl=ppmitrim0$yearsbl==0
npd=viztbl["PDSporadic","BL"]
npdf=sum(viztbl["PDSporadic",c("V04","V06","V08","V10","V12")])
ngpd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('PDGBA','PDLRRK2','PDSNCA' )))
ncn=viztbl["CN","BL"]
nprepd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('ProdromalGBA','ProdromalLRRK2' ,'ProdromalSNCA','ProdromalSporadic' )))
vizfll=mean( ppmitrim0$yearsbl[!isbl] )
vizfll=insight::format_value( vizfll )
# tt = table( table( ppmitrim0$subjectID[!isbl] ) )

```

# Abstract

The Parkinson's Progression Markers Initiative (PPMI) delivers multiple modality MRI (M3RI) and biomarker data for a comprehensive longitudinal study of Parkinson's Disease (PD).  These provide quantitative indices of deep brain and cortical structure (T1-weighted MRI), microstructural integrity of brain tissue (diffusion-weighted imaging) and resting brain function (resting state functional MRI).  Integrating and uniformly analyzing M3RI alongside non-imaging biological and clinical data is challenging due to the distinct nature of each modality. This study systematically organizes this complex data into a structured format, provides a PD-focused evaluation of the methodologies and evidence for technical robustness of the approach.  The cohort encompasses `r npd` idiopathic PD, `r ngpd` genetic PD, `r nprepd` presymptomatic PD and `r ncn` control subjects at baseline with followup at a mean of `r vizfll` years.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy bodies, primarily composed of misfolded alpha-synuclein, and appearing in the substantia nigra at an early stage [@fearnley_ageing_1991]. The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [@lee_mechanisms_2006;@dickson_neuropathology_2009;@calabresi_alpha-synuclein_2023]. The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [@shahnawaz_discriminating_2020; @siderowf_assessment_2023].

Analyzing the link between SAA status and longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking pathology, symptoms and imaging [@nemmi_totally_2019; @tremblay_sex_2020; @markello_multimodal_2021].

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI from 2010 to 2023, focusing on T1-weighted, diffusion-weighted, and resting-state functional MRI for analyzing neurodegenerative diseases. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [@avants_pediatric_2015; 
@stone_functional_2020; @tustison_antsx_2020]

To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] and an additional easily accessible M3RI young control cohort [@avants_pediatric_2015].  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate the neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [@schwarz_t1-weighted_2011;@aquino_substantia_2014;@ryman_mri_2020]. Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [@peran_magnetic_2010] but also in LRRK2-PD [@tolosa_lrrk2_2020]. Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [@hacker_resting_2012;@kim_abnormal_2017]. Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain, pointing towards a more integrative approach to understanding PD [@menke_mri_2009;@markello_multimodal_2021] and the role of alpha-synuclein in these effects [@simuni_biological_2024].

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs are computed with [ANTsPyMM](https://pypi.org/project/antspymm/) and depend on standard anatomical and functional hierarchies that are well-established in the field and consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dwMRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables easily merge with the associated demographics, SAA status, clinical data such as the Unified Parkinson's Disease Rating Scale (UPDRS) [@disease_unified_2003] and standard PPMI DAT-SPECT summary measurements [@bega_clinical_2021; @droby_aberrant_2022]. Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.


# Methods

![Overview of ANTsPyMM outputs for T1-weighted MRI, diffusion MRI and resting state fMRI.  Panel (a) shows example input data; the package does not require all modalities to be present -- only T1w.  It also handles arterial spin labeling (perfusion), FLAIR and neuromelanin, not covered here.  Panel (b) illustrates core T1w outputs across several inter-related and PD relevant systems in the brain.  Panel (c) shows the standard outputs associated with DTI. Whole brain tractography is also output but no evaluation results are available to contextualize its performance and, as such, we do not recommend its use.  Panel (d) summarizes the various rsfMRI outputs for processing parameter set number 122 referred to with a prefix `rsfMRI_fcnxpro122`.](../figs/antspymm_3.jpg)

## MRI data collection 

MRI data collection occurred between 2010 and an August 2023 cutoff date for these data.  Two phases of MRI collection occurred in PPMI; the first collected T1w and later DTI as part of exploratory investigations.  In 2020, a new phase of collection sought to improve both MRI quality and consistency and expand the number of modalities collected.  The sequences used at each site are provided in detail at FIXMEDATARECORD and in the original Laboratory of Neuroimaging (LONI) source data (described below in Data Records). The "phase" of data collection is captured in the variable `imaging_protocol`.  Table FIXME summarizes the cohort characteristics.


```{r tblprep,eval=TRUE,echo=FALSE,cache=FALSE}
###
toadd = c(  "age_BL", "commonSex", 'race', 'hy_BL', 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD', 'imaging_protocol')
biomarkers = c('abeta', 'tau',  'nfl_serum', 'mean_striatum' )
tblcols = unique( c( toadd, 'joinedDX'  ) )
bsel = ppmitrim$yearsbl==0 # & ppmi$studyName == 'PPMI'
joinedem=ppmitrim[bsel,tblcols]
joinedem$imaging_protocol=as.character(joinedem$imaging_protocol)
joinedem$hasDTI=!is.na(ppmitrim[bsel,'DTI_dti_FD_mean'])
joinedem$hasfMRI=!is.na(ppmitrim[bsel,'rsfMRI_fcnxpro129_FD_mean'])
names(joinedem)[1]=tblcols[1]='age'
names(joinedem)[2]=tblcols[2]='Sex'
wsaa=which(names(joinedem)=='AsynStatus' )
names(joinedem)[wsaa]=tblcols[wsaa]='CSFSAA'
tblcols=colnames(joinedem)
tblcols=gsub("_",".",tblcols)
tblcols=gsub(".mean","",tblcols)
tblcols=gsub("DTI.","",tblcols)
tblcols=gsub("rsfMRI.fcnxpro122.","rsfMRI.",tblcols)
names(joinedem)=tblcols
joinedem$race = as.character( joinedem$race )
joinedem[ is.na(joinedem$race), 'race' ] = 'not.spec.'
joinedem$joinedDX = gsub("Prodromal",'AR',joinedem$joinedDX)
joinedem$joinedDX=as.character(joinedem$joinedDX)
joinedem$joinedDX[ 
  multigrep( c("ARSporadic"), joinedem$joinedDX )]='SporadicAR'
joinedem$joinedDX[ 
  multigrep( c("ARGBA", "ARLRRK2",  "ARSNCA"), joinedem$joinedDX )]='GenAR'
joinedem$joinedDX[ 
  multigrep( c("PDGBA",    "PDLRRK2", "PDPRKN", "PDSNCA"), joinedem$joinedDX )]='GenPD'
joinedem$joinedDX[ 
  multigrep( c("PDSporadic"), joinedem$joinedDX )]='SporadicPD'
mlevs = c( "CN", "GenAR", "SporadicAR","GenPD", "SporadicPD")
joinedem$joinedDX = factor( joinedem$joinedDX, levels = mlevs )
mytbl = joinedem[ !is.na(joinedem$joinedDX),c(tblcols)]
rownames(mytbl)=1:nrow(mytbl)
mycap="Table 1. Baseline cohort for subjects with T1w IDPs and non-missing diagnosis."
####
```

```{r clusterCharARtbl,eval=TRUE,echo=FALSE,cache=FALSE,results='asis'}
sttblPD=ztable(mytable(joinedDX~.,data=mytbl[,tblcols]))

# Print the ztable object, ensuring it's treated as LaTeX code
print(sttblPD, type = "latex",size=4,caption=mycap,sidewaystable=TRUE)


```


```{r tbl1instead,eval=FALSE,echo=FALSE,cache=FALSE,results='asis'}
library(table1) # https://cran.r-project.org/web/packages/table1/vignettes/table1-latex.pdf
x=table1(~ . | joinedDX, data=mytbl[!is.na(mytbl$joinedDX),], topclass="Rtable1-zebra",caption=mycap)
t1kable(x)
```

### Data Organization

Raw DICOM data was downloaded from LONI and converted to nifti format via [`dcm2niix`](https://pubmed.ncbi.nlm.nih.gov/26945974/). These data were then organized into a directory tree following the [NRG format](https://github.com/stnava/biomedicalDataOrganization) illustrated in Figure FIXME. This BIDS-like structure [@BIDSREFERENCE] is defined to aid in longitudinal analyses of multiple modality data and intends to support: (a) sortable and specific dates associated with imaging sessions; (b) links between the data on disk and its origin (LONI) through the "Image ID"; (c) easy maintenance of multiple modality data collections; and (d) predictable input/output structure.  Critically, the unique ID allows the original data associated with an IDP to be easily found in LONI.  In brief, this system assigns each image -- and categories of derivative data -- a directory and individual file name that assist in making data findable, accessible, interpretable and reproducible (FAIR) for both early and downstream processing.

![The NRG format supports predictable and interpretable data storage and processing that can easily be tied back to the LONI source dicom.  The filename proceeds from less specific information(Project ID at reader's left) to the most specific (unique image ID at reader's right).  A specific character -- here the dash -- is reserved exclusively as a separator between the stages of information.](../figs/nrg_format.jpg)

### ANTsPyMM processing

ANTsPyMM collects and documents best ANTsX practices for both data inspection and IDP generation for the modalities of interest in a single python package.  While ANTsPyMM supports BIDS format, it behaves most predictably and safely with NRG format.  Each "run" of the integrated multiple modality processing encoded by ANTsPyMM is driven by a data frame that defines a multiple modality "collection" of images for a given subject at a given date.  There are two key functions that aid users in defining the appropriate input data structure (the multiple modality subject dataframe) given the data on disk and sending that data to processing.  The first is `antspymm.generate_mm_dataframe` which generates the appropriate multiple modality subject dataframe that documents the available images and their on disk locations.  The output of this function should be written to disk as it defines the expected input as well as output.  The second key function runs the multiple modality processing (`antspymm.mm_csv`) based on the multiple modality subject dataframe.  The "Usage Notes" section provides more details on this system with an accompanying reproducible example based on freely accessible multiple modality neuroimaging.

### Semi-automated quality assessment

ANTsPyMM's primary goal is reliable M3RI IDP generation but necessarily addresses quality control (QC) with particular focus on the T1w modality i.e. the core anatomical image that represents the most consistently collected MRI in PPMI. T1w is also the focus of QC because ancillary modality processing depends heavily on anatomical labels (e.g. tissue segmentation, cortical parcellation) derived from these images.  As such, we developed an automated (deep learning based) T1w reviewer that is trained on human (BA) QC reviews.  Each T1w image is therefore reviewed internally in the first stage of ANTsPyMM processing by this `resnetGrader` (a deep learning model trained to predict image quality) [@avants2022]. The grader will abort processing if the T1w does not achieve a given baseline level of quality.  Human visual inspection was performed on images that pass the grader by BA and serves as a sanity check to the automated method.  The `resnetGrader` successfully filtered unusable data and we selected a quality cutoff at `r min(ppmitrim$T1Hier_resnetGrade)` to filter out low quality images.  Similarly, the rsfMRI and DTI were reviewed in `post hoc` fashion.  This process involved visually inspecting each estimated FA image and each estimated default mode network connectivity map and its associated mean BOLD image.  Particular focus was paid to cases with high motion and/or low SNR.

## Neuroanatomical coordinate systems

The statistical interpretation of processed images is aided by automatic anatomic labeling with pre-specified coodinate systems or maps overlaid on each subject's neuroimage. We leverage a recent homotopic parcellation [@FIXME], the Desikan-Killiany-Tourville (DKT) system [@FIXME], the CIT168 atlas [@FIXME], the Johns Hopkins University (JHU) white matter labels [@FIXME], the Schmahmann cerebellar parcellation [@FIXME], brain stem labels [@FIXME], a medial temporal lobe schema [@FIXME] and labels derived from probabilistic maps of the basal forebrain [@FIXME].  These systems are described in detail in online [data dictionary and associated documentation](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) for this project. These coordinate system enable PD researchers to interrogate a variety of hypotheses related to, for example, known functional networks, association hubs, cholinergic networks, the striatum or dopaminergic systems.

### T1-weighted MRI processing

T1-weighted MRI processing is described in detail in @tustison_antsx_2021. This open-source software ecosystem includes tools for image registration, segmentation, and super-resolution (SR) as customized for the human brain.  The derived measurements are tabulated by the neuroanatomical coordinates defined above and include cortical and subcortical measurements and morphological measurements of the hippocampus, basal forebrain and cerebellum.  The results of this stage are key to consistent processing of concomitant rsfMRI and DWI. We provide both original resolution (OR) and SR results as part of this effort.  For SR processing of T1w, the network is applied -- first -- over the whole head T1w image to double resolution along all axes within the brain parenchyma. Otherwise, SR and OR processing are identical. SR training with 3D perceptual losses is documented in the `python` package [siq](https://pypi.org/project/siq/) and is based on `tensorflow` implementations of a volumetric deep back projection network (DBPN) [@FIXME;@FIXME] .  See Figure FIXME for examples of these outputs.  IDPs derived from the T1 processing are denoted by prefixes `T1w` and `T1Hier`.


![Example ANTsPyMM SR outputs applied to T1-weighted MRI (upper left) and diffusion MRI. T1w is super resolved to 0.5mm isotropic and DTI to 1mm.](../figs/sr_comparison.jpg)

### Diffusion weighted MRI processing

Diffusion tensor image (DTI) processing leverages best practices from both ANTsX [@FIXMEPTBP] and the collaborative DTI-focused project [DiPy](https://www.frontiersin.org/articles/10.3389/fninf.2014.00008/full). This pipeline is specifically designed to utilize DWI acquisitions with either a single or opposed phase encoding directions. The functionality has been developed to address a broad spectrum of preprocessing requirements, such as motion correction, denoising, dewarping and gradient reorientation, and enhancement through SR techniques, culminating in an optimized DTI reconstruction. The SR stream applies to each volume in the DWI timeseries after motion correction and distortion correction but before tensor fitting i.e. in a relatively minimally invasive fashion.  After reconstruction, the pipeline integrates atlas-based labeling and template-based normalization processes, thereby enhancing the anatomical interpretability of the DTI metrics.  Figure FIXME summarizes the pipeline which follows these steps:

![Overview of the DTI processing pipeline based on ANTsX and DiPy.](../figs/dti_pipe.jpg)

1. **Input Preparation**: The pipeline accepts either a single DWI or a pair of DWI with reversed phase encoding. It also requires associated b-values and b-vectors for each direction, alongside a T1-weighted image and a brain mask for improved spatial accuracy in inter-modality registration.

2. **Initial Reconstruction and Motion Correction**: By default, the DWI data is denoised before performing motion correction. This is skipped when applying SR which integrates denoising.  Motion correction aligns DWI volumes within and across acquisitions to a reference mean B0 and mean DWI, reducing artifacts due to subject movement.

3. **Dewarping and Super-Resolution**: Dewarping is applied to correct for distortions between the DWI space and the T1-weighted image. Optionally, SR is applied after dewarping but before the DiPy based reconstruction process.

4. **Reconstruction of DTI Metrics**: The function employs weighted least squares to reconstruct DTI metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD) from the preprocessed DWI data. This step is pivotal in quantifying the diffusion properties of brain tissue. 

5. **Atlas-Based Labeling and Registration**: Utilizing the Johns Hopkins University (JHU) atlas and corresponding labels, the pipeline performs spatial registration of the DTI to the atlas space. This process facilitates anatomical localization and quantification of DTI metrics within predefined brain regions. 

6. **Output Generation**: The pipeline yields a comprehensive output including the reconstructed DTI metrics, summary statistics of these metrics within atlas-defined regions, the spatial registration information, and additional diagnostic metrics such as framewise displacement and signal-to-noise ratio (SNR) assessments spatially and temporally for both B0 and DWI. An example output volumetric tensor image with labels is in Figure FIXME.

IDPs derived from the DWI processing are denoted by prefixes `DTI_`.

![Example SR processing for DTI highligting the multiple coordinate systems that are available to aid interpretation.](../figs/dti_SR.jpg)


### Resting state functional MRI processing 

Resting state functional MRI (rsfMRI) processing builds on prior multi-view techniques performed in this same ecosystem [(avants2015)](https://www.nature.com/articles/sdata20153) [avants2016](https://doi.org/10.1016/j.neurobiolaging.2018.10.002).  The procedure is based on the findings described in three comprehensive evaluation studies [@FIXME] and is designed to compute both functional activity and correlation maps utilizing the recently proposed homotopic labels to delineate major network systems [@FIXME]. The methodology described below is grounded in contemporary understanding of resting-state fMRI analysis and incorporates recommendations from seminal works regarding optimal preprocessing for minimizing motion artifacts and other sources of noise (Ciric et al., 2017; Parkes et al., 2018). As such, our processing reflects a comprehensive approach to resting-state fMRI IDP extraction for real-world multi-site studies of neurodegenerative disease.  Overall, the methods aim to facilitate the reliable extraction of functional connectivity patterns that are consistent with underlying neural mechanisms.  Similar to the DWI processing, the procedure accepts either a single image or a pair of images with reversed phase encoding direction.  The steps are outlined in Figure FIXME:

![Overview of the rsfMRI processing pipeline based on ANTsX.](../figs/fmri_pipe.jpg)

1. **Input Preparation**: Inputs include the raw BOLD fMRI time-series data, a reference volumetric subject-specific fMRI template (automatically generated), and T1-weighted anatomical images all from the same subject. These inputs are foundational for aligning functional data with anatomical landmarks and for ensuring that subsequent analyses are anatomically informed.  By default, the input fMRI is upsampled to 3mm isotropic resolution and 8 initial volumes are discarded to allow for both signal and subject stabilization.

2. **Preprocessing**: Initial steps include motion correction, application of a despiking algorithm (a `python` implementation of AFNI's 3dDespike [@FIMXE]), and anatomical registration to align the fMRI data with the T1-weighted image.  If a pair of images is passed, these same preprocessing steps are applied and results are concatenated along the time axis.

3. **Noise Reduction**: Anatomical CompCor (aCompCor) is used to mitigate physiological and other noise sources. This is based on recommendations from studies examining the impact of preprocessing strategies on functional connectivity (Ciric et al., 2017; Parkes et al., 2018).

4. **Band-pass Filtering and activity calculation**: The application of a specific frequency range for filtering aligns with recommendations from Shirer et al. (2015) and Parkes et al. (2018), emphasizing the importance of selecting appropriate frequency bands for resting-state analysis.  The default frequency bands are based on empirical evaluation studies described below.

5. **Censoring**: Select volumes are censored based on both motion-based and intensity-based outlier detection.  The parameters for this stage derive from empirical evaluation studies on publicly available data as discussed below.  Both *censored* and *imputed* versions of the time series are created.  A summary of censoring results is recorded in several ways but perhaps most relevant are the variables `*minutes_original_data` and `*minutes_censored_data` which provides the length in minutes of the original versus processed data.

6. **Network Correlation Analysis**: This step involves calculating correlation matrices for identified resting-state networks, utilizing labels described above.  Both inter and intra-network correlation values are computed for each of the sub-networks provided by the homotopic parcellation.  

7. **Functional activity**: is computed with three models: mfALFF, mALFF and mPerAf as described in [@FIXME].  These are versions of fALFF, ALFF and PerAf where each is divided by the global mean in the brain.  Summary values are averaged within each of 500 labels in the homotopic label set which facilitates left/right asymmetry and mean values which are critical to studying diseases with laterality effects.

Due to the relatively diverse needs of researchers and the variety of rsfMRI that is generally present in public data, we run the above processing with three different sets of parameters (sets [122, 134 and 129](https://github.com/ANTsX/ANTsPyMM/blob/4d10c3a7c4a962c00a3c198ba0e00f35da25776d/antspymm/mm.py#L6496-L6506)) for censoring based on motion and intensity outlierness.  These three parameter choices led to rsfMRI IDPs that were the top performers in terms of reliability and predictive power out of 78 that we tested empirically.  See [this repository](https://github.com/stnava/antspymm_reproducibility) and the technical validation section for further details. IDPs from the rsfMRI processing are denoted by prefixes `rsfMRI_fcnxpro122` for 122 and similarly for 129 and 134.

# Data Records

The PPMI IDPs for T1w, rsfMRI and DTI are located at FIXME. The neuroimaging and associated standard PPMI demographics and clinical data is hosted in the [LONI Imaging Data Archive (LONI IDA)](http://ida.loni.usc.edu). The former is stored in DICOM format and the latter in tabular `csv` format.  Additionally, data dictionaries describing all non-imaging column headers are available on the LONI IDA.  

We attach the neuroimaging IDPs to the PPMI Curated Data Cut Curated (v.2023-06-12 `PPMI_Curated_Data_Cut_Public_20230612_rev`) available on the LONI IDA.  Code for this merging process is available via the [subtyper package](https://stnava.github.io/subtyper/) specifically the function [merge_ppmi_imaging_clinical_demographic_data](https://stnava.github.io/subtyper/reference/merge_ppmi_imaging_clinical_demographic_data.html).  The M3RI IDPs are described in detail [here](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) and are available in a data table within the `ANTsPyMM` repository (csv format).  The full tabular IDPs for both OR and SR outputs are available at [this location](FIXME).  We also provide a "trim" version [here](FIXME) that is intended to allow users to "get started" with these data without being overwhelmed by the sheer number of variables (many thousand in raw form).  We base demonstrations below on the trim version of these PPMI IDPs and justify their choice based on extant results in the literature.

# Technical Validation

Components of technical validity that are critical for quantitative methodology in neuroimaging include: (a) generally robust performance across modalities; (b) multi-site reproducibility; (c) disease-specific discrimination from controls in particular over time in the clinical trial setting; (d) sensitivity to or relationship with changes in clinically relevant symptoms at baseline and/or over time.  We provide evidence that the current IDPs satisfy these properties in the following sections.  

* We quantify reproducibility and reliability in each modality through analysis of three traveling subject cohorts (addressing (a) and (b) above). These cohorts collect imaging data at different sites from the same individuals.  Reliability data based on such cohorts are highly relevant for multisite trials which are always impacted by site-specific variation.  By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) manifested across different scanner types and imaging modalities.  

* We derive effect sizes from statistical models that test established hypotheses comparing SAA positive PD subjects versus control subjects.  These show expected effects of PD are detectable in these data.  This addresses (c) above.

* We finalize the technical validity section with examples of how scientists may relate baseline brain health to rate of symptom change in PD in an interpretable and modality-specific manner as well as a multiple modality (integrative) context.  This addresses (d) above.

The scale of the current data supports control for a subset of important PD relevant covariates including disease duration, educational level, sex, age and levodopa dose equivalent daily dose (LEDD).  These variables are included in reference models with additional details below.

## Robust performance

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges [@FIXME] that span modalities and organ systems.  The foundational methods also support applications to non-human data [@FIXME].  Furthermore, the consistency of the methodology naturally enables multivariate statistical inference and/or prediction [@BLAST] even within the multi-study context [@FARAZ].

## Multi-site reproducibility

Traveling subject studies involve scanning the same subjects on multiple MRI scanners at different locations. These studies help in assessing consistency and/or agreement of image quantification where the only variables are the machines themselves. This is crucial for understanding power in multi-site studies of natural history or intervention and for ensuring that the observed changes in brain structure or function are due to actual physiological changes rather than variations in the imaging process itself. 

In this study, we employ traveling cohort data to assess the agreement of IDPs pooled across multiple sites for the purposes of statistical inference. These data will establish expectations of repeatability for T1w, DTI and rsfMRI as measured by ANTsPyMM processing.  Thus, we use these data to characterize the consistency and reliability of these tools when applied to data that has known systematic biases due to site and scanner differences.  The results confirm that findings and conclusions drawn from ANTsPyMM are reliable and not overwhelmed by scanner-specific differences or inconsistencies.  This knowledge is critical for a foundational framework such as ANTsX/ANTsPyMM upon which scientific studies, machine learning platforms and other methodological comparisons are based. These cohorts represent variability in both MRI manufacturer and MRI model (high variability) that would exceed standard (within-scanner, within-site) test-retest analysis.  Results therefore provide a lower-bound on reliability; i.e. within-site (e.g. longitudinal) studies would be expected to have higher reliability in general.

![Summary reproducibility results from aggregated traveling subject data. T1 IDPs represent high reproducibility in all categories (cerebellum, CIT168, cortical volume, cortical thickness, basal forebrain and medial temporal lobe).  DTI IDPs are also highly reproducible with FA in the cortical gray matter (gm) nearly equaling that of major white matter regions in the JHU atlas. Resting state connectivity shows good to excellent reproducibility; PerAF, fALFF and ALFF are relatively less reproducible -- on average -- though variability is also high.](../figs/antspymm_repro.png)

We find that ANTsPyMM IDPs derived from the same subjects imaged at different sites with MRI from various manufacturers show overall good to high reliability with a few exceptions within resting state derivatives (fALFF specifically).  This provides empirical evidence that multiple modality MRI may be used to derive quantitative phenotypes on which predictive models may be based.  Statistical control for site effects should still be applied at the population level using, for example, random effects.  The data and code for reproducing these results is available in [this location](https://github.com/stnava/antspymm_reproducibility).

<!--
## Multi-view prediction 

We classify PD and control cases based on the available data using a standard machine learning (ML) paradigm available in the `mlr3verse` [@FIXME].  MLR3 allows systematic comparison of cross-validated performance between different ML models as well as feature sets.  As such, we compare performance between (a) T1w only versus (b) T1w plus DTI features as a function of either OR or SR calculations.  These results demonstrate that both joint modeling (DTI and T1 together) and SR improve classification accuracy over T1 alone or OR features.  Figure FIXME demonstrates a comparison of T1 only performance versus T1 plus DTI performance in terms of both raw and balanced accuracy using SR features.  Only better performing models are shown including: glmnet [@FIXME], imbalanced random forests [@FIXME], naive bayes classifier [@FIXME] and classic random forests [@FIXME].  The "featureless" model is the baseline classifier (no imaging features are used).

-->

```{r classified,echo=FALSE,eval=FALSE,fig.width=6,fig.height=9,message=FALSE,warning=FALSE,cache=FALSE}
############################
ppmi = antspymm_predictors(ppmi, TRUE )
ppmi$age_BL = antsrimpute( ppmi$age_BL )
ysel = ppmi$yearsbl >= 0 & !is.na( ppmi$T1Hier_thk_r_i_iicerebellum) & !is.na(ppmi$T1Hier_volLRAVGi_iicerebellum) & subtyper::fs( ppmi$T1Hier_resnetGrade > 1.01 )
ysel = ppmi$yearsbl == 0 & !is.na( ppmi$T1Hier_thk_r_i_iicerebellum) & !is.na(ppmi$T1Hier_volLRAVGi_iicerebellum) & subtyper::fs( ppmi$T1Hier_resnetGrade > 1.01 )
dtvec = ppmi$DTI_mean_fa.body_of_corpus_callosum.jhu_icbm_labels_1mm
seldti = subtyper::fs( dtvec >= quantile(dtvec,0.005, na.rm=TRUE) )
selfl = !is.na( ppmi$T2Flair_flair_wmh_prior )
selfmri=!is.na(  ppmi$rsfMRI_fcnxpro122_VisPeri_2_SalVentAttnA) & 
  !is.na(ppmi$rsfMRI_fcnxpro122_ContA_2_ContA) & 
  subtyper::fs(ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5)
ppmi$DXbasic = NA
ppmi$DXbasic[ grep("CN",ppmi$joinedDX)]='CN'
ppmi$DXbasic[ grep("Prodromal",ppmi$joinedDX)]='AR'
ppmi$DXbasic[ grep("PD",ppmi$joinedDX)]='PD'
ppmi$DXbasic[ grep("AD",ppmi$joinedDX)]='AD'
ppmi$DXbasic[ grep("MCI",ppmi$joinedDX)]='MCI'
cohortCCbl = ppmi[ ysel, ]
# now match ADNI + ppmi 
selcn = subtyper::fs( cohortCCbl$joinedDX=='CN' )
tarsam = sum( subtyper::fs(cohortCCbl$studyName=='PPMI' & selcn ))
mm = match_cohort_pair( 
  cohortCCbl[ cohortCCbl$studyName=='ADNI' & selcn,],
  cohortCCbl[ cohortCCbl$studyName=='PPMI'& selcn,], 
  c('age_BL'), option='rand', restrict_df1=0.05, 
  num_iterations=1000,
  sample_size=tarsam,verbose=T)
matcheddemog  = cohortCCbl$studyName=='PPMI' | rownames(cohortCCbl)  %in% mm
cohortCCbl=cohortCCbl[ matcheddemog, ]
t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI','age_BL'],
  cohortCCbl[ cohortCCbl$studyName=='ADNI','age_BL'] )
t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI' & cohortCCbl$joinedDX=='CN','age_BL'],
  cohortCCbl[ cohortCCbl$studyName=='ADNI'& cohortCCbl$joinedDX=='CN','age_BL'] )
# t.test( cohortCCbl[ cohortCCbl$studyName=='PPMI'&selcn,'age_BL'],
#  cohortCCbl[ mm,'age_BL'] )

dxv='joinedDX'
dxs = c("CN","PDSporadic")
dxv='AsynStatus'
dxs = c("Negative","Positive")
dxv='DXbasic'
dxs = c("CN","PD")
dxv='DXSubAsyn'
dxs = c("PDSporadicNegative","PDSporadicPositive")
dxs = c("ProdromalSporadicNegative","ProdromalSporadicPositive")
dxs = c("CNNegative","PDSporadicPositive")
############################
cohortCCbl = cohortCCbl[ cohortCCbl[,dxv] %in% dxs , ]
cohortCCbl$DXbio = 0
cohortCCbl$DXbio[  cohortCCbl[,dxv] == dxs[2] ] = 1
cohortCCbldt = cohortCCbldt[ cohortCCbldt[,dxv] %in% dxs , ]
cohortCCbldt$DXbio = 0
cohortCCbldt$DXbio[  cohortCCbldt[,dxv] == dxs[2] ] = 1
cohortCCblrsf = cohortCCblrsf[ cohortCCblrsf[,dxv] %in% dxs , ]
cohortCCblrsf$DXbio = 0
cohortCCblrsf$DXbio[  cohortCCblrsf[,dxv] == dxs[2] ] = 1
idps = antspymm_predictors(cohortCCbl, TRUE, TRUE )
idps = idps[ -grep("rsfMRI_fcnxpro129",idps)]
idps = idps[ -grep("rsfMRI_fcnxpro134",idps)]
idps = idps[ -grep("unclass",idps)]
idps = idps[ -grep("T1Hier_RandBasis",idps)]
idps = idps[ -grep("die_hth",idps)]
# idps = idps[ multigrep( c("Asym","LRAVG"), idps ) ]
idpst1 = unique( c( 
  idps[ multigrep( c("T1Hier","LRAVG","cerebellum","thk"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","dktcortex","thk"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","deep_cit168","vol"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","Asym","deep_cit168","vol"),idps,intersect=TRUE)],
  idps[ multigrep( c("T1Hier","LRAVG","nbm","vol"),idps,intersect=TRUE)],
#  idps[ multigrep( c("T1Hier","Asym","nbm","vol"),idps,intersect=TRUE)],
  getNamesFromDataframe( c("vol","brainste"), ppmi, exclusions=c("lobe","issu","cleanup")) ) )
idpsdt = unique( c( 
    idps[ multigrep(c("DTI","mean_md","LRAVG"),idps,intersect=TRUE)],
    idps[ multigrep(c("DTI","mean_fa","LRAVG"),idps,intersect=TRUE)] ) )
xcl = antspymm_nuisance_names()
idpsrsfmri = c(
  getNamesFromDataframe( c("rsfMRI_fcnxpro122","_2_"), ppmi, exclusions=xcl ),
  getNamesFromDataframe( c("rsfMRI_fcnxpro122","_falff"), ppmi, exclusions=xcl ) )
print(table( cohortCCbl[,dxv]))
idpnas = rep(0,length(idps))
for ( k in 1:length( idps ) ) idpnas[k]=sum(is.na(cohortCCbl[,idps[k]]))
idpvars = apply( cohortCCbl[,idps], MARGIN=2, FUN=var )
names(idpvars)=idps
cohortCCbl$imaging_protocol = as.numeric( cohortCCbl$imaging_protocol )
if ( ! exists("nrep") ) nrep = 50
# idpst1 = dcurvarsel( cohortCCbl, idpst1, 0.5 )
# idpsdt = dcurvarsel( cohortCCbldt, idpsdt, 0.5 )
# idpsrsfmri = dcurvarsel( cohortCCblrsf, idpsrsfmri, 0.5 )
#########################
mycx = mlr3classifiers()
# mycx = mycx[ !( mycx %in% c("classif.gbm", "classif.ksvm", "classif.fnn",  "classif.kknn", "classif.rpart", "classif.xgboost", "classif.ranger") ) ]
mycx = mycx[ !( mycx %in% c("classif.gbm",  "classif.fnn", "classif.rpart", "classif.ranger") ) ]
mycx = c( mycx, "classif.featureless" )
mybal = 'over'
srate = 0.95
dxtbl=table( cohortCCbl[,'DXbio'] )
mysamp = floor(  max(dxtbl)/min(dxtbl)) 
cohortCCbl$sex=0
cohortCCbl$sex[cohortCCbl$commonSex=='Male']=1
if ( FALSE ) {
#  for ( z in c(idpst1,idpsdt,idpsrsfmri) ) {
  for ( z in c(idpst1) ) {
    loform = paste0( z , "~studyName" )
    cohortCCbl = adjustByCovariates(cohortCCbl,loform )
      # groupVariable='DXbasic',group='CN')
  }
  idpst1 = paste0(idpst1,"_adjusted")
#  idpsdt = paste0(idpsdt,"_adjusted")
#  idpsrsfmri = paste0(idpsrsfmri,"_adjusted")
}
#######
cohortCCbl[,idpst1] = antsrimpute( cohortCCbl[,idpst1])
cohortCCbl$study = 0
cohortCCbl$study[ cohortCCbl$studyName == 'ADNI']=1
mycvbs0 = mlr3classifiercv(
       cohortCCbl[ cohortCCbl$DXbio == 0, ],
       tcols = c("study", 'sex','age_BL', idpst1 ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbl$subjectID[ cohortCCbl$DXbio == 0],
       verbose = FALSE
     )
aggbs0 = aggregate( bacc ~ mdl, mycvbs0, mean )
aggbs0
mycvbs = mlr3classifiercv(
       cohortCCbl,
       tcols = c("DXbio", 'sex','age_BL' ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbl$subjectID,
       verbose = FALSE
     )
aggbs = aggregate( bacc ~ mdl, mycvbs, mean )
cohortCCbl=cohortCCbl[cohortCCbl$studyName=='PPMI', ]
mycvt1 = mlr3classifiercv(
       cohortCCbl,
       tcols = c("DXbio", 'sex', idpst1 ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
#       subjectIDs = cohortCCbl$subjectID,
       verbose = FALSE
     )
aggt1 = aggregate( bacc ~ mdl, mycvt1, mean )
aggt1
myadj = c(idpst1 , idpsdt )
cohortCCbldt[,myadj] = antsrimpute( cohortCCbldt[,myadj])
mycvdt = mlr3classifiercv(
       cohortCCbldt,
       tcols = c("DXbio", 'sex','age_BL', myadj ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCbldt$subjectID,
       verbose = FALSE
     )
aggdt = aggregate( bacc ~ mdl, mycvdt, mean )
myadj = c(idpst1,idpsdt,idpsrsfmri)
cohortCCblrsf[,myadj] = antsrimpute( cohortCCblrsf[,myadj])
mycvrs = mlr3classifiercv(
       cohortCCblrsf,
       tcols = c("DXbio",'sex','age_BL', myadj  ),
       nrepeats = nrep,
       partrate = srate,
       dup_size = mysamp,
       balancing = mybal,
       mylearners = mycx,
       subjectIDs = cohortCCblrsf$subjectID,
       verbose = FALSE
     )
aggrs = aggregate( bacc ~ mdl, mycvrs, mean )
print( aggbs )
print( aggt1 )
print( aggdt )
print( aggrs )
#########################
dxs=gsub("Prodromal","AR",dxs)
dxs=gsub("Positive","+",dxs)
dxs=gsub("Negative","-",dxs)
g1t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 alone:", dxs[1], "vs",  dxs[2])))
g2t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none') + ggtitle(paste("Raw Acc. T1 alone:", dxs[1], "vs",  dxs[2])))
# g1=( ggstatsplot::ggbetweenstats( mycv, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
# g2=( ggstatsplot::ggbetweenstats( mycv, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))

bbase=( ggstatsplot::ggbetweenstats( mycvbs, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. Age + Sex:", dxs[1], "vs",  dxs[2])))
t1=( ggstatsplot::ggbetweenstats( mycvt1, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 :", dxs[1], "vs",  dxs[2])))
t1b=( ggstatsplot::ggbetweenstats( mycvt1, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 :", dxs[1], "vs",  dxs[2])))
dt=( ggstatsplot::ggbetweenstats( mycvdt, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
dtb=( ggstatsplot::ggbetweenstats( mycvdt, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI:", dxs[1], "vs",  dxs[2])))
rs=( ggstatsplot::ggbetweenstats( mycvrs, mdl, acc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Raw Acc. T1 + DTI + rsf:", dxs[1], "vs",  dxs[2])))
rsb=( ggstatsplot::ggbetweenstats( mycvrs, mdl, bacc, p.adjust.method = 'holm', pairwise.display ='none' ) + ggtitle(paste("Bal. Acc. T1 + DTI + rsf:", dxs[1], "vs",  dxs[2])))

# mygg = grid.arrange( grobs=list(g1t1,g1,g2t1,g2), nrow=4, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
mygg1 = grid.arrange( grobs=list(t1,dt,rs), nrow=3, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
mygg2 = grid.arrange( grobs=list(t1b,dtb,rsb), nrow=3, top=paste('DTI + T1 features outperform T1 features alone in discriminating SAA confirmed', dxs[1], "vs",  dxs[2]))
print( mygg1 )
print( mygg2 )

```


```{r interpretit,echo=FALSE,eval=FALSE,fig.width=9,fig.height=5}
library(ggpubr)
library(randomForestSRC)
datcol=c(idpst1, idpsdt, idpsrsfmri)
datcol=c(idpst1 )
datcols=shorten_pymm_names(datcol )
myx=cohortCCbl
colnames(myx)[  colnames(myx) %in% datcol ] = datcols
myx=myx[,c("study",'age_BL','commonSex', 'imaging_protocol', datcols )]
myx$commonSex=factor(myx$commonSex)

rfobj <- rfsrc(study ~ ., data = myx,forest=TRUE)
myvimp = vimp(rfobj)
newimp = data.frame( feature=names(myvimp$importance), importance=as.numeric(myvimp$importance ))
newimp = newimp[ order(newimp$importance,decreasing=T),]
newimp$type=substr(newimp$feature,0,3)
newimp$type=gsub("_","",newimp$type)
print( ggbarplot( head(newimp,20), 'feature','importance', fill='type', palette='npg' ) + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Feature importance ",paste(dxs,collapse=' vs '))) ) 

if ( FALSE  ) {
  tsk = as_task_classif( x = cohortCCbl[ , c("DXbio", datcols )], target='DXbio',  id='pd' )
  lrn_gbm = lrn("classif.imbalanced_rfsrc", predict_type = "prob")
  split = partition(tsk)
  lrn_gbm$train( tsk, row_ids = split$train )
  predictor = Predictor$new(lrn_gbm, data = cohortCCbl[,datcols], y = cohortCCbl[,'DXbio'])
  importance = FeatureImp$new(predictor, loss = "ce", n.repetitions = 10 )
  importance$resultsfull = importance$results
  importance$results = importance$results[1:25,] 
  importance$plot()
  # newimp = data.frame( importance$results[1:25,]  )
  # print( ggbarplot( newimp, 'feature','importance',  palette='npg', ylim=c(1,1.2) ) + 
  #  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Feature importance ",paste(dxs,collapse=' vs '))) + geom_errorbar(aes(ymin=importance.05, ymax=importance.95), width=.1,
  #                    position=position_dodge(.5))  ) 
}
```


```{r interpretit2,eval=FALSE,echo=FALSE,fig.width=10,fig.height=6,message=FALSE,warning=FALSE}
library(ggpubr)
library(randomForestSRC)
datcol=c(idpst1, idpsdt, idpsrsfmri)
datcol=c(idpst1 )
datcols=shorten_pymm_names(datcol )
datcols=gsub("_adjusted","",datcols)
datcols=gsub("_adjuste","",datcols)
datcols=gsub("_adjust","",datcols)
datcols=gsub("_adjus","",datcols)
datcols=gsub("_adju","",datcols)
datcols=gsub("_adj","",datcols)
datcols=gsub("_ad","",datcols)
outcome='DXbio'
outcome='study'
myx=cohortCCbl
myx$study=0
myx$study[myx$studyName=='ADNI']=1
colnames(myx)[  colnames(myx) %in% datcol ] = datcols
opreds = c('age_BL','commonSex', datcol )
myx=myx[,c(outcome,'age_BL','commonSex',  datcols )]
myx$commonSex=factor(myx$commonSex)
# rfobj <- rfsrc(DXbio ~ ., data = myxtr)
# rfobj <- rfsrc.fast(DXbio ~ ., data = myxtr)
mypartition = dataPartition( myx$age_BL, 0.8  )
myx[,outcome] = factor( myx[,outcome])
# myrf=rfsrc( DXbio ~ ., data=myx[mypartition$train,], importance=T, forest=TRUE  )
myrf=imbalanced( study ~ ., data=myx[mypartition$train,], importance=T)#, ntree = 5000  )
###### from getting started guide
# oo <- subsample(myrf, verbose = FALSE)
###### take a delete-d-jackknife procedure for example
# vimpCI <- extract.subsample(oo)$var.jk.sel.Z
###### Confidence Intervals for VIMP
# plot.subsample(oo)
# take the variable "Month" for example for partial plot
# plot.variable(myrf, xvar.names = "Month", partial = TRUE)
###########################################################
vv = myrf$importance[,1]
nms=names(vv)
myimp = data.frame( 
    nms=names(vv),
    imp=vv)
myimp$type = 'cit'
myimp$type[1:2]='demog'
myimp$type[ grep("deep",opreds)]='deep'
myimp$type[ grep("brainstem",opreds)]='brainstem'
myimp$type[ grep("bf",opreds)]='nbm'
myimp$type[ grep("cerebell",opreds)]='cerebellum'
myimp$type[ grep("cortex",opreds)]='cortex'
myimp$type[ grep("mtl",opreds)]='mtl'
rownames(myimp)=NULL
library(ggpubr)
myimp = myimp[ order( myimp$imp, decreasing=TRUE),]
ggbarplot(head(myimp,14), x = "nms", y = "imp",
          fill = "type",               # change fill color by cyl
          color = "white",            # Set bar border colors to white
          palette = "jco",            # jco journal color palett. see ?ggpar
          sort.val = "desc",          # Sort the value in dscending order
          sort.by.groups = FALSE,     # Don't sort inside each group
          x.text.angle = 90           # Rotate vertically x axis texts
          )
get.imbalanced.performance( myrf, confusion=T )
##################################
qq = predict( myrf, newdata=myx[mypartition$test,], type='probabilities' )
##################################
```

```{r interpretit2auc,eval=FALSE,echo=FALSE,fig.width=10,fig.height=6,message=FALSE,warning=FALSE,results='asis'}
## ggplot it
library(pROC)
# Create the ROC object
predictions = as.numeric(qq$class)
predictions = qq$predicted[,2]
roc_obj <- roc(myx[mypartition$test,'DXbio'], predictions )

# Plot the ROC curve with smoothing
plot(roc_obj, print.auc=TRUE, auc.polygon=TRUE, max.auc.polygon=TRUE, grid=TRUE, smooth=TRUE)
# plot(roc_obj, main="Smoothed ROC Curve", col="#1c61b6", print.auc=TRUE)
lines(smooth(roc_obj), col="#ff0000")  # Add smoothed ROC curve

if ( FALSE ) {
  library(evalmod)
  library(ggplot2)
  library(precrec)
  sscurves <- evalmod(scores = predictions, 
      labels = myx[mypartition$test,'DXbio'], x_bins=10000 )
  aucs <- auc(sscurves)
  autoplot( sscurves, show_cb = F )
  # Use knitr::kable to display the result in a table format
  knitr::kable(aucs,"latex", booktabs = TRUE) %>%
    kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
}
```

## Sensitivity to differences from controls

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  MRI is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. Here, we assess longitudinal and cross-sectional effect sizes in T1w, DTI and rsfMRI IDPs that are pre-defined for PD relevance.

Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), dMRI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

The tabulated multi-modality MRI dataset derived from deeply validated open source methods represents a significant leap forward in PD M3MRI research. It simplifies the analysis of complex imaging data, potentially accelerating the discovery of novel insights into PD's progression and effects. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.

basal forebrain [in LRRK2](https://www.sciencedirect.com/science/article/pii/S0969996123001973)


In the current investigation, we sought to elucidate the complex relationships between neuroimaging biomarkers and the progression of Parkinson's Disease (PD) through the employment of linear mixed-effects models (LMMs). The analytical framework was constructed using the R programming environment, leveraging particularly the capabilities of the `lme4` package to fit LMMs. This methodology allows for the nuanced exploration of hierarchical data structures commonly encountered in longitudinal neuroimaging studies, where multiple observations per subject are standard.


Our approach commenced with the initialization of the variables of interest (VOIs), encompassing baseline measurements ("_BL") and their temporal changes ("_delta"), to capture both static and dynamic aspects of the neuroimaging markers. Subsequent model formulations (`bform`) were iteratively developed to explore a variety of predictive variables and their interactions. These models were designed to investigate the predictive power of baseline characteristics, imaging protocol variances (notably LRRK2_MRIPROTOCOL), and specific neuroimaging features (e.g., DTI_dti_tsnr_b0_mean, DTI_dti_ssnr_b0_mean) on the progression indicators of PD.


The analytical strategy incorporated flexibility to adjust predictor variables based on the specific type of neuroimaging data under consideration (e.g., rsfMRI or DTI), thereby tailoring the model to the nuanced differences inherent to each imaging modality. This was achieved through dynamic modification of the `othdxform` variable, ensuring the inclusion of motion-related predictors where pertinent, reflecting our commitment to methodological rigor and the pursuit of accurate, context-sensitive insights.


Employing the `lmer` function, linear mixed-effects models were constructed and fitted to the data. This process included the standardization of variables within the equation, a critical step given the varying scales and distributions of neuroimaging metrics. Post model construction, we engaged in a predictive accuracy refinement process through the re-scaling of variables and recalibration of the model based on a curated subset of the data, thereby enhancing the robustness of our findings.

Comparative model analysis was conducted to ascertain the significance of various predictors, employing the `anova` function to contrast models with and without specific variables. This methodological step was crucial for discerning the impact of individual predictors on disease progression, thereby offering insights into the potential mechanisms underlying PD pathophysiology.


In summary, our study employs advanced statistical modeling techniques to investigate the relationship between neuroimaging biomarkers and Parkinson's Disease progression. Through the careful construction and refinement of linear mixed-effects models, we aim to uncover significant predictors of disease trajectory, contributing valuable knowledge to the field of neurodegenerative disease research. This analytical endeavor not only highlights the complexity of PD but also underscores the potential of sophisticated statistical methods to unravel it.


```{r pkgs,echo=FALSE,eval=TRUE,message=FALSE,cache=TRUE}
set.seed( 0 )
library(plyr)
library(ggplot2)
library( GoodmanKruskal )
library(forcats)
library(heatmap3)
library(permute)
library(interactions)
library(reghelper)
library(MGMM) # GMM methods (FIXME)
library(WeightedCluster) # cluster quality (FIXME)
library(tidyverse)
library(clValid)
library( cluster.datasets )
library(magrittr)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ggfortify)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="latex" )
tblcmd = ztable
```

```{r functions,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,cache=FALSE}

normalizersfmri = function( dd, applyit='mean' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,cache=FALSE}
if ( ! exists( "is_test" ) ) is_test = TRUE
```

## Diagnostic effects in pre-defined structural, white matter and resting functional measurements

```{r quicklmdxsetup,echo=FALSE,eval=buildsci,fig.width=9,fig.height=6,warning=FALSE,message=FALSE}
######################################################################
num=c(122,129,134)[1] # resting state protocol numbers ###############
######################################################################
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|commonID)+ (1|imaging_protocol) + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|commonID) + (1|imaging_protocol) + age_BL + commonSex "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_mean + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
dxsel2 = ppmi$DXSubAsyn %in% c(
  negate, posate, ispd )
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
# mylevsx1=c( "CN", "ProdromalSporadic", "PDSporadic", "MCI", "AD" )
# keep the "best" ntokeep examples
# mydog = ppmi[ head( order(ppmi$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
mydog = ppmi[ ppmi$T1Hier_resnetGrade > 1.02 ,  ]
ysel = mydog$yearsbl <= 4.5 
mydog = mydog[ mydog$studyName %in% c('PPMI') & ysel &
# mydog = mydog[ mydog$studyName %in% c('PPMI','ADNI') & ysel &
#  ppmi$DXSubAsyn %in%  mylevsx0[c(1,2,3)]&  
#  ppmi$joinedDX %in%  mylevsx1[c(1,2,3)] &  
#  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2" ) ) &
  subtyper::fs( mydog$joinedDX %in% c( "CN", "MCI", "PDGBA","PDLRRK2","PDSporadic" ) ),]
mydog = normalizersfmri( mydog )
mydog$joinedDX <- fct_relevel(mydog$joinedDX, "CN")
mydog$DXSubAsyn <- fct_relevel(mydog$DXSubAsyn, "CNNegative")
###############################################
mydog$TDX = NA #as.character( mydog$DXSubAsyn )
dolrrk2=FALSE
if ( dolrrk2 ) {
  mydog$TDX = mydog$DXSubAsyn
  mydog$TDX[ mydog$LRRK2_study == FALSE ] = NA
  mydx='PDLRRK2'
} else {
  mydog$TDX[ subtyper::fs(mydog$AsynStatus == 'Negative' & mydog$joinedDX == 'CN') ]='CN'
# mydog$TDX[ mydog$DXSubAsyn %in% ispd ]='otherPositive'
  mydog$TDX[ mydog$DXSubAsyn  == 'PDLRRK2Positive' ]='PDLRRK2+'
  mydog$TDX[ mydog$DXSubAsyn  == 'PDGBAPositive' ]='PDGBA+'
  mydx='PDLRRK2+'
  mydx='PDGBA+'
 # mydog$TDX[ mydog$DXSubAsyn  == 'PDSporadicNegative' ]='DXPD-'
  mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDSporadicPositive') ]='PDSp+'
  mydx='PDSp+'
}
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_n_outliers < 100 ) &
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5 )
mydog = antspymm_predictors(mydog, TRUE )
idps = antspymm_predictors(mydog, TRUE, TRUE )
subjectcount = table( mydog$commonID )
# mysubs = names(  subjectcount > 1 )
# mydog = mydog[ mydog$commonID %in% mysubs , ]
xcl = antspymm_nuisance_names()
rsfnames = c( 
  getNamesFromDataframe( c("rsf","LRAVG",num,'_falff'), mydog, exclusions=xcl ),
  getNamesFromDataframe( c("rsf","Asym",num,'_falff'), mydog, exclusions=xcl ) )
rsfnamescnx = c( 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","efaul"),  ppmi, exclusions=xcl ), 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","imbi"),  ppmi, exclusions=xcl ),   
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","efaul","imbi"),  ppmi, exclusions=xcl )
  )
rsfnamescnx = getNamesFromDataframe( c("pro122", "_2_" , "SomMot" ), ppmi, exclusions=c(xcl,'efaul','Dors','SalVe','imbi')  )
rsfnamescnx = rsfnamescnx[ grep("rsfMRI_fcnxpro122_SomMot", rsfnamescnx) ]
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','Limbic'),  ppmi, exclusions=xcl ),
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','SalVent'),  ppmi, exclusions=xcl ) )
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
# idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'joinedDX'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
mydog = mydog[ !is.na( mydog[,dxvar]), ]
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), mydog ),
  getNamesFromDataframe( c("DTI","Asym"), mydog ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),mydog, exclusions=c("left","right")), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),mydog, exclusions=c("left","right")) )
######################################
# print( table( mydog[,dxvar]))
mydog = fillBaselineColumn( mydog,
        c( idpst1, rsfnamescnx, rsfnames, dtinamesasymlr, 'hy', 'brainVolume' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX == 'CN' ]=0
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX != 'CN' ]=2
mydog$hy_BL = factor( mydog$hy_BL )
######################################
motname = paste( 
      paste0( "rsfMRI_fcnxpro",num,"_n_outliers"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_mean") )
motnamedt = "DTI_dti_FD_mean"
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
#  nmstotest = idpst1[ multigrep( c("dktcortex","thk"),idpst1,intersect=T)]
#  nmstotest = sample( nmstotest, 4 )
  mycorr='none'
}
# decide on some really good regions to test/show
ctx = c( "T1Hier_vol_Asym_superior_parietaldktcortex", "T1Hier_vol_Asym_inferior_parietaldktcortex", 
getNamesFromDataframe( c("vol","Asym", "dktcortex","entral"),mydog)
 ) # need ref
snc = c( "T1Hier_vol_mtg_sn_snc_Asymdeep_cit168",   
  "T1Hier_vol_bn_str_pu_Asymdeep_cit168", 
#  "T1Hier_vol_bn_str_ca_Asymdeep_cit168", 
#  "T1Hier_vol_bn_gp_gpi_Asymdeep_cit168", 
#  "T1Hier_vol_bn_gp_gpe_Asymdeep_cit168", 
  'T1Hier_midbrain_pons_ratio',
  getNamesFromDataframe( c("vol","Asym", "nbm"),mydog),
  getNamesFromDataframe( c("vol","Asym", "mtl",'ca3'),mydog) )

dtivars = c( "superior_longitudinal_fasciculus", "_snc", 
  "superior_corona_radiata", "fornix", "_capsule", 
#  "parahippocampal", 
  "str_pu")
nmstotest = c( ctx, snc )
nmstotest = unique( c( 
  nmstotest, 
  gsub("Asym","LRAVG",nmstotest), 
  dtinamesasymlr[ multigrep( dtivars, dtinamesasymlr )],
  rsfnamescnx ) )
```

### Table of pre-defined regions tested

see [agostas paper](https://www.sciencedirect.com/science/article/pii/S2213158220302114) for support for atrophy and progression

[fmri connex](https://link.springer.com/article/10.1007/s00234-021-02731-w)

* add references to table for each predefined region

* add long names to predefined regions

```{r predefregions,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
idpids = nmstotest[ multigrep( c("LRAVG",'ratio',"rsfM"),nmstotest)]
myregions = data.frame( IDP=shorten_pymm_names(idpids))
myregions$modality[ grep("rsf", myregions$IDP)]='rsfMRI'
myregions$modality[ grep("dti", myregions$IDP)]='DTI'
myregions$modality[ grep("t1", myregions$IDP)]='T1w'
myregions2=myregions
rownames(myregions2)=NULL
myregions2$IDP=gsub('_','.',myregions$IDP)
myregions2T1 = myregions2[ myregions2$modality == 'T1w', ]
rownames(myregions2T1)=NULL
myregions2DTI = myregions2[ myregions2$modality == 'DTI', ]
rownames(myregions2DTI)=NULL
myregions2RSF = myregions2[ myregions2$modality == 'rsfMRI', ]
rownames(myregions2RSF)=NULL
myregions2T1$anat= c(
  "Superior Parietal Cortex",
  "Inferior Parietal Cortex",
  "Paracentral Cortex",
  "Postcentral Cortex",
  "Precentral Cortex",
  "Substantia Nigra Compacta",
  "Basal Nucleus Striatum, Putamen",
  "Nucleus Basalis Meynert, Anterior Basal Forebrain",
  "Nucleus Basalis Meynert, Middle Basal Forebrain",
  "Nucleus Basalis Meynert, Posterior Basal Forebrain",
  "Dentate Gyrus, CA3 Region of Medial Temporal Lobe",
  "Midbrain Pons ratio"
#  "Medulla Brainstem",
#  "Pons Brainstem"
)
myregions2RSF$connectivity <- c(
  "Temporal Parietal Region",
  "Control Network Component C",
  "Control Network Component B",
  "Control Network Component A",
  "Somatomotor Area B",
  "Somatomotor Area A",
  "Peripheral Visual Area",
  "Central Visual Area",
  "Temporal Parietal Region",
  "Control Network Component C",
  "Control Network Component B",
  "Control Network Component A",
  "Somatomotor Area B",
  "Somatomotor Area A",
  "Peripheral Visual Area",
  "Central Visual Area"
)
myregions2DTI$anat =  c(
  "Superior Longitudinal Fasciculus FA",
  "Superior Longitudinal Fasciculus Mean MD",
  "Deep Substantia Nigra Compacta FA",
  "Substantia Nigra Compacta FA",
  "Deep Substantia Nigra Compacta Mean MD",
  "Substantia Nigra Compacta Mean MD",
  "Superior Coronal Radiata FA",
  "Superior Coronal Radiata Mean MD",
  "Fornix FA",
  "Fornix Mean MD",
  "Anterior Internal Capsule FA",
  "External Capsule FA",
  "Posterior Internal Capsule FA",
  "Retrolenticular Part of Internal Capsule FA",
  "Superior Frontal-Occipital Fasciculus FA",
  "Anterior Internal Capsule Mean MD",
  "External Capsule Mean MD",
  "Posterior Internal Capsule Mean MD",
  "Retrolenticular Part of Internal Capsule Mean MD",
  "Superior Frontal-Occipital Fasciculus Mean MD",
  "Deep Basal Nucleus Striatum, Putamen FA",
  "Basal Nucleus Striatum, Putamen FA",
  "Deep Basal Nucleus Striatum, Putamen Mean MD",
  "Basal Nucleus Striatum, Putamen Mean MD"
)


myregionszT1z=ztable(myregions2T1[,c('IDP','anat')])
myregionszRSFz=ztable(myregions2RSF[,c('IDP','connectivity')])
myregionszDTIz=ztable(myregions2DTI[grep("dti.fa",myregions2DTI$IDP,fixed=TRUE),c('IDP','anat')])
mycap='PD IDPs in ANTsPyMM: T1w L/R average and asym'
print(myregionszT1z, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
mycap='PD IDPs in ANTsPyMM: DTI L/R average and asym for both fractional anisotropy (FA) and mean diffusion (MD) (not shown)'
print(myregionszDTIz, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
mycap='PD IDPs in ANTsPyMM: rsfMRI bilateral inter or intra-network connectivity  (Yan, et. al. homotopic parcellation nomenclature)'
print(myregionszRSFz, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
# myregions %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```

```{r quicklmdx,echo=FALSE,eval=buildsci,fig.width=9,fig.height=4.5,warning=FALSE,message=FALSE}
dxdfT1=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdfT1)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( vois[2], " ~ hy_BL + ", vois[1], "+", dxform )
  bform = paste( vois[2], " ~ 1 + ", vois[1], "+", dxform )
  bform = paste( voi, " ~ T1Hier_resnetGrade + LRRK2_MRIPROTOCOL + ", dxform )
  bform = paste( voi, " ~ (LRRK2_MRIPROTOCOL) + ", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ LRRK2_MRIPROTOCOL+DTI_dti_tsnr_b0_mean + DTI_dti_tsnr_dwi_mean+", dxform )
  bform = paste( voi, " ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+ spc0 +spc1+", dxform )
  bform = paste( voi, " ~ 1 + T1Hier_resnetGrade+spc0+spc2+", dxform )
  bform = paste( vois[2], " ~ " , vois[1], "+brainVolume_BL + T1Hier_resnetGrade+duration_yrs+", dxform )
  othdxform=dxform
  if ( antspymm_vartype(voi) == "rsfMRI" ) othdxform=paste0(motname,"+",dxform)
  if ( antspymm_vartype(voi) == "DTI" ) othdxform=paste0(motnamedt,"+",dxform)
  bform = paste( voi, " ~ brainVolume_BL+duration_yrs+ T1Hier_resnetGrade+", othdxform )
  newform = paste( bform, " * ", dxvar  )
  temp2 = mydog[ !is.na( mydog[,voi]) & mydog$age_BL < 70005 & 
    mydog$studyName %in% c('PPMI','ADNI'), ]
  temp2$duration_yrs[ is.na( temp2$duration_yrs ) ] = 0
#  for ( x in  all.vars( as.formula(newform)) ) { 
#    print(x) ; print(table( is.na( temp2$duration_yrs ), temp2$studyName )) }
  temp2 = scale_variables_in_equation( temp2, newform )
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scale_variables_in_equation( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdfT1[n,'voi']=voi
  dxdfT1[n,'n.base']=length(unique(temp3$commonID))
#  dxdfT1[n,'n.long']=poptbl[2]
  dxdfT1[n,'anv']=anvp
  othercols = rownames(mycoffs)
  othercols=c( "yearsbl" , othercols[grep("TDX",othercols)] )
  othercolsnm=gsub("TDX","",othercols)
  othercolsnm=gsub(":",".",othercolsnm)
  ndf = length(unique(temp3$commonID))
  chnd = effectsize::t_to_d( mycoffs[ othercols, 't value'], rep(ndf,length(othercols))  )
  dxdfT1[n,paste0("d.",othercolsnm)]=chnd[,1]
#  dxdfT1[,paste0("p.",othercolsnm)]=mycoffs[ othercols, 5]
  dxdfT1[n,'res']=myrez
  dxdfT1[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( gsub("_",".",shorten_pymm_names(voi)) %in% c("t1.vol.mtg.sn.sncdeep.cit168","dti.mean.md.sup.longitudinal.fasciculus.","dti.fa.sup.corona.radiata.asym","t1.vol.nbm.antbf","rsf.defaulta.2.visperi") | anvp < 1e-6 ) {
#    print( mycoffs )
#    print( dxdfT1[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( shorten_pymm_names(voi), "omnibus : ", anvp ) )
    print( interactions::interact_plot( mdl, 'yearsbl',  'TDX', main.title=ttl, interval=TRUE, plot.points =FALSE, facet.modx=TRUE, int.type = c("confidence", "prediction")[1], partial.residuals=F,y.label ='') )
#    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
##########################################################
```

### Table of significant diagnostic group effects

```{r dxresults,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
if ( sum( psel ) == 0  ) psel = rep(TRUE,nrow(dxdfT1))
dxdfT1sel = dxdfT1[psel,]
dxdfT1sel$voi = shorten_pymm_names( dxdfT1sel$voi )
dxdfT1sel = dxdfT1sel[ order( dxdfT1sel$anv ), ]
dxdfT1sel$anv = insight::format_p(  dxdfT1sel$anv, digits=4  )
dxdfT1selcols = colnames(dxdfT1sel)[1:10]

# Print the ztable object, ensuring it's treated as LaTeX code
dxdfT1selz=dxdfT1sel[, dxdfT1selcols]
colnames(dxdfT1selz)=gsub("yearsbl","y",colnames(dxdfT1selz))
colnames(dxdfT1selz)=gsub("PD","",colnames(dxdfT1selz))
dxdfT1selz$voi=gsub("_",".",dxdfT1selz$voi,fixed=TRUE)
dxdfT1selz=ztable(dxdfT1selz)
mycap='Significant (fwe) longitudinal diagnostic group effects in PD+: T1w, DTI and rsfMRI.'
print(dxdfT1selz, type = "latex",size=2,caption=mycap,sidewaystable=TRUE)

# dxdfT1sel[, dxdfT1selcols] %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```



## Baseline IDP to longitudinal UPDRS effects in pre-defined structural, white matter and resting functional measurements

In our investigation into the determinants of cognitive decline within Parkinson's Disease (PD) cohorts, we employed a refined statistical methodology utilizing linear mixed-effects models to analyze neuroimaging data. This analytical approach, crafted within the R programming environment, was specifically tailored to accommodate the complexities of longitudinal neuroimaging datasets.

### Methodological Overview

The preprocessing phase involved adjusting the dataset to reflect baseline neuroimaging measurements, a critical step for the longitudinal analysis. We dynamically adapted our models based on the neuroimaging modality—T1-weighted images, resting-state fMRI (rsfMRI), or Diffusion Tensor Imaging (DTI)—incorporating modality-specific motion metrics and setting appropriate thresholds for data inclusion to mitigate the effects of data variability.

### Cognitive Function Model Construction

Our models were meticulously formulated to explore cognitive function changes over time, integrating a broad spectrum of predictors including patient-specific random effects, motion metrics, biomarker statuses, diagnostic categories, and demographic variables. This multi-dimensional approach allowed for a comprehensive examination of cognitive trajectories in PD.

### Data Refinement

The dataset underwent a rigorous refinement process, including the application of Winsorization to control for outliers, thereby enhancing the integrity of our analysis. The inclusion criteria were stringently applied, focusing on participants with a confirmed diagnosis and within a specified follow-up duration to ensure data relevance and reliability.

### Analytical Execution

Subsequent to the variable standardization process, we fitted our models using the `lmer` function. Through comparative model analysis via ANOVA, we assessed the significance of model predictors and their interactions. This step was fundamental in elucidating the intricate relationships between neuroimaging biomarkers and cognitive outcomes in PD.

### Conclusion

Our investigation represents a sophisticated application of statistical models to understand cognitive decline in Parkinson's Disease. By integrating comprehensive predictor variables and applying rigorous data refinement techniques, we offer insightful contributions to the neurodegenerative disease research domain, highlighting the utility of tailored statistical analyses in uncovering the nuanced dynamics of PD progression.


```{r quicklmcog,echo=FALSE,eval=buildsci,fig.width=12,fig.height=4,warning=FALSE,message=FALSE}
#########################################################
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
cogs = getNamesFromDataframe( c("updrs","score"), mydog, exclusions=c(4,'_BL',"_delta","tot") )
# cogs = getNamesFromDataframe( c("updrs","score","tot"), mydog, exclusions=c(4,'_BL',"_delta") )[1]
col2sbl = unique(c( idpst1, dtinamesasymlr, rsfnames, rsfnamescnx,  fdnames, cogs, nmstotest ))
mydogp = fillBaselineColumn( mydog,
        col2sbl,
        'subjectID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydogp$hy_BL = factor( mydogp$hy_BL )
stadfrsf=data.frame()
for ( cog in  cogs  ) {
  for ( voi in nmstotest ) {
    n = nrow(stadfrsf)+1
    voi = paste0(voi,"_BL")
    maxy=5.0
    if ( antspymm_vartype( voi ) == "T1" ) motname=""
    if ( antspymm_vartype( voi ) == "rsfMRI" )  {
      motname = paste( paste0( "rsfMRI_fcnxpro",num,"_n_outliers_BL"), " + ",
        paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL"))
      motname = paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL")
      maxy=2.5
      }
    if ( antspymm_vartype( voi ) == "DTI" )  {
      motname = "DTI_dti_FD_mean_BL"
      maxy=3.0
    }
    cogformcommon=paste( cog, "  ~ (1|PATNO) + ",motname," + AsynStatus + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + brainVolume_BL + ", motname, " + age_BL + commonSex + AsynStatus + yearsbl" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|imaging_protocol)+ (1|commonID) + T1Hier_resnetGrade  + duration_yrs + ",motname," + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )*TDX + ( yearsbl )" )
#    cogformcommon=paste( cog  , "~  (1|PATNO) + commonSex + brainVolume_BL + ( yearsbl )")
    temp2 = mydogp[ !is.na( mydogp[,voi]) & mydogp$TDX != "CN" & mydogp$yearsbl <= maxy, ]
#    temp2 = mydogp[ !is.na( mydogp[,voi]) & mydogp$TDX == "PDSp+" & mydogp$yearsbl <= maxy, ]
    temp2[,voi]=psych::winsor( temp2[,voi], 0.005)
    temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
    voix = shorten_pymm_names( voi )
    voix = gsub("_fcnxpro129", "",voix)
    voix = gsub("_fcnxpro122", "",voix)
    voix = gsub("_fcnxpro134", "",voix)
    temp2[,voix]=temp2[,voi]
    newform = paste(  cogformcommon, " * TDX * ", voix )
    newform = paste(  cogformcommon, " * ", voix )
    if ( nrow(temp2) > 100 ) {    
    temp2 = scale_variables_in_equation( temp2, newform )
    bmdl=suppressMessages(lmer( cogformcommon, data=temp2 ))
    mdl=suppressMessages(lmer( newform, data=temp2 ))
    mycoffs = coefficients( summary( mdl ) )
    anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
    othercols=c(voix,paste0("yearsbl:",voix))
    ndf = length(unique(temp2$commonID))
    chnd = effectsize::t_to_d( mycoffs[ othercols, 't value'], c(ndf,ndf) )
#    if ( max( abs( chnd[,1] ) ) > 2 ) derka
    stadfrsf[n,'cog']=cog
    stadfrsf[n,'voi']=voix
    poptbl = table( table( temp2$commonID ) )
    stadfrsf[n,'n.base']=ndf
#    stadfrsf[n,'n.long']=poptbl[2]
    stadfrsf[n,'anv']=anvp
    othercolsnm=c("d.b","d.y")
    stadfrsf[n,othercolsnm]=chnd[,1]
    stadfrsf[n,'res']=myrez
    stadfrsf[n,'singular']=isSingular(mdl)
    pairstovisB = c(
      "t1.vol.bn.str.pu.asym.bl", # updrs1 
      # "t1.vol.inf.parietal.ctx.bl",  # updrs1 
      "dti.mean.md.ant.int.cap.asym.bl",# updrs2 
      "rsf.sommotb.2.visperi.bl", # updrs3on 
       "t1.vol.dg.ca3mtl.bl", #
      "t1.vol.snc.bl" # # updrs3
      )
    pairstovisC = c(
      "updrs1_score", # updrs1 
      # "updrs1_score",  # updrs1 
      "updrs2_score",# updrs2 
      "updrs3_score_on", # updrs3on 
      "updrs2_score", # updrs2_score
      "updrs3_score" #  updrs3
      )
    ptv = paste0(pairstovisB,"_",pairstovisC)
#     if (  anvp < 3e-4 ) {
    if (  paste0(voix,"_",cog) %in% ptv  ) {
      cogdel = paste0(cog,"_delta")
  #    print( mycoffs[ , -c(1:3)] )
  #    print( voi )
      anvp = insight::format_p( anvp, digits=4 )
      anvp1 = insight::format_p( mycoffs[voix,'Pr(>|t|)'], digits=4 )
      anvp2 = insight::format_p( mycoffs[paste0("yearsbl:",voix),'Pr(>|t|)'], digits=4 )
      ttl=( paste(  voix, myrez, " + ", cog,  " : o", anvp ) )
      ttl1=( paste(  voix, myrez, " + ", cog,  " : m ", anvp1 ) )
      ttl2=( paste(  voix, myrez, " + ", cog,  " : y ", anvp2 ) )
      ttl3=c(voix,'higher strat.','lower strat.')
      temp2$TDX=as.character( temp2$TDX )
      temp2$TDX[ temp2$TDX == 'PDGBA+']='GB+'
      temp2$TDX[ temp2$TDX == 'PDLRRK2+']='LR+'
      temp2$TDX[ temp2$TDX == 'PDSp+']='sp+'
      gg1=( jtools::effect_plot( mdl, 
        !!sym(voix), # mod2='TDX',  
        main.title=ttl1, interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F  ) + theme(legend.position = "top")  )
      gg2=( interactions::interact_plot( mdl, 
        'yearsbl', # mod2='TDX',  
        main.title=ttl2, interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F,modx=!!sym(voix)  ) + theme(legend.position = "top")  )
      grid.arrange( grobs=list(gg2), nrow=1, top=ttl)
#      suppressMessages( threewayinteraction(  temp2, 'yearsbl', cogdel, 'TDX', voix, anatshow=ttl3 ) )
#      print( threewayinteraction( temp2, 'yearsbl', 'TDX', anat=voi ) )
 #     mygg = visreg::visreg( mdl, 'yearsbl', by=voi, gg=T )
 #     threewayinteraction( temp2, 'yearsbl', cog,  'AsynStatus', voi, showpoints=F )
#      print(prplot( mdl,  voi, 'yearsbl',ttl, colorvar='commonSex', addpoints=1))
#      gg0=(prplot( mdl, 'yearsbl', voi, '', ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      gg1=(prplot( mdl, voi, 'yearsbl', '', ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      grid.arrange( grobs=list(gg0,gg1),nrow=2, top=ttl)
#      visreg::visreg( mdl, 'yearsbl', by=voi, main=ttl  )

#    print( interactions::interact_plot( mdl, 'yearsbl', voi, main.title=ttl, interval=TRUE, plot.points =FALSE, facet.modx=TRUE, int.type = c("confidence", "prediction")[1], partial.residuals=F,y.label ='') )

    }
  } }
}
#####################
sigth=0.05
# for ( cog in cogs ) 
{
  mypvs = stadfrsf$anv
#  mypvs[ stadfrsf$cog != cog  ] = NA
  psel = subtyper::fs( p.adjust( mypvs, 'BY' ) <= sigth )
  psel2 = subtyper::fs( p.adjust( mypvs, 'BH' ) <= sigth )
  stadfrsf[psel2,'sig']='fdr'
  stadfrsf[psel,'sig']='fwe'
  if ( sum(psel ) > 0 )
    temp=stadfrsf[psel,]
    qdfsig=temp
#    qdf = rbind( qdf, temp )
  }
qdfsig = qdfsig[ order( qdfsig$anv ), ]
qdfsig$voi = shorten_pymm_names( qdfsig$voi )
qdfsig$anv = insight::format_p(  qdfsig$anv, digits=4  )
qdfcols =  c("cog", "voi" , "anv" ,'sig',othercolsnm)
qdfcols =  c("cog", "voi" , 'n.base', "anv", othercolsnm)
qdfsig = qdfsig[,qdfcols]
qdfsig$voi=gsub("_",".",qdfsig$voi,fixed=TRUE)
qdfsig$cog=gsub("_",".",qdfsig$cog,fixed=TRUE)
qdfsig = qdfsig[!duplicated(qdfsig),]
###########################################################
###########################################################################
```


### Table of significant clinical-IDP group effects

```{r updrsresults,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}

# Print the ztable object, ensuring it's treated as LaTeX code
qdfsigz=ztable(qdfsig)
mycap='Significant (fwe) IDP-UPDRS longitudinal effects for PD+: T1w, DTI and rsfMRI'
print(qdfsigz, type = "latex",size=3,caption=mycap,sidewaystable=FALSE)

# knitr::kable(qdfsig, "latex", booktabs = TRUE, caption='Significant IDP-UPDRS longitudinal  effects: T1w, DTI and rsfMRI') %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```


### multi-view example

In our study, we aimed to dissect the influence of neuroimaging biomarkers on the progression of motor symptoms in Parkinson's Disease (PD), as measured by changes in the Unified Parkinson's Disease Rating Scale (UPDRS) Part I scores. This endeavor involved the construction and analysis of linear mixed-effects models to assess the longitudinal impact of specific neuroimaging features on motor symptomatology.


The analysis focused on three neuroimaging biomarkers indicative of structural and functional brain integrity: the volume of the substantia nigra derived from T1-weighted images, connectivity metrics from resting-state fMRI, and mean diffusivity measures from Diffusion Tensor Imaging (DTI) of the anterior limb of the internal capsule. Initial preprocessing steps included the normalization of variable names to facilitate easier manipulation and analysis.


We constructed two principal models: a base model and a multivariate (MV) model. The base model predicted UPDRS Part I score changes based on a single neuroimaging biomarker, adjusted for patient-specific effects, demographic variables, and disease characteristics. The MV model extended this approach by incorporating all three neuroimaging biomarkers simultaneously, allowing for the assessment of their combined effect on motor symptom progression. Both models included random effects to account for intra-site and intra-patient variability, as well as other covariates such as disease duration, baseline motor function, and demographic information.


The dataset was curated to include only participants with relevant neuroimaging data, non-control diagnoses, and a maximum follow-up duration, ensuring the focus on PD progression. Outlier effects were mitigated through Winsorization, and variables were scaled appropriately to ensure model validity.


The models were fitted using the `lmer` function, with coefficients and comparative analyses elucidated through ANOVA. The significance of individual and combined neuroimaging biomarkers on motor symptom progression was quantitatively assessed.


The effects of neuroimaging biomarkers on UPDRS Part I score changes were visualized through effect plots and interaction plots, generated for each biomarker individually and in combination over time. These visualizations facilitated a nuanced understanding of the biomarkers' impacts across the disease trajectory.


Our analysis underscores the complex interplay between neuroimaging biomarkers and the progression of motor symptoms in PD. By leveraging a sophisticated statistical framework and meticulous data preprocessing, we offer novel insights into the neurobiological underpinnings of PD symptomatology. This study exemplifies the potential of multimodal neuroimaging analyses to inform our understanding of PD progression, highlighting the importance of comprehensive statistical approaches in neurodegenerative disease research.

```{r multiview,echo=FALSE,fig.width=16,fig.height=8}
cog='updrs1_score'
maxy=2.5
vois = c("t1.vol.bn.str.pu.asym.bl","dti.mean.md.fornix.asym.bl","rsf.sommota.2.contc.bl")
vois = c("T1Hier_vol_bn_str_pu_Asymdeep_cit168_BL",
  "rsfMRI_fcnxpro122_SomMotA_2_ContC_BL",
  "DTI_mean_md.anterior_limb_of_internal_capsule.LRAVG.jhu_icbm_labels_1mm" )
vois = c("T1Hier_vol_bn_str_pu_Asymdeep_cit168_BL",
  "rsfMRI_fcnxpro122_SomMotA_2_ContC_BL",
  "DTI_mean_md.anterior_limb_of_internal_capsule.LRAVG.jhu_icbm_labels_1mm" )
  #  "DTI_mean_md.anterior_limb_of_internal_capsule.Asym.jhu_icbm_labels_1mm" )
voisx=vois
for ( x in 1:length(vois) ) {
  voisx[x]= shorten_pymm_names(voisx[x])
}
# voisx[2]=paste0(voisx[2],'.avg')
# voisx[3]=paste0(voisx[3],'.asym')
bform =paste( " updrs1_score_delta ~  updrs1_score_BL + (1|SITE)+ (1|commonID) + T1Hier_resnetGrade  + duration_yrs + DTI_dti_FD_mean_BL+ rsfMRI_fcnxpro122_FD_mean_BL  + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )*TDX + ( yearsbl )  *  ( ", voisx[1] , ")" )
mvform =paste( bform, " + ( yearsbl )  *  ( ", paste(voisx,collapse="+") , ")" )
temp2 = mydogp[ !is.na( mydogp[,vois[3]]) & !is.na( mydogp[,vois[2]]) & mydogp$TDX != "CN" & mydogp$yearsbl <= maxy, ]
for ( x in 1:length(vois) ) {
  temp2[,voisx[x]]=temp2[,vois[x]]
}
temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
temp2 = scale_variables_in_equation( temp2, mvform )
bmdl=suppressMessages(lmer( bform, data=temp2 ))
mdl=suppressMessages(lmer( mvform, data=temp2 ))
mycoffs = coefficients( summary( mdl ) )
mvanv = anova(bmdl,mdl)
gglist = list() 
gglist2 = list() 
for ( x in 1:length(vois) ) {
  gglist[[x]] = ( jtools::effect_plot( mdl, 
        !!sym(voisx[x]), # mod2='TDX',  
        # main.title=paste('mv base', voisx[x]), 
        interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F  ) + theme(legend.position = "top")  )
  gglist2[[x]] = interactions::interact_plot( mdl, 
        'yearsbl',
        modx=!!sym(voisx[x]),
        # main.title=paste('mv time', voisx[x]), 
        interval=TRUE, 
        plot.points = F, facet.modx=T, 
        int.type = c("confidence", "prediction")[1], 
        partial.residuals=F  ) + theme(legend.position = "top")
  }
grid.arrange( grobs=gglist, nrow=2, top='MV base 3 modality')
grid.arrange( grobs=gglist2, nrow=2, top='MV long 3 modality')

if ( FALSE ) {
  gglist=list()
  for ( x in 1:length(vois) ) {
    gglist[[length(gglist)+1]]=visreg::visreg(  mdl, 'yearsbl' , voisx[x], gg=TRUE)
  }
  vtoadd=all.vars(as.formula(mvform))[ -c(1) ]
  visglm( temp2, mdl, 'yearsbl', paste0(cog,"_delta"), group='all', 'hey', groupvar='TDX' , varstoadd=vtoadd, verbose=TRUE )
}

# 0.00039
```

# Usage Notes

An example of processing used here is shown in the github respository [https://github.com/stnava/ANTPD_antspymm](https://github.com/stnava/ANTPD_antspymm) where we combine easily accessible multi-view neuroimaging with our open source methods for demonstration purposes.  All images referred to in this research were processed in a style identical to this example.


# Code availability

ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM). The version used for this work is `1.2.7` along with tensorflow `2.11.0`, antspyx `0.4.2`, antspynet `0.2.3` and antspyt1w `0.9.1`.

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work.

# Author contributions statement

...

# Competing interests

...

# Figures & Tables

Figures, tables, and their legends, should be included in the appropriate section of the document. Figures and tables can be referenced using Markdown syntax.

Figure: Legend (350 words max). Example legend text.

| Condition | n  | p     |
|-----------|----|-------|
| A         | 5  | 0.1   |
| B         | 10 | 0.01  |
Table: Legend (350 words max). Example legend text.


