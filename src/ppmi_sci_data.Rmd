---
output: 
  pdf_document:
    keep_tex: true
    fig_caption: yes
    template: null
#    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmiscidata.bib
classoption: table
header-includes:
  - \usepackage{multirow}
  - \usepackage{rotating}
  - \usepackage{authblk}
  - \renewcommand\Affilfont{\small}
linenumbers: true
urlcolor: blue
# nocite: '@*'
link-citations: true
---



\begin{centering}

$ $

\vspace{0.1 cm}

\LARGE

{\bf Magnetic Resonance Imaging Data Phenotypes for the Parkinson's Progression Markers Initiative}

\vspace{1.0 cm}

\normalsize

Brian B Avants$^{1,2}$,
Leon Fonville$^{1}$,
Olivia Hampton$^{1}$,
Alexandra Reardon$^{1}$,
Andrew Stenger$^{1}$,
Xue Wang$^{1}$,
Nicholas J Tustison$^{2}$,
James R Stone$^{2}$,
Philip A Cook$^3$,
Barbara Marebwa$^4$,
Lana M Chahine$^5$,
Kathleen L Poston$^6$,
Kenneth Marek$^7$,
Lino Becerra$^{1}$,
Roger Gunn$^{1}$
for the Alzheimer's Disease Neuroimaging Initiative*


\vspace{0.25 cm}

\small

$^1$Invicro, Needham, MA, USA

$^2$Department of Radiology and Medical Imaging, University of Virginia, Charlottesville, VA, USA

$^3$Department of Radiology, University of Pennsylvania, Philadelphia, PA

$^4$Parkinson's Research, The Michael J. Fox Foundation,  New York City, New York, USA

$^5$Department of Neurology, University of Pittsburgh, Pittsburgh, PA, USA

$^6$Department of Neurology, Stanford University, Palo Alto, CA, USA

$^7$Institute for Neurodegenerative Disorders, New Haven, CT, USA


\end{centering}

\vspace{2.2 cm}

\small

Corresponding author: \
Brian B. Avants \
avants@grasp.cis.upenn.edu

\noindent\rule{4cm}{0.4pt}

\footnotesize

*Data used in preparation of this article were obtained from the Alzheimerâ€™s Disease Neuroimaging Initiative (ADNI) database (adni.loni.usc.edu). As such, the investigators within the ADNI contributed to the design and implementation of ADNI and/or provided data but did not participate in analysis or writing of this report. A complete listing of ADNI investigators can be found at: http://adni.loni.usc.edu/wp-content/uploads/how_to_apply/ADNI_Acknowledgement_List.pdf

\newpage

\normalsize

```{r samplesizes,echo=FALSE,eval=TRUE}
redomerge=TRUE
buildsci=buildsci2=TRUE
```


```{r ppmimerge, echo=FALSE,eval=redomerge,cache=FALSE}
library(ztable)
library(rsq)
options(ztable.zebra.color="platinum")
options(ztable.colnames.bold=TRUE)
options(ztable.include.rownames=FALSE)
library(moonBook)
library(plyr)
library(subtyper)
library(forcats)
library(lmerTest)
library(lme4)
library(ggplot2)
library(ggpubr)
library(gridExtra)
library(mclust)
library(MASS)
library(dCUR)
library(mlr3learners)
library(mlr3verse)
library(effects)
library(ANTsR)

areunique = function( x ) {
  x[ !duplicated( x[,c("studyName","commonID","age_BL","T1Hier_resnetGrade")]), ]
}


subset_and_combine_studies <- function(df, study_column, study_names, grade_column, k_values) {
  # Check that study_names and k_values have exactly 2 elements
  if (length(study_names) != 2 || length(k_values) != 2) {
    stop("study_names and k_values should each have exactly 2 elements.")
  }

  # Define a helper function to subset and select top k rows for a given study
  subset_and_select <- function(study_name, k) {
    # Subset the dataframe for the specific study
    study_df <- df[na2f(df[[study_column]] == study_name), ]
    # Select the top k rows based on the specified grade column
    selected_rows <- topk(study_df, grade_column, k)
    # Return the subset of the dataframe with the selected rows
    return(study_df[selected_rows, ])
  }

  # Apply the helper function to each study and combine the results
  study1_subset <- subset_and_select(study_names[1], k_values[1])
  study2_subset <- subset_and_select(study_names[2], k_values[2])

  # Combine the two subsets
  combined_df <- rbind(study1_subset, study2_subset)
  
  return(combined_df)
}

 
makeqcpc <- function(demog, modality='T1w') {
  qcnames <- NULL
  coreqcnames =  c("EVR", 'snr', 'psnr', 'ssim', 'cnr', "reflection_err", 'mi', 'noise', 'msk_vol', 'spc0', 'spc1', 'spc2' )
  if (modality == 'T1w') {
    qcnames = c("T1Hier_templateL1", "T1Hier_resnetGrade", 'T1Hier_mhdist', coreqcnames )
  } else if (modality == 'DTI') {
    temp = paste0( modality,"1_",coreqcnames)
    qcnames = c("T1Hier_templateL1", "T1Hier_resnetGrade", temp)
  } else if (modality == 'rsf') {
    temp = paste0( modality,"1_",coreqcnames)
    qcnames = c("T1Hier_templateL1", "T1Hier_resnetGrade", temp)
  } else {
    stop("Unsupported modality")
  }
  
  # Identify rows with any NA values in the selected columns
  na_rows <- apply(demog[, qcnames], 1, function(x) any(is.na(x)))
  
  # Filter out rows with NA values
  non_na_demog <- demog[!na_rows, qcnames]
  pcqcmat <- data.matrix(non_na_demog)
  
  # Perform PCA
  pca_result <- prcomp(pcqcmat, scale. = TRUE)
  new_pca_columns <- pca_result$x[, 1:4]
  colnames(new_pca_columns) <- paste0(modality, colnames(new_pca_columns))
  colnames(new_pca_columns)=gsub("PC","QC",colnames(new_pca_columns))
  # Create a data frame with new PCA columns filled with NA for the original rows with NA
  pca_columns_full <- matrix(NA, nrow = nrow(demog), ncol = 4)
  colnames(pca_columns_full) <- colnames(new_pca_columns)
  pca_columns_full[!na_rows, ] <- new_pca_columns
  
  # Combine the original data frame with the new PCA columns
  demog <- cbind(demog, pca_columns_full)
  
  return(demog)
}


mypartrate=0.8
npd=ngpd=nprepd=0
mvanvp3=mvanvpu=mvanvp2=mvanvp1=1
doadj=FALSE
dxcts=data.frame()
rdir=path.expand('~/code/multidisorder/data/')
rdir=path.expand('~/Downloads/ppmi_pym_data/')
ppmitrimfn = paste0(rdir,'ppmi_idps_trim_v1.4.0_',myrez,'.csv')
rgT1 = c( 5000, 2150, 950 )
########
replaceOG=TRUE
if ( file.exists( ppmitrimfn ) & ! exists("ppmitrim")  ) {
  ppmitrim = read.csv(ppmitrimfn)
  adjnames = getNamesFromDataframe( "_adjusted", ppmitrim )
  ognames = gsub("_adjusted", "", adjnames )
  if ( replaceOG ) {
    ppmitrim[,ognames]=ppmitrim[,adjnames]
  }
} else if ( ! exists("ppmi") & !exists("ppmitrim") ) {
  if ( ! exists("pymf") ) {
    v='1.4.0'
    pymfns = data.frame(
      fns=c( 
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v',v,'.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v',v,'.csv'),
        paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRNext_v',v,'.csv')  ),
      rez=c("OR","SRF","SRP") )
    print(paste("ANTsPyMM Pipeline : ", myrez ) )
    pym = read.csv(  pymfns$fn[pymfns$rez == myrez ] )
    pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
    pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
    pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
    pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
    rm(pym)
    }
  if ( ! exists("adni") ) {
    adni = read.csv( path.expand( paste0(rdir, "ADNIMERGE_10Feb2024_antspymm_v",v,".csv" ) ) )
#    adnihq = highestQualityRepeat( adni, 'PTID', 'date', 'T1Hier_resnetGrade' )
  }
  studynames=c("ADNI", "NIFD4RTNI", "PPMI","UKBB","A4")
  dxnames= c("DX_bl", "DX", "DXSub", "DX", "DX" )
  sexnames=c("PTGENDER","SEX","SEX","sex_f31_0_0","PTGENDER")
  agenames=c("AGE","Age_BL","age_BL","subjectAge_BL","PTAGE")
  edunames=c("PTEDUCAT","EDUCATION","EDUCYRS","age_completed_full_time_education_f845_0_0","PTEDUCAT")
  sidnames=c("PTID","LONI_ID","PATNO","eid","sid")
  viznames=c("Years.bl","deltaTime","yearsbl","Years.bl","Years.bl")
  adni$commonSex = adni$PTGENDER
  adni$commonEdu = adni$PTEDUCAT
  adni$commonID = adni$subjectID = adni$PTID
  adni$age_BL = adni$age = adni$AGE
  adni$yearsbl = adni$Years_bl
  adni$joinedDX = adni$DX_bl
  adni$joinedDX[ grep("MCI",adni$joinedDX)]="MCI"
  adni$joinedDX[ adni$joinedDX == ""]=NA
  adni$studyName='ADNI'
  adniasynfn = path.expand( paste0(rdir,"AMPRION_ASYN_SAA_13Nov2023.csv"))
  adniasyn = read.csv( adniasynfn )
  names( adniasyn )[ names(adniasyn) == 'Result' ]='AsynStatus'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Detected-1','Detected-2')) , 'AsynStatus'] = 'Positive'
  adniasyn[ subtyper::fs(adniasyn$AsynStatus %in% c('Not_Detected','Indeterminate')), 'AsynStatus' ] = 'Negative'
  # map 
  adni$AsynStatus=NA
  uids = unique( adniasyn$RID[!is.na(adniasyn$AsynStatus)])
  for ( k in 1:nrow(adniasyn) ) {
        losel = subtyper::fs( adni$RID == adniasyn$RID[k] )
        if ( sum(losel) > 0 ) {        
            adni$AsynStatus[ losel ] = adniasyn$AsynStatus[k]
        }
    }
  ########### PPMI critical stuff here ###########
  demog=read.csv(paste0(rdir,"PPMI_20240401/Demographics_20240401.csv"))
  curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20240129.csv')
  saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv')
  if ( ! file.exists( saafn ) ) {
    saafn = paste0(rdir,'PPMI_CSFSAA_09Oct2023.csv')
    }
  saa=read.csv( saafn )
  ppmidemog0=read.csv( curfn )
  clin2b = merge_ppmi_imaging_clinical_demographic_data(
    demog, ppmidemog0, pymf, pymversion=myrez, saa )
  # add tracker
  tracker = read.csv(paste0(rdir,"ppmi_2_0_internal_scan_tracking_report_v12-2024-02-08.csv"))

  tracker = tracker[ tracker$Modality == "MR", ]
  tracker$EVENT_ID=tracker$Visit
  tracker$EVENT_ID[ grep("Baseline",tracker$EVENT_ID)]="BL"
  tracker$date=NA
  momap=data.frame( num=c( paste0("0",1:9), "10", "11", "12") )
  rownames(momap)=c("JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC")
  for ( k in 1:nrow(tracker) ) {
    fixedev=unlist(strsplit( tracker$Visit[k], "/"))
    if ( length( fixedev ) > 1 ) fixedev=fixedev[length( fixedev )]
    tracker$EVENT_ID[k]=fixedev
    fixeddt = unlist(strsplit( tracker$Scan.Date[k],"-"))
    fixeddt[2] = momap[ fixeddt[2], 'num' ]
    fixeddt = paste0( fixeddt[3] , fixeddt[2], fixeddt[1] )
    tracker$date[k]=fixeddt
    }
  trackersub = tracker[, c("Subject.ID","date" )]
  trackersub$imaging_protocol=2
  names(trackersub)=c("PATNO","date", "imaging_protocol" )
  clin2b=merge( clin2b, trackersub, by=c("PATNO","date"), all.x=TRUE )
  clin2b$imaging_protocol[ is.na(clin2b$imaging_protocol) ]=1
  # add LRRK2 
  lrrk2 = read.csv( paste0(rdir,'CSFSAA_LRRK2_MRI_SAMPLES_08Jan2024/Data-Table1.csv'))
  lrrk2$SAAGroup[ lrrk2$SAAGroup == " " ]=NA
  clin2b$LRRK2_study=NA
  uids = lrrk2$PATNO
  lrrk2cols = colnames(lrrk2)
  lrrk2cols=lrrk2cols[ !(lrrk2cols %in% "PATNO") ]
  newcols = paste0("LRRK2_", lrrk2cols )
  clin2b[,newcols]=NA
  for ( k in 1:length(uids) ) {
    clin2bsel = clin2b$PATNO == uids[k]
    if ( sum( clin2bsel ) > 0 ) {
      # print(paste("have",u))
      clin2b[clin2bsel,newcols]=lrrk2[k,lrrk2cols]
    } # else print(paste("miss",u))
  }
  clin2b$LRRK2_study = !is.na( clin2b$LRRK2_cohort)
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_dwi_mean +T1Hier_evratio + noise + snr + msk_vol,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~ DTI_dti_tsnr_b0_mean+DTI_dti_ssnr_b0_mean + DTI_dti_tsnr_dwi_mean+DTI_dti_ssnr_dwi_mean+T1Hier_resnetGrade +T1Hier_evratio + cnr + noise,data=clin2b) )
  summary( lm( LRRK2_MRIPROTOCOL ~  cnr + noise  + msk_vol + spc0+	spc1+	spc2,data=clin2b) )
  clin2b$subjectID = as.character(clin2b$subjectID)
  clin2b$imageID = as.character(clin2b$imageID)
  clin2b$dtid1 = as.character(clin2b$dtid1)
  clin2b$dtid2 = as.character(clin2b$dtid2)
  clin2b$rsfid1 = as.character(clin2b$rsfid1)
  clin2b$rsfid2 = as.character(clin2b$rsfid2)
  clin2b=dplyr::bind_rows( clin2b, adni )
  nna=!is.na( clin2b$AsynStatus )
  clin2b$DXSubAsyn[nna]=paste0( clin2b$joinedDX[nna], clin2b$AsynStatus[nna] )
  clin2b$DXSubAsyn[ clin2b$DXSubAsyn == "NANegative"]=NA
  clin2b$commonEdu[ clin2b$commonEdu == 1] = 12
  clin2b$commonEdu[ clin2b$commonEdu == 2] = 16
  clin2b$commonEdu[ clin2b$commonEdu == 3] = 20
  ppmi = clin2b
  rm(clin2b)
  rm(pymf)
  rm(adni)
  gc()
  ppmi$T1Hier_midbrain_pons_ratio = ppmi$T1Hier_vol_midbrainbrainstem / ppmi$T1Hier_vol_ponsbrainstem
  ppmi$SITE = factor( ppmi$SITE )
  ppmi$brainVolume = ppmi$T1Hier_vol_hemisphere_lefthemispheres + ppmi$T1Hier_vol_hemisphere_righthemispheres
  ppmi$brainVolume = ppmi$brainVolume / mean(ppmi$brainVolume)
  ppmi$imaging_protocol[ ppmi$studyName=='ADNI']=3
  ppmi$imaging_protocol=factor(ppmi$imaging_protocol)
  ppmi[ ppmi$studyName=='ADNI', 'age_BL']=ppmi[ ppmi$studyName=='ADNI', 'AGE']
}



```


```{r ppmitrim,echo=FALSE,eval=!exists("ppmitrim"),fig.width=16,fig.height=10,message=FALSE,warning=FALSE,cache=FALSE}
ppmi = fillBaselineColumn( ppmi,
        c(  'brainVolume', 'T1Hier_resnetGrade' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
ppmi = antspymm_predictors( ppmi, TRUE )
ppmi$maxtominspc = apply(  ppmi[,c("spc0","spc1","spc2")], FUN=max, MARGIN=1 )/
  apply(  ppmi[,c("spc0","spc1","spc2")], FUN=min, MARGIN=1 )
#############
mith=-0.5
ssimth=0.3
psnrth=12.0
mmspc=2.0
evThresh=c(0.45,0.9)  # 0.3
evThresh=c(0.0,1.0)  # 0.3
rgThresh=0.2
eps=0.0
qvary = c(eps,1.0-eps)
if ( myrez == 'SRF' ) {
  snrth=c( quantile(ppmi$snr,qvary,na.rm=T) )
} else {
  snrth=c( quantile(ppmi$snr,qvary,na.rm=T) )
}
asel = subtyper::fs( ppmi$studyName == 'ADNI' & 
  ppmi$T1Hier_resnetGrade_BL >= rgThresh & ppmi$T1Hier_resnetGrade >= rgThresh )
studies = c('PPMI','ADNI')
# studies = c('PPMI')
psel = subtyper::fs( 
    ppmi$studyName %in% studies & !(ppmi$subjectID == "101021" ) & 
    ppmi$SITE != 76 & 
    ppmi$yearsbl <= 4.5 & # limit non-random bias
    ( ppmi$snr >= snrth[1] & ppmi$snr <= snrth[2] ) &
    ppmi$maxtominspc <= mmspc & 
    ppmi$T1Hier_resnetGrade_BL >= rgThresh &
    ppmi$T1Hier_resnetGrade >= rgThresh &
#    ppmi$mi < mith & ppmi$ssim > ssimth & ppmi$psnr > psnrth &
    ppmi$EVR >= evThresh[1] &  ppmi$EVR <= evThresh[2]
)
ppmitrim = ppmi[ psel , ]
table( ppmitrim$studyName )

for ( mymo in c("T1w","DTI","rsf") ) {
  ppmitrim=makeqcpc( ppmitrim, mymo )
}

ppmitrim$mriMagneticFieldStrength[ 
  ppmitrim$mriMagneticFieldStrength %in% c(1.494)]=1.5
ppmitrim$mriMagneticFieldStrength[ 
  ppmitrim$mriMagneticFieldStrength %in% c(2.89362)]=3
ppmitrim$mriMagneticFieldStrength[ 
  !(ppmitrim$mriMagneticFieldStrength %in% c(1.5,3))]='other'
ppmitrim$mriMagneticFieldStrength=factor(ppmitrim$mriMagneticFieldStrength)

nmnames = getNamesFromDataframe( c("NM2DMT_NM","_substantianigra"), ppmitrim, exclusions='z_coord'  )
nmqcnames = getNamesFromDataframe( "NM2DMT", ppmitrim, exclusions='_substantianigra' )

```

```{r ppmitrimX,echo=FALSE,eval=TRUE,fig.width=16,fig.height=10,messages=FALSE,warnings=FALSE,cache=FALSE}
library(GGally)
qcnames=c( "T1Hier_resnetGrade", "noise", "snr", "EVR", "psnr", "ssim", "mi", "msk_vol", "reflection_err", "mriPixelBandwidth", "mriSAR", "maxtominspc",'updrs_totscore' )
my_bin <- function(data, mapping, ..., low = "#132B43", high = "#56B1F7") {
  ggplot(data = data, mapping = mapping) +
    geom_bin2d(...) +
    scale_fill_gradient(low = low, high = high)
}
ssel = subtyper::fs(ppmitrim$studyName == 'PPMI')
qcdf=ppmitrim[  ssel, c(qcnames,'joinedDX')]
qcdf$snc=ppmitrim$T1Hier_vol_mtg_sn_snc_LRAVGcit168[ssel]
# qcdf=ppmi[,c(qcnames,'joinedDX')]
# qcdf$snc=ppmi$T1Hier_vol_mtg_sn_snc_LRAVGcit168
qcdf$DX = "Other"
qcdf$DX[ grep("PD",qcdf$joinedDX)]="PD"
qcdf$DX[ grep("CN",qcdf$joinedDX)]="CN"
qcdf$DX[ grep("Prod",qcdf$joinedDX)]="AR"
qcpairs <- ggpairs( qcdf, columns=c(qcnames,"snc"),
  mapping = aes(color = DX),
  lower = list(
    combo = wrap("facethist", binwidth = 1),
    continuous = wrap(my_bin,  high = "red")
  ) )
# print( qcpairs )
# gc()

# ntokeep = nrow(ppmitrim)-round(0.01*nrow(ppmitrim))
# ppmitrim = ppmitrim[ head( order(ppmitrim$T1Hier_resnetGrade,decreasing=T),ntokeep) , ]
updnames = getNamesFromDataframe("upd",ppmitrim,exclusions=c("BL","delta"))
msnames = getNamesFromDataframe("pm_",ppmitrim,exclusions=c("BL","delta"))
lrrk2names= getNamesFromDataframe("LRRK2_",ppmitrim,exclusions=c("BL","delta","LRRK2_MRIPROTOCOL"))
t1namesctx = getNamesFromDataframe( c("T1Hier","LRAVG",'dktcortex','thk'), ppmitrim)
t1namescit = getNamesFromDataframe( c("T1Hier","LRAVG",'deep','vol'), ppmitrim)
t1namesnbm = getNamesFromDataframe( c("T1Hier","LRAVG",'nbm','vol'), ppmitrim)
t1namesbst = getNamesFromDataframe( c("T1Hier",'brainstem','vol'), ppmitrim, exclusions=c("tissues","lobes"))[-1]
t1namescrb = getNamesFromDataframe( c("T1Hier",'cerebellu','LRAVG','vol'), ppmitrim, exclusions=c("tissues","lobes","dktregion"))
t1namesctxa = gsub("LRAVG","Asym",t1namesctx)
t1namescita = gsub("LRAVG","Asym",t1namescit)
t1namesnbma = gsub("LRAVG","Asym",t1namesnbm)
t1namescrba = gsub("LRAVG","Asym",t1namescrb)
t1vars = c(t1namesbst,t1namesctx,t1namescit,t1namesnbm,t1namescrb,t1namesctxa,t1namescita,t1namesnbma,t1namescrba)
ppmitrim0 = ppmitrim[ , c("subjectID","age_BL",'commonSex', "hy_BL", "duration_yrs","LEDD","MOCA",updnames, msnames, 'joinedDX','AsynStatus', "DXSubAsyn", "educ","race",'tau','ptau','abeta', 'yearsbl', 'EVENT_ID', 'date', lrrk2names,  'filename', 'brainVolume', t1vars, 'imaging_protocol', 'T1Hier_resnetGrade' ) ]

# get numbers for abstract
viztbl = table( ppmitrim0$joinedDX, ppmitrim0$EVENT_ID )
isbl=ppmitrim0$yearsbl==0
npd=viztbl["PDSporadic","BL"]
npdf=sum(viztbl["PDSporadic",c("V04","V06","V08","V10","V12")])
ngpd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('PDGBA','PDLRRK2','PDSNCA' )))
nctl=viztbl["CN","BL"]
nprepd=sum( subtyper::fs(ppmitrim0$joinedDX[isbl] %in% c('ProdromalGBA','ProdromalLRRK2' ,'ProdromalSNCA','ProdromalSporadic' )))
vizfll=mean( ppmitrim0$yearsbl[!isbl] )
vizfll=insight::format_value( vizfll )
# tt = table( table( ppmitrim0$subjectID[!isbl] ) )

if ( FALSE ) {

ppmitrimbl=ppmitrim[ ppmitrim$EVENT_ID=='BL', ]
vv='T1Hier_vol_bn_str_pu_Asymdeep_cit168'
vv='T1Hier_vol_bn_gp_gpi_Asymdeep_cit168'
vv='T1Hier_vol_bn_gp_gpi_LRAVGdeep_cit168'
qq=quantile( ppmitrimbl[,vv], 0.95 )
table( ppmitrimbl$DXSubAsyn[ ppmitrimbl[,vv] > qq ] )
qq=quantile( ppmitrimbl[,vv], 0.025 )
table( ppmitrimbl$DXSubAsyn[ ppmitrimbl[,vv] < qq ] )

# convert Asym to AsymNorm 
ppmitrim = antspymm_predictors( ppmitrim, TRUE )
asymvars = getNamesFromDataframe( "Asym", ppmitrim )
for ( x in asymvars ) {
  y=gsub("Asym","LRAVG",x)
  myasym = ppmitrim[,x]
  ppmitrim[,x]=myasym/(ppmitrim[,y]*2)
  if ( max(ppmitrim[,x],na.rm=T) > 1 ) derka
}
}
doadj=!("DTI_mean_md_nbm_LRAVG_pos_adjusted" %in% colnames(ppmitrim))
########
```


```{r ppmitrimAdj,echo=FALSE,eval=doadj,fig.width=16,fig.height=10,message=FALSE,warning=FALSE,cache=FALSE}
ppmitrim = ppmitrim[ ppmitrim$mrimfg %in% c("GE","Philips","Siemens"), ]
nmstotest2=antspymm_predictors( ppmitrim, TRUE, TRUE )
nmstotest2=nmstotest2[ -multigrep( c( "T1w_mean", "alff","peraf","template","fcnxpro134","fcnxpro122","_adjusted"), nmstotest2)]
# adjust each of these vars
ppmitrim$isTrain=FALSE
# fairly balanced
dxsel = ppmitrim$joinedDX %in% c("CN",'ProdromalLRRK2','ProdromalGBA','ProdromalSporadic','SWEDDSporadic')
# dxsel = ppmitrim$joinedDX %in% c("CN")
agsel = ppmitrim$age_BL >= 50 & ppmitrim$age_BL <= 75
ppmitrim$isTrain[ dxsel & agsel ]=TRUE
table(ppmitrim$isTrain, ppmitrim$studyName )
############################################
ct=0
for ( x in nmstotest2 ) {
    ct=ct+1
    if ( ct %% 100 == 0 ) cat( paste( ct / length(nmstotest2)*100 , "%" )  )
    if ( antspymm_vartype(x) %in% c('rsfMRI','DTI') ) {
        myform = paste( x, " ~ studyName + mrimfg")
    } else myform = paste( x, " ~ studyName + mrimfg + mriMagneticFieldStrength ")
    ppmitrim=adjustByCovariates( ppmitrim, myform, 'isTrain', TRUE, TRUE )
}
nmstotest2adj=paste0(nmstotest2,'_adjusted' )
doadj=FALSE
```

# Abstract

The Parkinson's Progression Markers Initiative (PPMI) delivers multiple modality MRI (M3RI) and biomarker data for a comprehensive longitudinal study of Parkinson's Disease (PD).  These provide quantitative indices of deep brain and cortical structure (T1-weighted MRI), microstructural integrity of brain tissue (diffusion-weighted imaging) and resting brain function (resting state functional MRI).  Integrating and uniformly analyzing M3RI alongside non-imaging biological and clinical data is challenging due to the distinct nature of each modality. This study systematically organizes these complex data into a structured format, provides a PD-focused evaluation of the methodologies and evidence for technical robustness of the approach.  The cohort encompasses `r npd` idiopathic PD, `r ngpd` genetic PD, `r nprepd` presymptomatic PD and `r nctl` control subjects at baseline with followup at a mean of `r vizfll` years.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy bodies, primarily composed of misfolded alpha-synuclein, and appearing in the substantia nigra at an early stage [@fearnleyAgeingParkinsonDisease1991]. The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [@lee_mechanisms_2006;@dickson_neuropathology_2009;@calabresi_alpha-synuclein_2023]. The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [@shahnawaz_discriminating_2020; @siderowf_assessment_2023].

Analyzing longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking evidence of pathology, symptoms and imaging [@nemmi_totally_2019; @tremblay_sex_2020; @markello_multimodal_2021].

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI from 2010 to early 2024, focusing on T1-weighted, diffusion-weighted, and resting-state functional rsfMRI. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [@avants_pediatric_2015; 
@stone_functional_2020; @tustison_antsx_2021]

<!--
To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] and an additional easily accessible M3RI young control cohort [@avants_pediatric_2015].  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 
-->

To establish face validity, this study leverages not only PPMI M3RI, but also the Alzheimer's Disease Neuroimaging Initiative (ADNI) [@veitch2024alzheimer] and traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019].  We analyze these data collectively and uniformly to establish reliability benchmarks and to demonstrate feasibility of consistent processing in multi-site studies such as PPMI.  Additionally, we exemplify statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD and related conditions.

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [@schwarz_t1-weighted_2011;@aquino_substantia_2014;@ryman_mri_2020;@poston_substantia_2020]. Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [@peran_magnetic_2010;@owens-walton_worldwide_2024] but also in genetic PD [@tolosa_lrrk2_2020;@owens-walton_worldwide_2024]. Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [@hacker_resting_2012;@kim_abnormal_2017;@esposito_rhythm-specific_2013]. Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain.  More integrative research in PD [@menke_mri_2009;@markello_multimodal_2021] is needed to determine the sequence of these changes and how they may relate to alpha-synuclein and potential copathology or comorbidity [@simuni_biological_2024].

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs are computed with [ANTsPyMM v1.4.0](https://pypi.org/project/antspymm/) and depend on standard anatomical and functional hierarchies that are well-established in the field and consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dwMRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables easily merge with the associated demographics, SAA status, clinical data such as the Movement Disorder Society-Sponsored Unified Parkinson's Disease Rating Scale (MDS-UPDRS) [@disease_unified_2003] and standard PPMI DAT-SPECT summary measurements [@bega_clinical_2021; @droby_aberrant_2022]. Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.

# Methods

## MRI data collection 

MRI data collection occurred between 2010 and an April 2024 cutoff date for these data.  Two phases of MRI collection occurred in PPMI; the first collected T1w and later DTI as part of exploratory investigations.  In 2020, a new phase of collection sought to improve both MRI quality and consistency and expand the number of modalities collected.  The sequences used at each site are provided in detail at [@avants_ppmi_2024] and in the original Laboratory of Neuroimaging (LONI) source data (described below in Data Records). The "phase" of data collection is captured in the variable `imaging_protocol`.  The PPMI data includes control subjects, idiopathic (sporadic) PD subjects and genetic PD subjects characterized by GBA, LRRK2, SNCA and PRKN mutations; the latter two groups appear infrequently in this PPMI M3RI cohort.  Additionally, presymptomatic subjects comprise a substantial and growing portion of the cohort; these are also characterized by genetic mutations and/or early risk factors for PD (hyposmia or RBD) [@siderowf_assessment_2023].  Table 1 summarizes the cohort characteristics.  In the following sections, we focus on the PD cohort with SAA measurements as the presymptomatic cohort is undergoing significant additional data collection.


```{r tblprep,eval=TRUE,echo=FALSE,cache=FALSE}

nmstotest2=antspymm_predictors( ppmitrim, TRUE, TRUE )
nmstotest2=nmstotest2[ -multigrep( c("alff","peraf","template","fcnxpro134","fcnxpro122","_adjusted","_BL","_delta","T1w_mean","area"), nmstotest2)]

if ( ! exists("ppmitrimsave") & FALSE ) {
#  ppmitrimsave = ppmitrim
#  nmstotest2=gsub("_adjusted","",nmstotest2adj)
#  ppmitrim[,nmstotest2]=ppmitrim[,nmstotest2adj]
  write.csv( ppmitrim, ppmitrimfn, row.names=FALSE )

  simfile="~/Downloads/ppmi_pym_data/PPMISiMLRW100"
  presim=read_simlr_data_frames( path.expand(simfile), 
      c("t1","t1a", "dt", "dta", "rsf" ))
  ppmitrim = apply_simlr_matrices(  ppmitrim, presim, absolute_value=rep(TRUE,length(presim)), robust=FALSE )[[1]]
  simnames = apply_simlr_matrices(  ppmitrim, presim, absolute_value=rep(TRUE,length(presim)), robust=FALSE )[[2]]
#########
  cnames = getNamesFromDataframe("common",ppmitrim)
  cnames[ which(cnames=='commonAge')]='age_BL'
  trimnames=c("studyName",cnames,'yearsbl', "date","filename",
    getNamesFromDataframe("QC",ppmitrim), antspymm_qc_names(),nmstotest2, simnames)
  trimnames=unique(intersect(trimnames,colnames(ppmitrim)))
  write.csv( ppmitrim[,trimnames], gsub(".csv","_trim.csv",ppmitrimfn,fixed=TRUE), row.names=FALSE )
}

###
toadd = c(  "age_BL", "commonSex", 'race', 'hy_BL', 'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD', 'subgroup', 'imaging_protocol')
toadd = c(  "age_BL", "commonSex", 'race',  'duration_yrs', "updrs_totscore", 'AsynStatus', 'LEDD', 'subgroup', 'imaging_protocol')
biomarkers = c('abeta', 'tau',  'nfl_serum', 'mean_striatum' )
tblcols = unique( c( toadd, 'joinedDX'  ) )
bsel = ppmitrim$yearsbl==0 # & ppmi$studyName == 'PPMI'
joinedem=ppmitrim[bsel,tblcols]
joinedem$imaging_protocol=as.character(joinedem$imaging_protocol)
#joinedem$hasDTI=!is.na(ppmitrim[bsel,'DTI_dti_FD_max'])
#joinedem$hasfMRI=!is.na(ppmitrim[bsel,'rsfMRI_fcnxpro129_FD_max'])
names(joinedem)[1]=tblcols[1]='age'
names(joinedem)[2]=tblcols[2]='Sex'
wsaa=which(names(joinedem)=='AsynStatus' )
names(joinedem)[wsaa]=tblcols[wsaa]='CSFSAA'
tblcols=colnames(joinedem)
tblcols=gsub("_",".",tblcols)
tblcols=gsub(".mean","",tblcols)
tblcols=gsub("DTI.","",tblcols)
tblcols=gsub("rsfMRI.fcnxpro122.","rsfMRI.",tblcols)
names(joinedem)=tblcols
joinedem$race = as.character( joinedem$race )
joinedem[ subtyper::fs(joinedem$race == '1'), 'race' ] = 'White'
joinedem[ subtyper::fs(joinedem$race == '2'), 'race' ] = 'Black'
joinedem[ subtyper::fs(joinedem$race == '3'), 'race' ] = 'Asian'
joinedem[ subtyper::fs(joinedem$race == '4'), 'race' ] = 'Other'
joinedem[ is.na(joinedem$race), 'race' ] = 'not.spec.'
joinedem$joinedDX = gsub("Prodromal",'AR',joinedem$joinedDX)
joinedem$joinedDX=as.character(joinedem$joinedDX)
joinedem$joinedDX[ 
  multigrep( c("ARSporadic"), joinedem$joinedDX )]='SporadicAR'
joinedem$joinedDX[ 
  multigrep( c("ARGBA", "ARLRRK2",  "ARSNCA"), joinedem$joinedDX )]='GenAR'
joinedem$joinedDX[
  multigrep( c( "PDPRKN", "PDSNCA"), joinedem$joinedDX )]='OtherGenPD'
joinedem$joinedDX[ 
  multigrep( c("PDGBA"), joinedem$joinedDX )]='GBAPD'
joinedem$joinedDX[
  multigrep( c("PDLRRK2"), joinedem$joinedDX )]='LRRK2PD'
joinedem$joinedDX[ 
  multigrep( c("PDSporadic"), joinedem$joinedDX )]='SporadicPD'
mlevs = c( "CN", "GenAR", "SporadicAR","OtherGenPD", 'LRRK2PD', 'GBAPD', "SporadicPD")
joinedem$joinedDX = factor( joinedem$joinedDX, levels = mlevs )
mytbl = joinedem[ !is.na(joinedem$joinedDX),c(tblcols)]
mytbl$imaging.protocol=as.character(mytbl$imaging.protocol)
mytbl$imaging.protocol[ mytbl$imaging.protocol=='1']='PPMI1'
mytbl$imaging.protocol[ mytbl$imaging.protocol=='2']='PPMI2'
mytbl$imaging.protocol[ mytbl$imaging.protocol=='3']='ADNI'
rownames(mytbl)=1:nrow(mytbl)
mycap="Table 1. Baseline PPMI IDP cohort. AR=at-risk; MSA = multi-system atrophy; OtherGen = other genetic; RBD = REM Sleep Behavior Disorder."
####
```

```{r clusterCharARtbl,eval=TRUE,echo=FALSE,cache=FALSE,results='asis'}
sttblPD=ztable(mytable(joinedDX~.,data=mytbl),zebra=2)

# Print the ztable object, ensuring it's treated as LaTeX code
print(sttblPD, type = "latex",size=4,caption=mycap,sidewaystable=TRUE)


```


```{r tbl1instead,eval=FALSE,echo=FALSE,cache=FALSE,results='asis'}
library(table1) # https://cran.r-project.org/web/packages/table1/vignettes/table1-latex.pdf
x=table1(~ . | joinedDX, data=mytbl[!is.na(mytbl$joinedDX),], topclass="Rtable1-zebra",caption=mycap)
t1kable(x)
```

### Data Organization

Raw DICOM data was downloaded from LONI and converted to nifti format via `dcm2niix` [@li_first_2016]. These data were then organized into a directory tree following the [NRG format](https://github.com/stnava/biomedicalDataOrganization) illustrated in Figure 1. This BIDS-like structure [@gorgolewski_brain_2016] is defined to aid in longitudinal analyses of multiple modality data and intends to support: (a) sortable and specific dates associated with imaging sessions; (b) links between the data on disk and its origin (LONI) through the "Image ID"; (c) easy maintenance of multiple modality data collections; and (d) predictable input/output structure.  Critically, the unique ID allows the original data associated with an IDP to be easily found in LONI.  In brief, this system assigns each image -- and categories of derivative data -- a directory and individual file name that assist in making data findable, accessible, interpretable and reproducible (FAIR) for both early and downstream processing.

![The NRG format supports predictable and interpretable data storage and processing that can easily be tied back to the LONI source dicom.  The filename proceeds from less specific information (Project ID at reader's left) to the most specific (unique image ID at reader's right).  A specific character -- here the dash -- is reserved exclusively as a separator between the stages of information.](../figs/nrg_format.jpg)

### ANTsPyMM processing

ANTsPyMM collects and documents best ANTsX practices for both data inspection and IDP generation for the modalities of interest in a single python package.  While ANTsPyMM supports BIDS format, it behaves most predictably and safely with NRG format.  Each "run" of the integrated multiple modality processing encoded by ANTsPyMM is driven by a data frame that defines a multiple modality "collection" of images for a given subject at a given date.  There are two key functions that aid users in defining the appropriate input data structure and sending that data to processing.  The first is `antspymm.generate_mm_dataframe` which generates the appropriate multiple modality subject dataframe that documents on disk locations for image sets.  The resulting dataframe defines the expected input as well as output structures.  The second key function runs the multiple modality processing (`antspymm.mm_csv`) based on the multiple modality subject dataframe.  The "Usage Notes" section provides more details on this system with an accompanying reproducible example based on freely accessible multiple modality neuroimaging.

![Overview of ANTsPyMM outputs for T1-weighted MRI, diffusion MRI and resting state fMRI.  Panel (a) shows example input data; the package does not require all modalities to be present -- only T1w.  It also handles arterial spin labeling (perfusion), FLAIR and neuromelanin, not covered here.  Panel (b) illustrates core T1w outputs across several inter-related and PD relevant systems in the brain.  Panel (c) shows the standard outputs associated with DTI. Whole brain tractography is also output but no evaluation results are available to contextualize its performance and, as such, we do not recommend its use.  Panel (d) summarizes the various rsfMRI outputs for processing parameter set number 129 referred to with a prefix `rsfMRI_fcnxpro129`.](../figs/antspymm_3.jpg)

### Semi-automated quality assessment

ANTsPyMM's primary goal is reliable M3RI IDP generation.  Of necessity, it also addresses quality control (QC) with particular focus on the T1w modality i.e. the core anatomical image that represents the most consistently collected MRI in PPMI. T1w is the focus of QC because ancillary modality processing depends heavily on anatomical labels (e.g. tissue segmentation, cortical parcellation) derived from these images.  As such, we developed an automated (deep learning based) T1w reviewer that is trained on human (BA) QC reviews.  Each T1w image is therefore reviewed internally in the first stage of ANTsPyMM processing by this `resnetGrader` (a deep learning model trained to predict image quality) [@avants2023.02.02.23285376]. The grader will abort processing if the T1w does not achieve a given baseline level of quality.  Human visual inspection was performed on images that pass the grader by BA and serves as a sanity check to the automated method.  The `resnetGrader` successfully filtered unusable data and we selected a quality cutoff at 1.02 to filter out low quality images.  Similarly, the rsfMRI and DTI were reviewed in `post hoc` fashion.  This process involved visually inspecting each estimated FA image and each estimated default mode network connectivity map and its associated mean BOLD image.  Particular focus was paid to cases with high motion and/or low SNR; such images were excluded from statistical analyses.

## Neuroanatomical coordinate systems

The statistical interpretation of processed images is aided by automatic anatomic labeling with pre-specified coodinate systems or maps overlaid on each subject's neuroimage. We leverage a recent homotopic parcellation [@yan_homotopic_2023], the Desikan-Killiany-Tourville (DKT) system [@klein_101_2012], the CIT168 atlas [@pauli_high-resolution_2018], the Johns Hopkins University (JHU) white matter labels [@mori_white_2009], the Schmahmann cerebellar parcellation [@lyu_multimodal_2024;@carass_comparing_2018], brain stem labels [@iglesias_bayesian_2015], a medial temporal lobe schema [@rizvi_posterior_2023-1] and labels derived from probabilistic maps of the basal forebrain [@liu_nucleus_2015;@zaborszky_stereotaxic_2008].  These systems are described in detail in online [data dictionary and associated documentation](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) for this project. These coordinate system enable PD researchers to interrogate a variety of hypotheses related to, for example, known functional networks, association hubs, cholinergic networks, the striatum or dopaminergic systems.

### T1-weighted MRI processing

T1-weighted MRI processing is described in detail in [@tustison_antsx_2023;@tustison_antsx_2021]. This open-source software ecosystem includes tools for image registration, segmentation, and super-resolution (SR) as customized for the human brain.  The derived measurements are tabulated by the neuroanatomical coordinates defined above and include cortical and subcortical measurements and morphological measurements of the hippocampus, basal forebrain and cerebellum.  The results of this stage are key to consistent processing of rsfMRI and DWI. We provide both original resolution (OR) and SR results as part of this effort.  For SR processing of T1w, the network is applied -- first -- over the whole head T1w image to double resolution along all axes within the brain parenchyma. Otherwise, SR and OR processing are identical. SR training with 3D perceptual losses is documented in the `python` package [siq](https://pypi.org/project/siq/) and is based on `tensorflow` implementations of a volumetric deep back projection network (DBPN) [@avants2023.02.02.23285376;@tustison_antsx_2021;@haris_deep_2020] .  See Figure 2 for examples of these outputs.  IDPs derived from the T1 processing are denoted by prefixes `T1w` and `T1Hier`.


![Example ANTsPyMM SR outputs applied to T1-weighted MRI (upper left) and diffusion MRI. T1w is super resolved to 0.5mm isotropic and DTI to 1mm.](../figs/sr_comparison.jpg)

### Diffusion weighted MRI processing

Diffusion tensor image (DTI) processing leverages best practices from both ANTsX [@avants_pediatric_2015;@stone_neurological_2023;@stone_functional_2020] and the open-source DTI-focused project [DiPy](https://dipy.org) [@garyfallidis_dipy_2014]. This pipeline is specifically designed to utilize DWI acquisitions with either a single or opposed phase encoding directions. The functionality has been developed to address a broad spectrum of preprocessing requirements, such as motion correction, denoising, dewarping and gradient reorientation, and enhancement through SR techniques, culminating in an optimized DTI reconstruction. The SR stream applies to each volume in the DWI timeseries after motion correction and distortion correction but before tensor fitting i.e. in a relatively minimally invasive fashion.  After reconstruction, the pipeline integrates atlas-based labeling and template-based normalization processes, thereby enhancing the anatomical interpretability of the DTI metrics.  Figure 4 summarizes the pipeline which follows these steps:

![Overview of the DTI processing pipeline based on ANTsX and DiPy.](../figs/dti_pipe.jpg)

1. **Input Preparation**: The pipeline accepts either a single DWI or a pair of DWI with reversed phase encoding. It also requires associated b-values and b-vectors for each direction, alongside a T1-weighted image and a brain mask for improved spatial accuracy in inter-modality registration.

2. **Initial Reconstruction and Motion Correction**: By default, the DWI data is denoised before performing motion correction. This is skipped when applying SR which integrates denoising.  Motion correction aligns DWI volumes within and across acquisitions to a reference mean B0 and mean DWI, reducing artifacts due to subject movement.

3. **Dewarping and Super-Resolution**: Dewarping is applied to correct for distortions between the DWI space and the T1-weighted image. Optionally, SR is applied after dewarping but before the DiPy based reconstruction process.

4. **Reconstruction of DTI Metrics**: The function employs weighted least squares to reconstruct DTI metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD) from the preprocessed DWI data. This step is pivotal in quantifying the diffusion properties of brain tissue. 

5. **Atlas-Based Labeling and Registration**: Utilizing the Johns Hopkins University (JHU) atlas and corresponding labels [@mori_white_2009], the pipeline performs spatial registration of the DTI to the atlas space. This process facilitates anatomical localization and quantification of DTI metrics within predefined brain regions. 

6. **Output Generation**: The pipeline yields a comprehensive output including the reconstructed DTI metrics, summary statistics of these metrics within atlas-defined regions, the spatial registration information, and additional diagnostic metrics such as framewise displacement and signal-to-noise ratio (SNR) assessments spatially and temporally for both B0 and DWI. An example output volumetric tensor image with labels is in Figure 3 and 5.

IDPs derived from the DWI processing are denoted by prefixes `DTI_`.

![Example SR processing for DTI highligting the multiple coordinate systems to aid interpretation.](../figs/dti_SR.jpg)


### Resting state functional MRI processing 

Resting state functional MRI (rsfMRI) processing builds on prior multi-view M3RI analyses performed in this same ecosystem [@avants_pediatric_2015;@avants_amyloid_2019;@avants_similarity-driven_2021].  The procedure is based on the findings described in three comprehensive evaluation studies [@shirer_optimization_2015;@parkes_evaluation_2018;@noble_decade_2019] and is designed to compute both functional activity and correlation maps utilizing the recently proposed homotopic labels to delineate major network systems [@yan_homotopic_2023]. The methodology described below is grounded in contemporary understanding of resting-state fMRI analysis and incorporates recommendations from seminal works regarding optimal preprocessing for minimizing motion artifacts and other sources of noise [@shirer_optimization_2015;@parkes_evaluation_2018]. As such, our processing reflects a comprehensive approach to resting-state fMRI IDP extraction for real-world multi-site studies of neurodegenerative disease.  Overall, the methods aim to facilitate the reliable extraction of functional connectivity patterns that are consistent with underlying neural mechanisms in PD [@tahmasian_systematic_2015;@esposito_rhythm-specific_2013].  Similar to the DWI processing, the procedure accepts either a single image or a pair of images with reversed phase encoding direction.  The steps are outlined in Figure 6:

![Overview of the rsfMRI processing pipeline based on ANTsX.](../figs/fmri_pipe.jpg)

1. **Input Preparation**: Inputs include the raw BOLD fMRI time-series data, a reference volumetric subject-specific fMRI template (automatically generated), and T1-weighted anatomical images all from the same subject. These inputs are foundational for aligning functional data with anatomical landmarks and for ensuring that subsequent analyses are anatomically informed.  By default, the input fMRI is upsampled to 3mm isotropic resolution and 8 initial volumes are discarded to allow for both signal and subject stabilization.

2. **Preprocessing**: Initial steps include motion correction, application of a despiking algorithm (a `python` implementation of AFNI's 3dDespike [@cox_afni_2012]), and anatomical registration to align the fMRI data with the T1-weighted image.  If a pair of images is passed, these same preprocessing steps are applied and results are concatenated along the time axis.

3. **Noise Reduction**: Anatomical CompCor (aCompCor) is used to mitigate physiological and other noise sources. This is based on recommendations from studies examining the impact of preprocessing strategies on functional connectivity [@shirer_optimization_2015;@parkes_evaluation_2018].

4. **Band-pass Filtering and activity calculation**: The application of a specific frequency range for filtering aligns with recommendations from both Shirer et al. (2015) and Parkes et al. (2018), emphasizing the importance of selecting appropriate frequency bands for resting-state analysis.  The default frequency bands are based on empirical evaluation studies described below.

5. **Censoring**: Select volumes are censored based on both motion-based and intensity-based outlier detection.  The parameters for this stage derive from empirical evaluation studies on public data as discussed below.  Both *censored* and *imputed* versions of the time series are created.  A summary of censoring results is recorded in several ways but perhaps most relevant are the variables `*minutes_original_data` and `*minutes_censored_data` which provides the length in minutes of the original versus processed data.

6. **Network Correlation Analysis**: This step involves calculating correlation matrices for identified resting-state networks, utilizing labels described above.  Both inter and intra-network correlation values are computed for each of the sub-networks provided by the homotopic parcellation.  

7. **Functional activity**: is computed with three models: mfALFF, mALFF and mPerAf as described in [@jia_percent_2020].  These are versions of fALFF, ALFF and PerAf where each is divided by the global mean in the brain.  Summary values are averaged within each of 500 labels in the homotopic label set which facilitates left/right asymmetry and mean values which are critical to studying diseases with laterality effects.

Due to the relatively diverse needs of researchers and the variety of rsfMRI that is generally present in public data, we run the above processing with three different sets of parameters.  These sets are named by their position in the parameter search data frame as [122, 134 and 129](https://github.com/ANTsX/ANTsPyMM/blob/0d987b7c56d2d24a4a24ccb71dbb93d51157ff05/antspymm/mm.py#L6596-L6605).  They encode 3 different choices for outlier rejection (based on motion) and control of nuisance signal via aCompCor.  These three parameter choices led to rsfMRI IDPs that were the top performers in terms of reliability and predictive power out of 78 that we tested empirically.  See [this repository](https://github.com/stnava/antspymm_reproducibility) and the technical validation section for further details. IDPs from the rsfMRI processing are denoted by prefixes `rsfMRI_fcnxpro122` for 122 and similarly for 129 and 134.

## Dimensionality reduction with SiMLR 

Statistical power in cohorts with diverse composition may be challenged by the number of individual predictors (here, `r length(nmstotest2)`). To address this, we adopt similarity-driven multi-view linear reconstruction (SiMLR) for dimensionality reduction and apply the default settings recommended in prior work [@avants_similarity-driven_2021; @stone_neurological_2023]. SiMLR provides a reduced number of predictors by creating "sparse feature sets" that are linked across modalities, allowing for their combined use in joint prediction models. As an unsupervised method, SiMLR identifies a joint low-dimensional space that captures the common variability across these diverse modalities. This enables integrated analyses of MRI and acquired non-imaging data (represented as standard tabular outcomes) within the analytical framework of classical regression. Importantly, this approach can be applied even when only a subset of the variables is present.  

Here, the SiMLR decomposition is trained in ADNI subjects and subsequently applied to PPMI thereby decoupling the learning and inference stages.  Six matrices were decomposed into 100 joint components.  The matrices included one for tabular clinical data and five for neuroimaging including T1w related measurements averaged across left and right,  T1w related asymmetry measurements, DTI related measurements averaged across left and right,  DTI related asymmetry measurements and resting state connectivity measurements.  Although cognition and functionally related clinical scores were employed during decomposition, these were not retained for further application to PPMI.  The technical validation section will demonstrate how these learned patterns may be used in analyses integrating PPMI IDPs and clinically relevant metrics both cross-sectionally and longitudinally.


# Data Records

The PPMI IDPs for T1w, rsfMRI and DTI are located at [@avants_ppmi_2024]. The neuroimaging and associated standard PPMI demographics and clinical data is hosted in the [LONI Imaging Data Archive (LONI IDA)](http://ida.loni.usc.edu). The former is stored in DICOM format and the latter in tabular `csv` format.  Additionally, data dictionaries describing all non-imaging column headers are available on the LONI IDA.  

We attach the neuroimaging IDPs to the PPMI Curated Data Cut (v.2024-01-29 `PPMI_Curated_Data_Cut_Public_20240129`) from the LONI IDA.  Code for this merging process is within the [subtyper package](https://stnava.github.io/subtyper/) specifically the function [merge_ppmi_imaging_clinical_demographic_data](https://stnava.github.io/subtyper/reference/merge_ppmi_imaging_clinical_demographic_data.html).  The M3RI IDPs are described in detail [here](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html) and are in a data table within the `ANTsPyMM` repository (csv format).  The full tabular IDPs for both OR and SR outputs are at [this location](https://figshare.com/articles/dataset/PPMI_MR_IDPs/25361071).

We supplement these PPMI data with subjects from ADNI due to the current dearth of control longitudinal neuroimaging in PPMI.  As with PPMI, we attach ANTsPyMM IDPs to `ADNIMERGE_10Feb2024` using the `subtyper` function `merge_ADNI_antspymm_by_closest_date`.  Select subjects from ADNI are considered for merging with PPMI if they are not diagnosed wtih Alzheimer's disease or mild cognitive impairment (MCI) and have acceptable quality neuroimaging. The ADNI cohort is significantly older (mean of 72.3 years versus 63.9 in PPMI).

We also train a regression model on the matched subjects to adjust imaging variables for systematic differences dut to study populations (ADNI vs PPMI), MRI manufacturers ('GE', 'Philips', 'Siemens') and magnetic field strength. Control subjects aged between 50 and 70 are designated as training samples.  The regression map is learned and applied to each IDP throughout the full cohort using the `subtyper` function `adjustByCovariates`.  The purpose of this process is to mitigate the influence of different imaging protocols, ensuring that subsequent analyses are less confounded by these factors.  This approach has been used in practical studies of ADNI MRI data [@Risacher2017].  These merged and adjusted IDP data records are included in the file `ppmi_idps_trim_v1.4.0_SRF.csv`. SiMLR derived variables are denoted `t1PC*` (left-right averaged T1w derived feature sets), `t1aPC*` (asymmetry-related T1w derived feature sets), `dtPC*` (left-right averaged DTI derived feature sets), `dtaPC*` (asymmetry-related DTI derived feature sets) and `rsfPC*` (resting connectivity) where the `*` varies from 1 to 100.  These SiMLR derived variables limit the multiple testing considerations to 100 variables because these are typically grouped together.  That is, a given PC set (referred to as $simIDP_i^k$) is included in a single model (e.g. if $k=1$, then $age \approx t1PC1 + t1aPC1 + dt1PC1 + dtaPC1 + rsfPC1$) where $simIDP_1=t1, simIDP_2=t1a$, etc.  We use this approach in a technical validation section below.

# Technical Validation

Components of technical validity that are critical for quantitative methodology in neuroimaging include: (a) generally robust performance across modalities; (b) multi-site reproducibility; (c) disease-specific discrimination from controls in particular over time in the clinical trial setting; (d) sensitivity to or relationship with changes in clinically relevant symptoms at baseline and/or over time.  We provide evidence that the current IDPs satisfy these properties in the following sections.  

* We quantify reproducibility and reliability in each modality through analysis of three traveling subject cohorts (addressing (a) and (b) above). These cohorts collect imaging data at different sites from the same individuals.  Reliability data based on such cohorts are highly relevant for multisite trials which are always impacted by site-specific variation.  By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) manifested across different scanner types and imaging modalities.  

* We derive effect sizes from statistical models that test established hypotheses comparing biomarker classified PD subjects versus control subjects.  These show expected effects of PD are detectable in these data.  This addresses (c) above.

* We finalize the technical validity section with examples of how scientists may relate IDP measures of brain health to rate of symptom change in PD in a multiple modality (integrative) context.  This addresses (d) above.

The scale of the current data supports control for a subset of important PD relevant covariates including disease duration, educational level, sex, age and levodopa dose equivalent daily dose (LEDD).  These variables are included in reference models with additional details below.

## Robust performance

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges [@menze_multimodal_2015;@murphy_evaluation_2011;@baheti_brain_2021] that span modalities and organ systems.  The foundational methods also support applications to non-human data [@allan_johnson_whole_2019;@hopkins_regional_2013-1].  Furthermore, the consistency of the methodology naturally enables multivariate statistical inference and/or prediction [@stone_neurological_2023] even within the multi-study context [@dadu_prediction_2024].

## Multi-site reproducibility

Traveling subject studies involve scanning the same subjects on multiple MRI scanners at different locations. These studies help in assessing consistency and/or agreement of image quantification where the only variables are the machines themselves. This is crucial for understanding power in multi-site studies of natural history or intervention and for ensuring that the observed changes in brain structure or function are due to actual physiological changes rather than variations in the imaging process itself. 

In this study, we employ traveling cohort data [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] to assess the agreement of IDPs pooled across multiple sites for the purposes of statistical inference. These data will establish expectations of repeatability for T1w, DTI and rsfMRI as measured by ANTsPyMM processing and are described briefly here:  

1. the SRPBS Traveling Subject MRI Dataset [@tanaka_multi-site_2021]:

  * 9 healthy subjects travel to 12 sites to be imaged;

  * of the 12 sites, 9 have consistently available T1w and rsfMRI in 6 subjects.

2. traveling subject DTI cohort [@tong_reproducibility_2019]:

  * 3 healthy subjects travel to 4 sites to be imaged;

  * T1w and multi-shell DWI/DTI are available.

3. Hawco's traveling subject MRI dataset [@hawco_longitudinal_2022] is available [here](https://openneuro.org/datasets/ds003011):

  * 4 healthy male subjects travel to 6 sites to be imaged with T1w, rsfMRI and DTI.

Thus, we use these data to characterize the consistency and reliability of these tools when applied to data that has known systematic biases due to site and scanner differences.  The results confirm that findings and conclusions drawn from ANTsPyMM are reliable and not overwhelmed by scanner-specific differences or inconsistencies.  This knowledge is critical for a foundational framework such as ANTsX/ANTsPyMM upon which scientific studies, machine learning platforms and other methodological comparisons are based. These cohorts represent variability in both MRI manufacturer and MRI model (high variability) that would exceed standard (within-scanner, within-site) test-retest analysis.  Results therefore provide a lower-bound on reliability; i.e. within-site (e.g. longitudinal) studies would be expected to have higher reliability in general.

![Summary reproducibility results from aggregated traveling subject data. T1 IDPs represent high reproducibility in all categories (cerebellum, CIT168, cortical volume, cortical thickness, basal forebrain and medial temporal lobe).  DTI IDPs are also highly reproducible with FA in the cortical gray matter (gm) nearly equaling that of major white matter regions in the JHU atlas. Resting state connectivity shows good to excellent reproducibility; PerAF, fALFF and ALFF are relatively less reproducible -- on average -- though variability across regions is also high.](../figs/antspymm_repro.png)



We employ the intra-class correlation to assess results.  ICC ranges may be interpreted as [@koo_guideline_2016]:

* below 0.50: poor

* between 0.50 and 0.75: moderate

* between 0.75 and 0.90: good

* above 0.90: excellent

We find that ANTsPyMM IDPs derived from the same subjects imaged at different sites with MRI from various manufacturers show overall good to high reliability with a few exceptions within resting state derivatives (fALFF specifically).  This provides empirical evidence that multiple modality MRI may be used to derive quantitative phenotypes on which predictive models may be based.  Statistical control for site effects should still be applied at the population level using, for example, random effects.  The data and code for reproducing these results is available in [this location](https://github.com/stnava/antspymm_reproducibility).  Figure 7 shows the key summary output for this ICC comparison.  


```{r pkgs,echo=FALSE,eval=TRUE,message=FALSE,cache=TRUE}
set.seed( 0 )
library(plyr)
library(ggplot2)
library( GoodmanKruskal )
library(forcats)
library(heatmap3)
library(permute)
library(interactions)
library(reghelper)
library(MGMM) # GMM methods 
library(WeightedCluster) # cluster quality 
library(tidyverse)
library(clValid)
library( cluster.datasets )
library(magrittr)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ggfortify)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="latex" )
tblcmd = ztable
```

```{r functions,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,cache=FALSE}

normalizersfmri = function( dd, applyit='none' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,cache=FALSE}
if ( ! exists( "is_test" ) ) is_test = FALSE
```

## Diagnostic effects in pre-defined structural, white matter and resting functional measurements

```{r quicklmdxsetup,echo=FALSE,eval=TRUE,fig.width=9,fig.height=6,warning=FALSE,message=FALSE}
######################################################################
num=c(122,129,134)[2] # resting state protocol numbers ###############
######################################################################
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|commonID)+ (1|imaging_protocol) + commonEdu +  age_BL + commonSex + brainVolume_BL "
raneffstr = " (1|commonID) + (1|SITE) " 
raneffstr = " (1|commonID) + (1|imaging_protocol)" 
raneffstr = " (1|commonID) " 
dxform=paste( raneffstr, " + noise + ssim + T1Hier_evratio + age_BL + commonSex " )
dxform=paste( raneffstr, "  + age_BL + commonSex " )
# dxform="  (1|commonID) + (1|SITE) + age_BL + commonSex "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_max + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
dxsel2 = ppmitrim$DXSubAsyn %in% c(
  negate, posate, ispd )
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
mydog = areunique(ppmitrim)
mydog$imaging_protocol = factor( mydog$imaging_protocol )
mydog=highestQualityRepeat(mydog,'commonID','yearsbl','T1Hier_resnetGrade')
ysel = mydog$yearsbl <= 4.5 # & mydog$age_BL <= 75
mydog = mydog[ mydog$studyName %in% c('PPMI','ADNI') & ysel, ]
mydog = normalizersfmri( mydog )
mydog = highestQualityRepeat( mydog, 'commonID','yearsbl','T1Hier_resnetGrade' )
mydog$joinedDX <- fct_relevel(mydog$joinedDX, "CN")
mydog$DXSubAsyn <- fct_relevel(mydog$DXSubAsyn, "CNNegative")
###############################################
###############################################
mydog$TDX = NA #as.character( mydog$DXSubAsyn )
selcn=subtyper::fs(mydog$AsynStatus == 'Negative' & mydog$joinedDX == 'CN') 
mydog$TDX[ selcn ]='CN'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDLRRK2Positive') ]='PDLRRK2+'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDLRRK2Negative') ]='PDLRRK2-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDGBAPositive') ]='PDGBA+'
# mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDGBANegative') ]='PDGBA-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDSporadicPositive') ]='PDSp+'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'ProdromalSporadicPositive') ]='PASp+'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'ProdromalSporadicNegative') ]='PASp-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDSporadicNegative') ]='PDSp-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'PDSporadicNegative') ]='PDSp-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'MCINegative') ]='MCI-'
mydog$TDX[ subtyper::fs(mydog$DXSubAsyn  == 'MCIPositive') ]='MCI+'

subjectcount = table( mydog$commonID )
# mysubs = names(  subjectcount > 1 )
# mydog = mydog[ mydog$commonID %in% mysubs , ]
xcl = c( antspymm_nuisance_names(), '_adjusted' )
rsfnames = c( 
  getNamesFromDataframe( c("rsf","LRAVG",num,'_falff'), mydog, exclusions=xcl ),
  getNamesFromDataframe( c("rsf","Asym",num,'_falff'), mydog, exclusions=xcl ) )
rsfnamescnx = c( 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","efaul"),  ppmitrim, exclusions=xcl ), 
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","Vis","imbi"),  ppmitrim, exclusions=xcl ),   
  getNamesFromDataframe( c(paste0("rsfMRI_fcnxpro",num),"_2_","efaul","imbi"),  ppmitrim, exclusions=xcl )
  )
rsfnamescnx = getNamesFromDataframe( c( 
    paste0("pro",num), "_2_" , "SomMot" ), 
    ppmitrim, exclusions=c(xcl,'efaul','Dors','SalVe','imbi')  )
rsfnamescnx = rsfnamescnx[ grep("rsfMRI_fcnxpro129_SomMot", rsfnamescnx) ]
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','Limbic'),  ppmi, exclusions=xcl ),
#  getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_",num,'SomMot','SalVent'),  ppmi, exclusions=xcl ) )
dtinames = getNamesFromDataframe( c("DTI_"), ppmitrim, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmitrim,exclusions=c('_adjusted','_BL',"_delta")  )
# idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), mydog,exclusions=c('_adjusted','_BL',"_delta") ),
  getNamesFromDataframe( c("DTI","Asym"), mydog,exclusions=c('_adjusted','_BL',"_delta") ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),mydog, exclusions=c("left","right",'adjusted')), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),mydog, exclusions=c("left","right",'adjusted')) )
######################################
# print( table( mydog[,dxvar]))
vars2bl = unique( c( nmstotest2, idpst1, rsfnamescnx, rsfnames, dtinamesasymlr, 'hy', 'brainVolume' ) )
mydog = fillBaselineColumn( mydog,
        vars2bl,
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX == 'CN' ]=0
mydog$hy_BL[ is.na( mydog$hy_BL ) & mydog$joinedDX != 'CN' ]=2
mydog$hy_BL = factor( mydog$hy_BL )
######################################
motname = paste( "1 + ",
#      paste0( "rsfMRI_fcnxpro",num,"_minutes_censored_data"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_bold_evr"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_max") )
motnamedt = "dt_total_timepoints + DTI_dti_fa_evr  + DTI_dti_FD_max + DTI_dti_ssnr_dwi_mean"
motnamedt = "DTI1_dimt + DTI1_dti_bvalueMax + DTI_dti_fa_evr  + DTI_dti_FD_max  "
motnamedt = "DTI_dti_FD_max  "
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
#  nmstotest = idpst1[ multigrep( c("dktcortex","thk"),idpst1,intersect=T)]
#  nmstotest = sample( nmstotest, 4 )
  mycorr='none'
}
# decide on some really good regions to test/show
ctx = c( "T1Hier_vol_Asym_superior_parietaldktcortex", "T1Hier_vol_Asym_inferior_parietaldktcortex", 
getNamesFromDataframe( c("vol","Asym", "dktcortex","entral"),mydog,exclusions=c('_adjusted','_BL',"_delta"))
 ) # need ref
snc = c( "T1Hier_vol_mtg_sn_snc_Asymdeep_cit168",   
  "T1Hier_vol_bn_str_pu_Asymdeep_cit168", 
#  "T1Hier_vol_bn_str_ca_Asymdeep_cit168", 
  "T1Hier_vol_bn_gp_gpi_Asymdeep_cit168", 
  "T1Hier_vol_bn_gp_gpe_Asymdeep_cit168", 
  'T1Hier_midbrain_pons_ratio',
  getNamesFromDataframe( c("vol","Asym", "nbm"),mydog,exclusions=c('_adjusted','_BL',"_delta")),
  getNamesFromDataframe( c("vol","Asym", "mtl",'ca3'),mydog,exclusions=c('_adjusted','_BL',"_delta") ) )

dtivars = c( "superior_longitudinal_fasciculus", "_snc", 
  "superior_corona_radiata", "fornix", "_capsule", 
#  "parahippocampal", 
  "str_pu")
nmstotest = c( ctx, snc )
apriori_targets = unique( c( 
  nmstotest, 
  gsub("Asym","LRAVG",nmstotest), 
  dtinamesasymlr[ multigrep( dtivars, dtinamesasymlr )],
  rsfnamescnx ) )



```


```{r predefregions,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE}
idpids = apriori_targets[ multigrep( c("LRAVG",'ratio',"rsfM"), apriori_targets)]
myregions = data.frame( IDP=shorten_pymm_names(idpids))
myregions$modality[ grep("rsf", myregions$IDP)]='rsfMRI'
myregions$modality[ grep("dti", myregions$IDP)]='DTI'
myregions$modality[ grep("t1", myregions$IDP)]='T1w'
myregions2=myregions
rownames(myregions2)=NULL
myregions2T1 = myregions2[ myregions2$modality == 'T1w', ]
rownames(myregions2T1)=NULL
myregions2DTI = myregions2[ myregions2$modality == 'DTI', ]
rownames(myregions2DTI)=NULL
myregions2RSF = myregions2[ myregions2$modality == 'rsfMRI', ]
rownames(myregions2RSF)=NULL
myregions2T1$anat= c(
  "Superior Parietal Cortex",
  "Inferior Parietal Cortex",
  "Paracentral Cortex",
  "Postcentral Cortex",
  "Precentral Cortex",
  "Substantia Nigra Compacta",
  "Basal Nucleus Striatum, Putamen",
  "Globus Pallidus Internal Segment",
  "Globus Pallidus External Segment",
  "Nucleus Basalis Meynert, Anterior Basal Forebrain",
  "Nucleus Basalis Meynert, Middle Basal Forebrain",
  "Nucleus Basalis Meynert, Posterior Basal Forebrain",
  "Dentate Gyrus, CA3 Region of Medial Temporal Lobe",
  "Midbrain Pons ratio"
#  "Medulla Brainstem",
#  "Pons Brainstem"
)
myregions2RSF$connectivity <- c(
  "Temporal Parietal Region",
  "Control Network Component C",
  "Control Network Component B",
  "Control Network Component A",
  "Somatomotor Area B",
  "Somatomotor Area A",
  "Peripheral Visual Area",
  "Central Visual Area",
  "Striatum",
  "Dopaminergic system",
  "Basal Ganglia",
  "Midbrain",
  "Temporal Parietal Region",
  "Control Network Component C",
  "Control Network Component B",
  "Control Network Component A",
  "Somatomotor Area B",
  "Somatomotor Area A",
  "Peripheral Visual Area",
  "Central Visual Area",
  "Striatum",
  "Dopaminergic system",
  "Basal Ganglia", 
  "Midbrain"
)
myregions2DTI$anat =  c(
  "Superior Longitudinal Fasciculus FA",
  "Superior Longitudinal Fasciculus Mean MD",
  "Deep Substantia Nigra Compacta FA",
  "Substantia Nigra Compacta FA",
  "Deep Substantia Nigra Compacta Mean MD",
  "Substantia Nigra Compacta Mean MD",
  "Superior Corona Radiata FA",
  "Superior Corona Radiata Mean MD",
  "Fornix FA",
  "Fornix Mean MD",
  "Anterior Internal Capsule FA",
  "External Capsule FA",
  "Posterior Internal Capsule FA",
  "Retrolenticular Part of Internal Capsule FA",
  "Superior Frontal-Occipital Fasciculus FA",
  "Anterior Internal Capsule Mean MD",
  "External Capsule Mean MD",
  "Posterior Internal Capsule Mean MD",
  "Retrolenticular Part of Internal Capsule Mean MD",
  "Superior Frontal-Occipital Fasciculus Mean MD",
  "Deep Basal Nucleus Striatum, Putamen FA",
  "Basal Nucleus Striatum, Putamen FA",
  "Deep Basal Nucleus Striatum, Putamen Mean MD",
  "Basal Nucleus Striatum, Putamen Mean MD"
)


myregionszT1z=ztable(myregions2T1[,c('IDP','anat')],tabular=TRUE,size=2,caption='Table 2. PD IDPs in ANTsPyMM: T1w L/R average and asym.',zebra=TRUE)
myregionszRSFz=ztable(myregions2RSF[,c('IDP','connectivity')],tabular=TRUE,size=2,caption='Table 4. PD IDPs in ANTsPyMM: rsfMRI bilateral inter or intra-network connectivity  (Yan, et. al. homotopic parcellation nomenclature).',zebra=TRUE)
myregionszDTIz=ztable(myregions2DTI[grep("dti.fa",myregions2DTI$IDP,fixed=TRUE),c('IDP','anat')],tabular=TRUE,size=2,caption='Table 3. PD IDPs in ANTsPyMM: DTI L/R average and asym for both fractional anisotropy (FA) and mean diffusion (MD) (not shown).',zebra=TRUE)
# print(myregionszRSFz, type = "latex",size=2,caption=mycap,sidewaystable=FALSE)
# myregions %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
#
# parallelTables(width=c(0.3,0.3,0.3),list(myregionszT1z,myregionszDTIz,myregionszRSFz),type="latex")
#
```


```{r predefregions1,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,results='asis'}
print(myregionszT1z, type = "latex",size=4,caption='Table 2. PD IDPs in ANTsPyMM: T1w L/R average and asym.',sidewaystable=FALSE,zebra=TRUE)
```

```{r predefregions2,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,results='asis'}
rsfcap='Table 4. PD IDPs in ANTsPyMM: rsfMRI bilateral inter or intra-network connectivity  (Yan, et. al. homotopic parcellation nomenclature).'
dticap='Table 3. PD IDPs in ANTsPyMM: DTI L/R average and asym for both fractional anisotropy (FA) and mean diffusion (MD) (not shown).'
print(myregionszDTIz, type = "latex",size=4,caption=dticap,sidewaystable=FALSE,zebra=TRUE)
```

```{r predefregions3,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,results='asis'}
print(myregionszRSFz, type = "latex",size=4,caption=rsfcap,sidewaystable=FALSE,zebra=TRUE)
maxy=2.25
```

```{r quicklmdx,echo=FALSE,eval=!exists("mydogU"),fig.width=8,fig.height=4.5,warning=FALSE,message=FALSE,fig.cap='Partial regression plots for example significant IDPs illustrate the trends of differences from controls.  The bar plots at left show 95 percent confidence intervals for estimated means of each group.  The line plots at right show the estimated change over time (baseline to `r maxy` years) along with 95 percent confidence intervals.  Table 6 and 7 detail the associated significance levels and effect sizes.'}
###################

library(lme4)

# Define the control parameters
ctrl <- lmerControl(
  optimizer = "bobyqa",  # Use the bobyqa optimizer
  optCtrl = list(maxfun = 100000),  # Increase the maximum number of function evaluations
  check.nobs.vs.nRE = "ignore",  # Ignore the check for number of observations vs. number of random effects
  check.conv.grad = .makeCC("warning", tol = 1e-4),  # Check for convergence of the gradient
  check.conv.singular = .makeCC("ignore", tol = 1e-4) )
ctrl <- lmerControl(
  optimizer = "bobyqa",  # Use the bobyqa optimizer
  optCtrl = list(maxfun = 100000),  # Increase the maximum number of function evaluations
  check.nobs.vs.nRE = "ignore",  # Ignore the check for number of observations vs. number of random effects
  check.conv.grad = .makeCC("warning", tol = 1e-4)  )

###################
mydog$TDX[ mydog$joinedDX %in% c("CN")]='CN'
# mydog$TDX[ mydog$joinedDX %in% c("MCI")]='CN'
mydog$TDX[ mydog$joinedDX %in% c("SMC")]='CN'
mydogU = mydog# [ mydog$joinedDX != 'AD', ]
mytab = table( mydogU$studyName )
frac = 0.99
ns = round( c( frac * mytab['ADNI'] , frac * mytab['PPMI'] ) )
mydogU <- subset_and_combine_studies(
  df = mydogU, 
  study_column = "studyName", 
  study_names = c("ADNI", "PPMI"), 
  grade_column = "T1Hier_resnetGrade", 
  k_values = ns # rgT1[1:2]
)
#############################################
mydogU$age_BL=antsrimpute(mydogU$age_BL)
mydogU$MOCA=antsrimpute(mydogU$MOCA)
mydogU$studyNameNum=0
mydogU$studyNameNum[mydogU$studyName=='ADNI']=1
mydogUa=mydogU[ na2f(mydogU$studyName == 'ADNI' & mydogU$age_BL <= 75.0), ]
# mydogUa=mydogU[ na2f(mydogU$studyName == 'ADNI' ), ]
mydogUp=mydogU[ na2f(mydogU$studyName == 'PPMI'), ]
mydogUa2=match_data_frames( mydogUp[mydogUp$yearsbl==0,], mydogUa[mydogUa$yearsbl==0,], c("age_BL",'commonSex','MOCA'))
mydogU=rbind(mydogUa[ mydogUa$commonID %in%  mydogUa2$commonID, ],mydogUp)
mydogU$roundyears = round( mydogU$yearsbl )
# print( paste("After matching: ",rsq::rsq(glm( studyNameNum ~ age_BL + commonSex+ MOCA, data=mydogU)) ))
t.test( mydogU$age_BL[mydogU$studyName=='ADNI' & mydogU$yearsbl==0], 
    mydogU$age_BL[mydogU$studyName=='PPMI'& mydogU$yearsbl==0] )
# summary(glm( studyNameNum ~ age_BL * commonSex, data=mydogU))
mydogU$SITE2=paste0(mydogU$SITE,mydogU$studyName)
mydogU[ is.na(mydogU$LEDD),'LEDD']=0
mydogU[ is.na(mydogU$duration_yrs),'duration_yrs']=0
dxform="  (1|commonID) + stats::poly(age_BL,2) + commonSex  + yearsbl "
dxform=" (1|SITE2) + (1|commonID) + age_BL + commonSex  + yearsbl "
##############
for ( y in 0:4 ) {
#  print( y)
#  print(table( mydogU$TDX[ mydogU$roundyears==y ], mydogU$imaging_protocol[ mydogU$roundyears==y ] ))
  }
dxform=" (1|commonID) + (1|SITE2) + age_BL + commonSex  + yearsbl "
simplerlm=TRUE
simplerlm=FALSE
dxglist=list()
dxdfT1=data.frame()
nms2viz = c("t1.vol.sncdp.", "t1.vol.bn.gp.gpidp.","dti.fa.lateral.occipital","dti.mean.md.uncinate.fasciculus.asym","t1.vol.asym.insula.ctx")
nms2viz = c("t1.vol.sncdp.", "t1.vol.bn.gp.gpidp.","t1.vol.bn.str.pu.asymdp.","dti.fa.sup.cor.rad","rsf.p2.sommotb.2.striatum")
nms2viz = c("t1.vol.sncdp.", "t1.vol.bn.str.pudp.", "dti.fa.deep.snc", "rsf.p2.sommotb.2.striatum")
for ( voi in apriori_targets ) {
  n=nrow(dxdfT1)+1
  if ( n %% 20 == 0 ) gc()
  vois = paste0( voi, c("_BL", "_delta" ) )
  othdxform=dxform
  if ( antspymm_vartype(voi) == "T1" ) {
    othdxform=paste0("(T1wQC1+T1wQC2+T1wQC3+T1wQC4)+",dxform)
    if ( simplerlm )
      othdxform=dxform
  }
  selector=rep(TRUE,nrow(mydogU))
  if ( antspymm_vartype(voi) == "NM2DMT" ) {
    selector = selector & subtyper::fs( 
      mydogU$NM2DMT_NM_substantianigra_z_coordinate >= 0.3 &
      mydogU$NM2DMT_NM_substantianigra_z_coordinate <= 0.8 )
    othdxform=paste0("NM2DMT_NM_evr+NM2DMT_NM_q0pt10+NM2DMT_NM_q0pt90+NM2DMT_NM_midbrainROI_mean+NM2DMT_NM_substantianigra_z_coordinate+",dxform)
    othdxform=paste0("NM2DMT_NM_evr+
      NM2DMT_NM_q0pt05+NM2DMT_NM_q0pt95+
      NM2DMT_NM_q0pt10+NM2DMT_NM_q0pt90+
      NM2DMT_NM_substantianigra_z_coordinate+",dxform)
    othdxform=paste0("NM2DMT_NM_midbrainROI_mean+",dxform)
    othdxform=gsub("studyName","1",othdxform)
  }
  if ( antspymm_vartype(voi) == "rsfMRI" ) {
    if ( grepl("pro122",voi ) ) fnum='122' 
    if ( grepl("pro129",voi ) ) fnum='129' 
    if ( grepl("pro134",voi ) ) fnum='134' 
    othdxform=paste0("(rsfQC1+rsfQC2+rsfQC3+rsfQC4)+",motname,"+rsfMRI_fcnxpro",fnum,"_minutes_original_data+rsfMRI_fcnxpro",fnum,"_minutes_censored_data+",dxform)
    if ( simplerlm )
      othdxform=paste0(motname,"+rsfMRI_fcnxpro",fnum,"_minutes_original_data+rsfMRI_fcnxpro",fnum,"_minutes_censored_data+",dxform)
    selector = selector & subtyper::fs( mydogU$rsf1_ol_loop  <= 0.5 &
      mydogU$rsfMRI_fcnxpro129_FD_mean <= 0.5 )
  }
  if ( antspymm_vartype(voi) == "DTI" ) {
    othdxform=paste0("(DTIQC1+DTIQC2+DTIQC3+DTIQC4)+",motnamedt,"+",dxform)
    if ( simplerlm )
      othdxform=paste0(motnamedt,"+",dxform)
    selector = selector & subtyper::fs( mydogU$DTI1_ol_loop  <= 0.5 &
      mydogU$DTI_dti_FD_mean <= 5 )
  }
  covarsX = paste("brainVolume_BL+commonEdu+duration_yrs+", othdxform)
  covarsX = paste("brainVolume_BL+commonEdu+", othdxform)
  temp =gsub("(1|commonID) +","",covarsX,fixed=T)
  temp =gsub("(1|imaging_protocol)  +","",temp,fixed=T)
  temp =gsub("(1|SITE2) +","",temp,fixed=T)
  temp =gsub("+ yearsbl","",temp,fixed=T)
  bform = paste( voi, " ~ ", covarsX )
  bformL = paste( bform, " + ", dxvar  )
  newform = paste( bform, " * ", dxvar  )
  dxs=c( "CN", 'MCI'  , "PDSp-","PDSp+" )
  dxs=c( "CN", "PDSp-", "PDSp+" )
  selector= selector & complete_cases_from_equation( mydogU, newform) & mydogU$yearsbl <= maxy & 
    mydogU$imaging_protocol %in% c( "1", "2", "3") &  # ADNI unselected deselected if we exclude 3
    mydogU$TDX %in% dxs
  if ( grepl("Asym", voi) )
    mydogU=truncatehi(mydogU,voi,t=4,removeit=FALSE)
  temp2 = select_longitudinal_subjects( mydogU[selector,],  'commonID', 'roundyears', 2, baseline=0.0 )
  temp2$TDX=factor(temp2$TDX,levels=dxs)
  mydogUbl = mydogU[ mydogU$yearsbl == 0 & selector, ]
  mydogUbl$TDX=factor(mydogUbl$TDX,levels=dxs)
  resultsX = lm_anv_p_and_d( mydogUbl, voi, 'TDX', 
    temp, predictoroperator='+', verbose=F )
  temp2 = scale_variables_in_equation( temp2, newform, variables_to_exclude=c(voi,'yearsbl'))
#    temp2[,voi]=psych::winsor(temp2[,voi],tr=0.01)
  bmdl=lmer( bformL, data=temp2, control = ctrl ) #bobyqa
  mdl=lmer( newform, data=temp2, control = ctrl ) #bobyqa
  mycoffsx = resultsX$coefficients
  mycoffs = coefficients( summary( mdl ) )
  anvp = anova( bmdl, mdl )$Pr[2]
  dxdfT1[n,'voiraw']=voi
  dxdfT1[n,'voi']=voi
  dxdfT1[n,'n.base']=as.character(count_unique_subjects_per_diagnosis( mydogUbl, 'TDX','commonID', format_counts=T ))
  dxdfT1[n,'n.long']=as.character(count_unique_subjects_per_diagnosis( temp2, 'TDX','commonID', format_counts=T ))
  dxdfT1[n,'anv.x']=resultsX$model_comparison$Pr[2]
  dxdfT1[n,'anv']=anvp
  othercols=rownames(mycoffsx)[grep("TDX",rownames(mycoffsx))]
  othercolsnm=gsub("TDX","",othercols)
  dxdfT1[n,paste0("d.x.",othercolsnm)]=resultsX$effect_sizes[,1]
  dxdfT1[n,paste0("p.x.",othercolsnm)]=as.numeric(mycoffsx[ othercols, "Pr(>|t|)"])
  othercols = rownames(mycoffs)
  othercols=c( "yearsbl" , othercols[grep("TDX",othercols)] )
  othercolsnm=gsub("TDX","",othercols)
  othercolsnm=gsub(":",".",othercolsnm)
  ndf = length(unique(temp2$commonID))
  chnd = effectsize::t_to_d( mycoffs[ othercols, 't value'], rep(ndf,length(othercols))  )
  dxdfT1[n,paste0("d.",othercolsnm)]=chnd[,1]
  dxdfT1[n,paste0("p.",othercolsnm)]=as.numeric(mycoffs[ othercols, "Pr(>|t|)"])
  dxdfT1[n,'res']=myrez
  dxdfT1[n,'singular']=isSingular(mdl)
  if ( n == 1 ) {
    unqdx=as.character(levels(temp2$DXSubAsyn))
    dxcts=data.frame()
    for ( zzz in 1:length(unqdx) ) {
      zzzz=unqdx[zzz]
      dxsel = subtyper::fs(mydogUbl$DXSubAsyn == zzzz)
      ncn=length(unique(mydogUbl[dxsel,'commonID'] ))
      dxcts[zzz,'n.base']=ncn
      dxsel = temp2$DXSubAsyn == zzzz
      ncn=length(unique(temp2[dxsel,'commonID'] ))
      dxcts[zzz,'n.long']=ncn
    }
    rownames(dxcts)=as.character(unqdx)
    dxcts=dxcts[dxcts$n.base>0,]
    dxcts$nn=paste0(dxcts$n.base,"/",dxcts$n.long)
  }
  thosetoviz = c( "t1.vol.bn.str.pu.asym", "t1.vol.inf.parietal.ctx", "dti.mean.md.sup.l.fasc.asym","dti.mean.md.fornix.asym","t1.vol.nbm.antbf","rsf.defaulta.2.visperi",'t1.vol.bn.gp.gpe')
  thosetoviz = c( "t1.vol.inf.parietal.ctx", "dti.mean.md.sup.l.fasc.asym","dti.mean.md.ant.int.cap.asym","t1.vol.nbm.antbf" )
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( shorten_pymm_names(voi) %in% nms2viz ) {
#   anvp <= 0.05/length(nmstotest2) |  dxdfT1[n,'anv.x'] <= 0.05/length(nmstotest2) )  {
    coffcols = c("Estimate" ,  "t value"  ,  "Pr(>|t|)" )
#    print(  knitr::kable( data.frame(mycoffs[-1,coffcols]), "latex", booktabs = TRUE,       caption=shorten_pymm_names(voi)) %>%      kableExtra::kable_styling(latex_options = c("striped", "scale_down")) )

    anvpx = insight::format_p( dxdfT1[n,'anv.x'], digits=4 )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( shorten_pymm_names(voi), "omnibus : x ", anvpx, " : y ", anvp ) )
    voix=shorten_pymm_names(voi)
    mygg0 = jtools::effect_plot( resultsX$full_model,  !!sym('TDX'), interval=T, facet.modx=F, partial.residuals=FALSE ) + ggtitle(paste("X:",voix)) + labs(y = NULL) + theme(legend.position = "none") 
#    mygg1=( interactions::interact_plot( mdl,  'yearsbl', 'TDX', interval=T, facet.modx=F ) + ggtitle(paste("L:",voi)) + labs(y = NULL) + theme(legend.position = "top") )
    mygg2=( interactions::interact_plot( mdl,  'yearsbl', 'TDX', interval=T, facet.modx=T, plot.points=F, partial.residuals=FALSE  ) + ggtitle(paste("L:",voix)) + labs(y = NULL) + theme(legend.position = "top") )
#    mygg2=( prplot( mdl,  'yearsbl', 'TDX' ) + ggtitle(paste("L:",voix)) + labs(y = NULL) + theme(legend.position = "top") )
    dxglist[[ length(dxglist)+1 ]]=mygg0
    dxglist[[ length(dxglist)+1 ]]=mygg2
#    interactions::probe_interaction(mdl, pred = 'yearsbl', modx = 'TDX',confint=T, facet.modx=T, interval=T, main.title=ttl, y.label=shorten_pymm_names(voi), data=temp2 )$interactplot
    # plot( predictorEffects(resultsX$full_model,'TDX') [[2]], main=ttl,ylab=shorten_pymm_names(voi) )
#    mygg1 = plot( predictorEffects(mdl,'TDX*yearsbl')[[2]], main=paste("L:",voi),ylab=shorten_pymm_names(voi) )
#    dxglist[[length(dxglist)+1]]=mygg 
#    print(    )
#    print( dxglist[[length(dxglist)]] )
#    print( mygg )
#    Sys.sleep(1)
#    ( visreg::visreg( mdl, 'yearsbl' , 'TDX', main=ttl))
#    Sys.sleep(1)
#    print( mycoffs[-1,-c(1:3)] )
#    print(paste(shorten_pymm_names(voi),anvpx,anvp))
    grid.arrange( grobs=list( mygg0, mygg2 ), nrow=2, top=ttl )
#    print( interactions::interact_plot( mdl, 'yearsbl',  'TDX', main.title=ttl, interval=TRUE, plot.points =FALSE, facet.modx=TRUE, int.type = c("confidence", "prediction")[1], partial.residuals=F,y.label ='') )
#    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
#  mdlV=lme4::lmer( newform, data=temp3 )
#  ggnostic(mdlV, mapping = ggplot2::aes(color = TDX))
  }
}
#######
##########################################################
mycorr='fdr'
psel = subtyper::fs( p.adjust( dxdfT1$anv, mycorr ) <= .05 )
psel = psel | subtyper::fs( p.adjust( dxdfT1$anv.x, mycorr ) <= .05 )
##########################################################
if ( TRUE ) {
  pnames=colnames(dxdfT1)[ grep("p.",colnames(dxdfT1),fixed=TRUE)]
  dnames=colnames(dxdfT1)[ grep("d.",colnames(dxdfT1),fixed=TRUE)]
  ct=0
  for ( x in pnames ) {
    ct=ct+1
#    cat("\n\n*********************************")
#    print( x )
    psel = p.adjust( dxdfT1[,x], 'none' ) <= 0.05
    dname = dnames[ct]
#    dxdfT1[subtyper::fs(!psel),dname]=NA
#    print( dxdfT1$voi[psel] )
  }
}


```


```{r quicklmdxsetdown,echo=FALSE,eval=TRUE,fig.width=12,fig.height=14,warning=FALSE,message=FALSE,fig.cap='Partial regression plots for example significant IDPs illustrate the trends of differences from controls.  The bar plots at left show 95 percent confidence intervals along with estimated means for each group.  The line plots at right show the estimated change over time (0 to 4 years) along with 95 percent confidence intervals.  Table 5 and 6 detail the associated significance levels and effect sizes.'}
if ( length(dxglist) > 0  )
  grid.arrange( grobs = dxglist, ncol=2, top='Group differences in IPDs from controls.' )
```


## Sensitivity to differences from controls

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  MRI is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. Here, we assess longitudinal and cross-sectional effect sizes in T1w, DTI and rsfMRI IDPs that are pre-defined for PD relevance.  These regions are listed in Table 2 (T1w), Table 3 (DTI) and Table 4 (rsfMRI) and span motor, associative and limbic systems that may be impacted in PD and associated disorders [@ryman_mri_2020].  These include motor and parietal cortex [@filippi_progressive_2020;@sokolowski_longitudinal_2024], midbrain and striatal regions and basal forebrain [@batzu_increased_2023] from T1w.  Due to known concomitant, AD-related pathology in some PD subjects, we also include a medial temporal lobe IDP [@das_episodic_2019].  Relatedly, we select mean diffusion and FA derived from DTI in the striatum and substantia nigra [@hu_diffusion_2023] as well as major white matter tracts [@gattellaro_white_2009;@pietracupa_freezing_2018], the fornix and external and internal capsule; a recent large-scale study demonstrated sensitivity of these measures to PD [@owens-walton_worldwide_2024].  Interestingly, DTI metrics in early PD -- within both the current study and the recent worldwide study [@owens-walton_worldwide_2024] -- appear to trend in directions that are opposite to that of other neurodegenerative diseases which provides an interesting opportunity for future work and more nuanced stage-based statistical modeling.  In rsfMRI, we focus on connectivity between sensorimotor regions and other networks, in particular visual and cognitive control [@caspers_within_2021;@wang_investigation_2021;@tahmasian_systematic_2015].  In total, we test `r length(apriori_targets)` different measurements which include left-right averaged as well as asymmetry metrics:
$$
avg(x_l,x_r)=\frac{1}{2}(x_l+x_r);~~~asym(x_l,x_r)=|x_l-x_r|
$$
derived from those regions which are bilateral.  This strategy is a generalizable way of testing laterality effects across all groups, including those without an established dominant side of disease (controls and pre-symptomatic PD subjects).


<!--
Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), DTI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes including and beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

basal forebrain [in LRRK2](https://www.sciencedirect.com/science/article/pii/S0969996123001973)
-->

We provide exemplar linear mixed-effects models (LMMs) that seek to elucidate the complex relationships between neuroimaging biomarkers and the progression of Parkinson's Disease (PD).  The analytical framework was constructed using the `R` programming environment, leveraging the `lme4` package [@kuznetsova_lmertest_2017;@bates_fitting_2014]. This methodology allows for the exploration of hierarchical data structures commonly encountered in longitudinal neuroimaging studies, where multiple observations per subject are standard.  These models were designed to investigate differences between biomarker-confirmed PPMI PD groups and controls.  We accentuate that these models are for demonstration only and do not constitute fully-vetted "official" PPMI results.  While these models may not account for all relevant covariates, they do provide evidence of validity by confirming the sensitivity of these IDPs to diagnostic group differences.  These models are of the form:

$$
\begin{split}
\text{IDP } \approx (1|ID) + (1|Site) + \text{BV}_\text{bl} + Edu + duration_\text{yrs} + \\
  modality\_specific\_covariates  + age_\text{bl} + \\ 
  Sex_\text{bio}  + years_\text{bl}   *  \text{DX}
\end{split}
$$

where IDP is the imaging outcome, $ID$ is a random effect for subject ID, $Site$ is a random effect for data collection site, $\text{BV}_\text{bl}$ is baseline brain volume, $Edu$ is educational attainment and $modality\_specific\_covariates$ covaries for modality-specific variability due to site and related effects.  Age at baseline and biological sex are additional covariates.  The primary predictors of interest are $years_\text{bl}   *  \text{DX}$ i.e. the interaction between time from baseline of the IDP measurement (in years) and the diagnostic group which includes SAA positive and negative PD subjects in addition to controls and MCI.  The cross-sectional/longitudinal sample sizes and results for each group within the $DX$ variable are denoted in Table 5 (cross-sectional) and 6 (longitudinal) where a postfix of ".x" indicates a cross-sectional estimate and ".y" a longitudinal one.  The columns `anv.x` and `anv.y` reflect omnibus model $p$-values; `d` indicates effect size for the corresponding group either cross-sectionally or longitudinally. The `sig` column indicates whether the corrected $p$-value survives family-wise error (fwe) or false discovery rate (fdr) correction.  In the longitudinal cohort, subjects are required to have two or more visits.

Cross-sectional models used standard linear regression (`lm` in `R`) with the same structure as described above but without random effects.  Linear mixed-effects models (LMMs) were constructed using the `lmer` function from the `lme4` package and fitted to the data. This process included the standardization of variables within the equation, a critical step given the varying scales and distributions of neuroimaging metrics. Comparative model analysis was conducted to ascertain the significance of various predictors, employing the `anova` function to contrast models with and without $DX$ and the interaction between $DX$ and $years_\text{bl}$. This `anova` assesses the "omnibus" model improvement due to the joint addition of both $DX$ and the interaction between $DX$ and $years_\text{bl}$.  As we are only reporting high level results here, we do not investigate $p$-values within individual diagnostic groups.  These results are shown in Table 5 (for the $DX$ term) and Table 6 (for the longitudinal term).  Effect sizes (d.x and d.y) for each term are estimated from the $t-$value and degrees of freedom for each cross-sectional and longitudinal model.  Very small effect sizes are those with absolute value less than 0.2. The effects of $DX$ on these IDPs are visualized through predictor effect plots [@larsen_use_1972;@JSSv087i09] of diagnosis by time generated for each diagnostic category as in Figure 8.  These IDPs are significant under family wise error (fwe) multiple comparisons correction at $p$-value $\le$ 0.05 (after correction based on the above-mentioned `anova`).  These plots and other regression plots are displayed with the `R` packages [`jtools`](https://jtools.jacob-long.com) and [`interactions`](https://interactions.jacob-long.com).

```{r dxresults,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
if ( length( grep("snseg",dxdfT1$voi) ) > 0 ) {
    dxdfT1=dxdfT1[-grep("snseg",dxdfT1$voi),]
}
pselFDR = na2f( 
  p.adjust( dxdfT1$anv.x, 'BH' ) <= .05 | 
  p.adjust( dxdfT1$anv, 'BH' ) <= .05  )
pselFWE = na2f( 
  p.adjust( dxdfT1$anv.x, 'BY' ) <= .05 | 
  p.adjust( dxdfT1$anv, 'BY' ) <= .05  )
dxdfT1$sig.x=NA
dxdfT1$sig.y=NA
dxdfT1[p.adjust( dxdfT1$anv.x, 'BH' ) <= .05,'sig.x']='fdr.x'
dxdfT1[p.adjust( dxdfT1$anv.x, 'BY' ) <= .05,'sig.x']='fwe.x'
dxdfT1[p.adjust( dxdfT1$anv, 'BH' ) <= .05,'sig.y']='fdr.y'
dxdfT1[p.adjust( dxdfT1$anv, 'BY' ) <= .05,'sig.y']='fwe.y'
psel = pselFDR | pselFWE
dxdfT1sel = dxdfT1[psel,]
dxdfT1sel$voi = shorten_pymm_names( dxdfT1sel$voi )
dxdfT1sel = dxdfT1sel[ order( dxdfT1sel$anv ), ]
dxdfT1sel$anv = insight::format_p(  dxdfT1sel$anv, digits=4  )
dxdfT1sel$anv.x = insight::format_p(  dxdfT1sel$anv.x, digits=4  )
temp = colnames(dxdfT1sel)
temp = gsub("PD","",temp)
colnames(dxdfT1sel)=temp
dxdfT1selcols = colnames(dxdfT1sel)[ !(colnames(dxdfT1sel) %in% c("res","singular","voiraw"))]

dxdfT1selcolsB = dxdfT1selcols[ -grep("d.year",dxdfT1selcols,fixed=TRUE ) ]
dxdfT1selcolsB = dxdfT1selcolsB[ -grep("p.",(dxdfT1selcolsB),fixed=TRUE ) ]
dxdfT1selcolsB = dxdfT1selcolsB[ !(dxdfT1selcolsB %in% 
  c('anv', "n.long",  "d.MCI", "d.Sp-", "d.Sp+")) ]
dxdfT1selcolsY = c( dxdfT1selcols[c(1,3,5,length(dxdfT1selcols))], 
  dxdfT1selcols[ grep("d.year",dxdfT1selcols,fixed=TRUE ) ],'sig.x')
dxdfT1selcolsY = dxdfT1selcolsY[ !(dxdfT1selcolsY %in% 
  c('anv.x',  "d.MCI", "d.Sp-", "d.Sp+")) ]
# Print the ztable object, ensuring it's treated as LaTeX code

dxdfT1selBz=dxdfT1sel[, dxdfT1selcolsB]
dxdfT1selYz=dxdfT1sel[, dxdfT1selcolsY]
colnames(dxdfT1selYz)=gsub("yearsbl","y",colnames(dxdfT1selYz))

# baseline t1 top 20
topkstat=20
gg=grep("t1",dxdfT1selBz$voi)
dxdfT1selBzT1=head( dxdfT1selBz[ gg, ], topkstat )
ggdt=grep("dti",dxdfT1selBz$voi)
dxdfT1selBzDT=head( dxdfT1selBz[ ggdt, ], topkstat )
ggrs=grep("rsf",dxdfT1selBz$voi)
dxdfT1selBzRS=head( dxdfT1selBz[ ggrs, ], topkstat )

gg=grep("t1",dxdfT1selYz$voi)
dxdfT1selYzT1=head( dxdfT1selYz[ gg, ], topkstat )
ggdt=grep("dti",dxdfT1selBz$voi)
dxdfT1selYzDT=head( dxdfT1selYz[ ggdt, ], topkstat )
ggrs=grep("rsf",dxdfT1selBz$voi)
dxdfT1selYzRS=head( dxdfT1selYz[ ggrs, ], topkstat )
temp=rbind(dxdfT1selBzT1,dxdfT1selBzDT,dxdfT1selBzRS)
nmstemp=c("voi",     "n.base",  "anv.x",   "d.x.MCI", "d.x.Sp-", "d.x.Sp+",'sig.x','sig.y' )
nmstempw=which(nmstemp %in% colnames(temp))
nmstemp2=c("voi",     "n.x (CN,MCI,PD-,PD+)",  "anv.x",   "d.x.MCI", "d.x.Sp-", "d.x.Sp+",'sig.x','sig.y' )
nmstemp2=c("voi",     "n.x (CN,Sp-,Sp+)",  "anv.x",   "d.x.MCI", "d.x.Sp-", "d.x.Sp+",'sig.x','sig.y' )
temp[,nmstemp2[nmstempw]]=temp[,nmstemp[nmstempw]]
temp[is.na(temp$sig.y),'sig.y']='n.s.'
dxdfT1selz=ztable( temp[temp$sig.x %in% c("fdr.x","fwe.x"),nmstemp2[nmstempw]], zebra=2)
mycap='Significant (fdr based on omnibus model p-value) diagnostic group i.e. time independent effects in PPMI PD.  Empty cells represent small effects.'
mycap='Table 5. Time independent group effects in PPMI/ADNI. Top-k per modality.'
print(dxdfT1selz, type = "latex",size=2,caption=mycap,sidewaystable=TRUE)
# dxdfT1sel[, dxdfT1selcols] %>%
#  knitr::kable("latex", booktabs = TRUE, caption=mycap) %>%
#  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```


```{r dxresultslong,echo=FALSE,eval=buildsci,warning=FALSE,message=FALSE,results='asis'}
temp=rbind(dxdfT1selYzT1,dxdfT1selYzDT,dxdfT1selYzRS)
nmstemp=c("voi" ,    "n.long",  "anv",     "d.y",     "d.y.MCI", "d.y.Sp-", "d.y.Sp+",'sig.y', 'sig.x' )
nmstempw=which(nmstemp %in% colnames(temp))
nmstemp2=c("voi",    "n.y (CN,MCI,PD-,PD+)",  "anv.y",     "d.y",     "d.y.MCI", "d.y.Sp-", "d.y.Sp+",'sig.y', 'sig.x'  )
nmstemp2=c("voi",    "n.y (CN,Sp-,Sp+)",  "anv.y",     "d.y",     "d.y.MCI", "d.y.Sp-", "d.y.Sp+",'sig.y', 'sig.x'  )
temp[,nmstemp2[nmstempw]]=temp[,nmstemp[nmstempw]]
temp[is.na(temp$sig.x),'sig.x']='n.s.'
dxdfT1selz=ztable( temp[ temp$sig.y %in% c("fdr.y","fwe.y"),nmstemp2[nmstempw]],zebra=2)
mycap='Significant (fdr based on omnibus model p-value) longitudinal group effects in PPMI PD. Empty cells represent small effects.'
mycap='Table 6. Longitudinal group effects in PPMI/ADNI. Top-k per modality.'
print(dxdfT1selz, type = "latex",size=2,caption=mycap,sidewaystable=TRUE)
```


## Baseline IDP to longitudinal MDS-UPDRS effects in structural, white matter and resting functional measurements


```{r quicklmcog,echo=FALSE,eval=!exists("mydogp"),fig.width=8,fig.height=3,warning=FALSE,message=FALSE,fig.cap='Partial regression interaction plots show a representative region for each of the MDS-UPDRS outcomes that we test.  Each panel demonstrates how different levels of the IDP (x-axis) lead to different amounts of change over time. For example, the slope of the relationship btween MD asymmetry in the internal capsule and change in MDS-UPDRS2 score increases over time with the largest differences occuring at the right side of the top right panel.  This indicates that subjects with higher levels of baseline MD asymmetry in this IDP progress more rapidly on this score.'}
#########################################################
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
cogs = getNamesFromDataframe( c("updrs","score"), mydog, exclusions=c(4,'_BL',"_delta","_on") )
col2sbl = nmstotest2# unique(c( nmstotest2, idpst1, dtinamesasymlr, rsfnames, rsfnamescnx,  fdnames, cogs, nmstotest ))
mydogp = fillBaselineColumn( mydogU,
        col2sbl,
        'subjectID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
mydogp$hy_BL = factor( mydogp$hy_BL )
mydogp2=mydogp
mydogp2$roundyears = round( mydogp2$yearsbl )
mydogp2=highestQualityRepeat( mydogp2, 'commonID', 'roundyears', 'T1Hier_resnetGrade' )
# for ( cog in  cogs[ -grep("tot",cogs)]  ) {
cogtotest="updrs_totscore"
cogtotest='updrs3_score' #  "updrs_totscore"
# cogtotest='updrs2_score' #  "updrs_totscore"
cogtotest=c( "pigd", "scopa", 'updrs1_score','updrs3_score','updrs2_score') #  "updrs_totscore"
```


```{r simlr,echo=FALSE,eval=TRUE,fig.width=10,fig.height=5,message=FALSE,warning=FALSE,fig.cap="Resampled estimates of multi-view ML for predicting change in MDS-UPDRS scores based on three different modalities demonstrate improved expected peformance.  Vertical dashed lines show median performance.",cache=FALSE}
n.comp=100
simfile="~/Downloads/ppmi_pym_data/TESTUKB"
simfile="~/Downloads/ppmi_pym_data/NADA"
simfile="~/Downloads/ppmi_pym_data/NADATHK100"
simfile="~/Downloads/ppmi_pym_data/PPMISiMLRW100"
simfile="~/Downloads/ppmi_pym_data/PPMISiMLRW_new_ica100"
simfile="~/Downloads/ppmi_pym_data/PPMISiMLRW_new100"
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_new_ica_reg",n.comp)
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_new_pca_cca_cog",n.comp)
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_new_pca_cca",n.comp,'_rez',myrez)
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_fin_pca_cca",n.comp,'_rez',myrez)
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_fin_pca_lrr",n.comp,'_rez',myrez)
simfile = paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_fin_ica_reg",n.comp,'_rez',myrez)
simfile=paste0("~/Downloads/ppmi_pym_data/PPMISiMLRW_fin_LLR",n.comp,'_rezOR')
if ( ! file.exists( paste0(simfile,'_t1_simlr.csv') ) ) {
    coggers = c("ess",  "MOCA", "NP1APAT", "NP1DPRS", "pigd", "rem",  "scopa",  "updrs1_score", "updrs2_score", "updrs3_score", "updrs_totscore" )
    xcl='_bl'
    supervisors = c( 
        getNamesFromDataframe( c("MMSE"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("CDRSB"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("ADAS"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("PACC"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("RAVLT"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("FAQ"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("LDEL"), ppmitrim, exclusions=xcl),
        getNamesFromDataframe( c("TRAB"), ppmitrim, exclusions=xcl)
    )
    supervisors = c( supervisors, getNamesFromDataframe(c("Ecog"),ppmitrim,exclusions=c( '_bl') ) ) %>% unique()
    supervisors = supervisors[ -multigrep( c("RAVLT_learning", "RAVLT_forgetting","LDELTOTAL_BL","_bl"),supervisors)]

    vars3=c("T1Hier_resnetGrade","rsfMRI_fcnxpro129_VisCent_2_VisPeri","DTI_mean_fa_die_hth_LRAVG")
    issaapos = na2f( ppmitrim$CSFSAA == 1 )
    isav45pos = na2f( ppmitrim$AV45_bl >= 1.1 )
    mycc = complete.cases( ppmitrim[,c(vars3,supervisors)]) & 
      ppmitrim$T1Hier_resnetGrade >= 1.05
    # & ( isav45pos | issaapos )
    if ( FALSE )
      temp <- subset_and_combine_studies(
        df = ppmitrim[mycc,],
        study_column = "studyName",
        study_names = c("ADNI", "PPMI"),
        grade_column = "T1Hier_resnetGrade",
        k_values = c(1000,1000)
      ) else temp=ppmitrim[mycc,]
    table( temp$studyName )
    trainer = rep(TRUE,nrow(temp))
    nhk=16
    temppca=prcomp( temp[,supervisors], scale. =TRUE, rank.=nhk )
    colnames(temppca$x)=paste0('prcomp',1:nhk)
    temp = cbind( temp, temppca$x )
    mysimN = log_parameters(
        antspymm_simlr,
        logfile=path.expand(simfile),
        blaster=data.frame(temp), 
        select_training_boolean=trainer, 
        energy='lrr',
        nsimlr=n.comp,
        constraint='Grassmannx100x100',
        connect_cog=colnames(temppca$x),
        doAsym=2,
        iterations=35,
#        sparseness=0.90,
#        covariates=c( 'center', 'scale', 'lowrank', 'center', 'scale', 'np' ),
        covariates=c(  'center', 'scale', 'np' ),
        exclusions=c("fcnxpro134","fcnxpro122",'mean_md' ,'area','adjusted','delta',"_BL","PC",'reference'),
        returnidps=FALSE,
        path_modeling = simlr_path_models( 6, 0 ),
        verbose=T )
#    myvars=rep(NA,length(mysimN))
#    for ( k in 1:length(myvars)) myvars[k]=var(temp[,mysimN[k]],na.rm=T)
    write_simlr_data_frames( mysimN$simlrX$v, path.expand(simfile)  )
    rm( temp )
    gc()
}
```



```{r quicknnh,echo=FALSE,eval=!exists("qdfsignnh"),fig.width=14.625,fig.height=5,warning=FALSE,message=FALSE,fig.cap='SiMLR mapping between M3RI and PD symptomology.'}
qdfcols =  c("cog", "voi" , 'n', "anv.x", "anv", 'sig', othercolsnm)
#########################################################
coggersAll = c("ess", "gds", "lns", "MOCA", "NP1APAT", "NP1ANXS", "NP1DPRS", "pigd", "rem", "quip", "scopa", "stai", "VLTANIM", "updrs1_score", "updrs2_score", "updrs3_score", "updrs_totscore", 'ADAS13', 'hvlt_immediaterecall', 'FAQ', 'EcogPtTotal', 'EcogSPTotal' , 'MMSE' )
coggers = c("ess",  "MOCA", "NP1APAT", "NP1DPRS", "pigd", "rem",  "scopa",  "updrs1_score", "updrs2_score", "updrs3_score", "updrs_totscore", 'ADAS13', 'hvlt_immediaterecall', 'FAQ', 'EcogPtTotal', 'EcogSPTotal' , 'MMSE' )
coggers = c(  'MOCA',  "NP1APAT", "NP1DPRS", "pigd", "rem", "updrs1_score", "updrs2_score", "updrs3_score", "updrs_totscore" )
coggers = c(  'MOCA', "pigd", "rem", "updrs1_score", "updrs2_score", "updrs3_score", "updrs_totscore" )
presim=read_simlr_data_frames( path.expand(simfile), 
    c("t1","t1a", "dt", "dta", "rsf" ), verbose=TRUE )
npc = ncol(presim[[1]])
# npc = 2
# coggers = c( 'MOCA',  "updrs1_score", "updrs2_score", "updrs3_score"  )
mydogp = apply_simlr_matrices(  ppmitrim, presim, robust=FALSE, 
  center = TRUE, scale = TRUE,
  absolute_value=rep(TRUE,length(presim)) )[[1]]
mydogp$SITE2=factor(paste0(mydogp$SITE,mydogp$studyName))
nnhnames = apply_simlr_matrices(  mydogp, presim, robust=FALSE, absolute_value=rep(TRUE,length(presim)) )[[2]]
mydogp$roundyears = round( mydogp$yearsbl )
# mydogp$LEDD[ is.na(mydogp$LEDD) ]=0
# mydogp$duration_yrs[ is.na(mydogp$duration_yrs) ]=0
mydogp$hy[ is.na(mydogp$hy) ]=0
mydogp = fillBaselineColumn( mydogp,
        c(nnhnames,coggersAll,'hy'),
        'subjectID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
####################
stadnnh=data.frame()
cogglist=list()
cogglistnames=list()
nnhqth = 0.05 / ( npc * length(coggers) )
nnhqth = 1e-4
#########################
for ( voi in (1:npc) ) {
  for ( cog in sample(coggers) ) {
    n = nrow(stadnnh)+1
    vars3=paste0( names(presim), paste0( "PC", voi ))
    vars3f=paste("(",paste(vars3,collapse='+'),")")
    dxsel = c("PDSp+","PDLRRK2+","PDGBA+","PASp+","MCI")
    dxsel = c("PDSp-","PASp-","PDSp+","PASp+","MCI")
    dxsel = c("PDSporadic","PDSNCA","PDLRRK2","PDGBA", # "CN", # "MCI", 'SMC',
      'ProdromalGBA','ProdromalLRRK2','ProdromalSNCA','ProdromalSporadic' )
    covarsX="duration_yrs + LEDD + commonEdu + age_BL + commonSex + ( yearsbl )"
    covarsX=" imaging_protocol + commonEdu + LEDD + duration_yrs + age_BL + commonSex + ( yearsbl )"
    covarsX=" commonEdu + age_BL + commonSex + ( yearsbl ) "
    if ( cog %in% c("updrs_totscore", "updrs3_score"  , "pigd" ))
      covarsX=paste("LEDD + ",covarsX )
    redspns=paste0(cog,"_delta")
    cogformcommon=paste( redspns, "~ ",paste0(cog,"_BL"),"+(1|commonID)+(1|SITE2)+ ", covarsX )
    cogformcommon=paste( redspns, "~ ",paste0(cog,"_BL"),"+(1|commonID)+ ", covarsX )
    newform = paste( cogformcommon, " * ", vars3f )
    severity_selection = na2f( mydogp$updrs_totscore_BL <= 30 )
    severity_selection = na2f( mydogp$hy_BL %in% c(0, 1, 2) )
    mydogpnna=mydogp[ complete.cases( mydogp[,all.vars(as.formula(newform))] ) & 
      na2f( mydogp$DTI_dti_FD_mean <= 5 & mydogp$rsfMRI_fcnxpro129_FD_mean <= 0.5 ) &
      mydogp$imaging_protocol %in% c(1,2) & # no ADNI
      (mydogp$joinedDX %in% dxsel ) & severity_selection &
      mydogp$yearsbl <= maxy, ]
    mydogpnna=truncatehi(mydogpnna,paste0('t1aPC',voi),t=4,removeit=FALSE)
    mydogpnna=truncatehi(mydogpnna,paste0('dtaPC',voi),t=4,removeit=FALSE)
    topkval = round( 0.985 * nrow(mydogpnna) )
    mydogpnna = mydogpnna[ topk( mydogpnna, "T1Hier_resnetGrade", topkval), ] # quality selection
    mydogpnnaBase = mydogpnna[ mydogpnna$yearsbl == 0.0, ]
    mydogpnnaLong = select_longitudinal_subjects( mydogpnna, 'commonID', 'roundyears', 2, baseline=0.0 )
    if ( n == 1 ) {
      mycogn=count_unique_subjects_per_diagnosis( mydogpnnaBase, 'joinedDX',
      'commonID', format_counts=F )
      mycogn = paste( with(mycogn, paste(Diagnosis, Unique_Subjects, sep = ": ")), collapse=' / ' )
      mycognL=count_unique_subjects_per_diagnosis( mydogpnnaLong, 'joinedDX',
      'commonID', format_counts=F )
      mycognL = paste( with(mycognL, paste(Diagnosis, Unique_Subjects, sep = ": ")), collapse=' / ' )
    }
    if ( cog %in% c("NP1DPRS","NP1APAT") )
      mydogpnnaLong[,redspns]=as.numeric(mydogpnnaLong[,redspns]>0)
    resultsX = lm_anv_p_and_d( mydogpnnaBase, cog, vars3f, covarsX, predictoroperator='+', verbose=F )
    anvpx=resultsX$model_comparison$Pr[2]
    if ( nrow(mydogpnnaLong) > 10 ) {
      if ( sd( mydogpnnaLong$LEDD) == 0 ) {
        newform = gsub("+ LEDD","",newform)
        newform = gsub("+ duration_yrs","",newform)
      }
      mydogpnnaLong = scale_variables_in_equation( mydogpnnaLong, newform , 
        variables_to_exclude=c('yearsbl',vars3, cog, redspns ))
      mdl=suppressMessages(lmer( newform, data=mydogpnnaLong ))
      bmdl=suppressMessages(lmer( cogformcommon, data=mydogpnnaLong ))
      nlong = length(unique( mydogpnnaLong$commonID ))
      mycoffs = coefficients( summary( mdl ) )
      anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
      othercols=rownames(mycoffs)[ grep("PC",rownames(mycoffs))]
      chnd = data.frame( 
        effectsize::t_to_d( mycoffs[ othercols, 't value'], c(nlong,nlong) ))
      rownames(chnd)=othercols
      stadnnh[n,'cog']=cog
      stadnnh[n,'voi']=as.character(voi)
      stadnnh[n,'n.x']=resultsX$n
      stadnnh[n,'n.long']=nlong
      stadnnh[n,'anv.x']=anvpx
      stadnnh[n,'anv']=anvp
      othercolsnm=c("d.b","d.y")
      stadnnh[n,othercolsnm]=c(
        max(abs(resultsX$effect_sizes[,1])),
        max(abs(chnd[6:10,1]))
      )
      stadnnh[n,'res']=myrez
      stadnnh[n,'singular']=isSingular(mdl)
      if ( anvpx < anvp ) {
        mycoffs=( resultsX$coefficients[-1,c(3:4)]) 
        vars3xt=intersect(vars3,rownames(mycoffs))
        theorder = order(mycoffs[vars3xt,"Pr(>|t|)" ])
        mycoffsord=mycoffs[vars3xt,][theorder,]
        xviz = rownames(mycoffsord)[1]
        xviz2 = rownames(mycoffsord)[2]
        wmat = unlist( strsplit( xviz, 'PC') )
        wmat2 = unlist( strsplit( xviz2, 'PC') )
        n2show=2
        stadnnh[n,paste0("S_m1_",1:n2show)]=names(interpret_simlr_vector2( presim[[wmat[1]]] , paste0('PC',wmat[2]), n2show=n2show ))
        if ( mycoffsord[2,'Pr(>|t|)'] <= 0.01 ) {
          stadnnh[n,paste0("S_m2_",1:n2show)]=names(interpret_simlr_vector2( presim[[wmat2[1]]] , paste0('PC',wmat2[2]), n2show=n2show ))
        }
      } else {
        mycoffs=( mycoffs[-1,c(4:5)])
        vars3xt=paste0("yearsbl:",vars3)
        vars3xt=intersect(vars3xt,rownames(mycoffs))
        theorder = order(mycoffs[vars3xt,"Pr(>|t|)" ])
        mycoffsord=mycoffs[vars3xt,][theorder,]
        xviz = gsub("yearsbl:","",rownames(mycoffsord)[1])
        xviz2 =  gsub("yearsbl:","",rownames(mycoffsord)[2])
        wmat = unlist( strsplit( xviz, 'PC') )
        wmat2 = unlist( strsplit( xviz2, 'PC') )
        n2show=2
        stadnnh[n,paste0("S_m1_",1:n2show)]=names(interpret_simlr_vector2( presim[[wmat[1]]] , paste0('PC',wmat[2]), n2show=n2show ))
        if ( mycoffsord[2,'Pr(>|t|)'] <= 0.05 ) {
          stadnnh[n,paste0("S_m2_",1:n2show)]=names(interpret_simlr_vector2( presim[[wmat2[1]]] , paste0('PC',wmat2[2]), n2show=n2show ))
        }
      }
      c2viz = c( "updrs1_score48", "updrs3_score64","updrs2_score76")
      c2viz = c("NP1DPRS48", "updrs3_score55","updrs2_score50")
      c2viz = c("updrs3_score4", "MOCA33", "updrs_totscore50", "updrs_totscore55", "rem70", "NP1DPRS71")
      if ( paste0(cog,voi) %in% c2viz  | min(c(anvp,anvpx)) <  1e-5 ) {
#      if ( paste0(cog,voi) %in% c2viz  ) {
        cogdel = paste0(cog,"_delta")
        anvp = insight::format_p( anvp, digits=4 )
        anvpx = insight::format_p( anvpx, digits=4 )
        voix=paste0("SiMLR",voi)
        ttl=( paste(  voix, myrez, " + ", cog,  " X: o", anvpx,  " L: o", anvp ) )
        m1=compare_model_predictions( resultsX$base_model, resultsX$full_model, mydogpnnaBase, cog, annot_size=3 )
        m2=compare_model_predictions( bmdl, mdl, mydogpnnaLong, redspns, annot_size=3 )
        gglist=list()
        for ( k in 1:length(vars3)) 
            gglist[[length(gglist)+1]]=jtools::effect_plot( resultsX$full_model,  !!sym(vars3[k]), 
              interval=T, facet.modx=F, plot.points = F, partial.residuals=FALSE ) + ggtitle(paste("X:",vars3[k])) + theme(legend.position = "none") 
#        gglist[[length(gglist)+1]]=m1[[2]]
        for ( k in 1:length(vars3)) 
            gglist[[length(gglist)+1]]=( interactions::interact_plot( mdl,  'yearsbl', !!sym(vars3[k]), interval=T, facet.modx=F , plot.points = F, partial.residuals=FALSE,linearity.check = FALSE ) + ggtitle(paste("L:",vars3[k]))  + theme(legend.position = "none") )
#        gglist[[length(gglist)+1]]=m2[[2]]
        mlist = lappend( m1, m2 )
        cogglist[[length(cogglist)+1]] = ggplotify::as.ggplot( arrangeGrob( grobs=gglist , nrow=2, top=ttl ) )
#        cogglist[[length(cogglist)+1]] = ggplotify::as.ggplot( arrangeGrob( grobs=mlist , nrow=2, top=ttl ) )
        cogglistnames[[length(cogglist)]] = paste0(cog,voi)
        print( cogglist[[length(cogglist)]]  )
        print( resultsX$coefficients )
        print( mycoffs )
        print(stadnnh[n,] )
    }
  } 
}
}
#####################
stadnnh = stadnnh[!stadnnh$singular,]
```

```{r quicknnhpost,echo=FALSE,eval=TRUE,fig.width=12,fig.height=14,warning=FALSE,message=FALSE,fig.cap='Select predictor effect plots for SiMLR mapping between M3RI and PD symptomology.  Plots headed with "X" relate to cross-sectional effects while "L" is longitudinal.  Significance for the class of effects is also noted in the main title of each figure pair ("p = ....").  Shaded regions in all panels show 95 percent confidence intervals.  In the "L" plots, the predictor effect plots visualizes interaction between time from baseline and the given SiMLR IDP.  The darker lines indicate the relationship of higher values in the given imaging score with the change in the outcome.  Lighter dashed lines indicate the relationship of lower values in the given imaging score with the change in the outcome.  For example, higher values in t1PC33 are associated with MOCA preservation over time (or increased learning) as is decreased asymmetry. The SiMLR50 plots (middle panels) show robust cross-sectional association with total score but no evidence of longitudinal association.  The SiMLR70 plots (bottom pair) show association of both DTI and resting state IDPs with REM sleep disturbance changes over time.'}
c2viz = c("updrs3_score4", "MOCA33", "updrs_totscore50", "updrs_totscore55", "rem70", "NP1DPRS71")
c2viz = c("updrs3_score4", "MOCA33", "updrs_totscore50", "updrs_totscore55", "rem70", "NP1DPRS71")
if ( is.list(cogglistnames) ) cogglistnames = unlist( cogglistnames )
wdisp = which( cogglistnames %in% c("updrs_totscore50", "MOCA33", "rem70" ))
cogglist2 =cogglist[wdisp]
if ( length(cogglist2) >= 3 )
  grid.arrange(grobs=list( 
    cogglist2[[1]], cogglist2[[2]], cogglist2[[3]] 
  ),nrow=3)
```



```{r updrsresultsSiMLRtabsetup,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,results='asis'}
sigth=0.05
for ( cog in unique(stadnnh$cog) ) {
  cogsel = subtyper::fs(stadnnh$cog == cog)
  # cogsel = rep(TRUE,nrow(stadnnh))
  mypvs = stadnnh$anv[ cogsel ]
  mypvsx = stadnnh$anv.x[ cogsel ]
  psel = subtyper::fs( p.adjust( mypvs, 'BY' ) <= sigth )
  psel2 = subtyper::fs( p.adjust( mypvs, 'BH' ) <= sigth )
  pselx = subtyper::fs( p.adjust( mypvsx, 'BY' ) <= sigth )
  psel2x = subtyper::fs( p.adjust( mypvsx, 'BH' ) <= sigth )
  stadnnh[cogsel, 'sig'][psel2|psel2x] <- 'fdr'
  stadnnh[cogsel, 'sig'][psel|pselx] <- 'fwe'
  }
qdfsignnh=stadnnh[ stadnnh$sig %in% c("fwe","fdr"), ]
qdfsignnh = qdfsignnh[ order( as.character(qdfsignnh$cog), qdfsignnh$anv * qdfsignnh$anv.x ), ]
temp=qdfsignnh
temp$d=0
temp$multi=FALSE
temp$p=temp$anv
qdfsignnhmatch=bipartite_variable_match(temp)
qdfsignnh$anv.x = insight::format_p(  qdfsignnh$anv.x, digits=4  )
qdfsignnh$anv = insight::format_p(  qdfsignnh$anv, digits=4  )
qdfsignnh$voi=gsub("_",".",qdfsignnh$voi,fixed=TRUE)
qdfsignnh$cog=gsub("_",".",qdfsignnh$cog,fixed=TRUE)
qdfsignnh = qdfsignnh[!duplicated(qdfsignnh),]
###########################################################################
```



```{r updrsresultsSiMLRtab,echo=FALSE,eval=TRUE,warning=FALSE,message=FALSE,results='asis'}
# Print the ztable object, ensuring it's treated as LaTeX code
#toviz = na.omit(qdfsignnh[qdfsignnh$sig=='fwe',])
# toviz = head( toviz[ , !colnames(toviz) == 'sig'], 20 )
qdfsignnh$cog = gsub("_",".",qdfsignnh$cog,fixed=TRUE)
qdfsignnh$cog = gsub(".score","",qdfsignnh$cog,fixed=TRUE)
nn=5
simlrviz=data.frame()
for ( gg in unique(qdfsignnh$cog)) {
  simlrviz=rbind(simlrviz, head(qdfsignnh[qdfsignnh$cog==gg,],nn) )
}
simlrviz[ is.na(simlrviz)]='NA'

colnames(simlrviz)=gsub("_",".",colnames(simlrviz),fixed=TRUE)
svnames=c("cog","voi","n.x","n.long","d.b","d.y","S.m1.1","S.m2.1",'sig')
svnames=c("cog","voi","n.x","n.long","anv.x","anv","S.m1.1","S.m2.1",'sig')
svnames2=c("cog","voi","n.x","n.y","anv.x","anv.y","S.m1.1","S.m2.1",'sig')
svnames=c("cog","voi","n.x","n.long", "anv.x","anv", "d.b","d.y","S.m1.1","S.m2.1",'sig')
svnames2=c("cog","voi","n.x","n.y", "anv.x","anv.y", "d.x","d.y","S.m1.1","S.m2.1",'sig')
# svnames=c("cog","voi","n.long",'anv',"d.y","S.m1.1","S.m2.1",'sig')
# svnames2=c("cog","voi","n.y",'anv.y',"d.y","S.m1.1","S.m2.1",'sig')
simlrviz[,svnames2]=simlrviz[,svnames]
qdfsigzNNH=ztable( simlrviz[,svnames2], zebra=2,tabular=F)
mycap=paste0('Table 7. Significant SiMLR IDP to clinical measurements: (up to) top five for each score.')
print(qdfsigzNNH, type = "latex",size=3,caption=mycap,sidewaystable=TRUE)
```


We use LMMs to estimate the relationship of IDP values to clinical observations as evaluated by MDS-UPDRS 1, 2, 3 (off), total (off) and related scores.  While these clinical measurements have well-documented limitations in terms of reliability and interpretability [@on_behalf_of_the_parkinsons_progression_markers_initiative_parkinsons_2023], they are consistently available in PPMI.  These exemplar assessments differ from the prior section in that they focus only on PPMI subjects as these measurements are absent in ADNI.  These models are of the form:

$$
\begin{split}
\text{UPDRSX}_{delta} \approx (1|ID) + \text{UPDRSX}_{bl} + \text{BV}_\text{bl} + Edu + LEDD  + \\ 
  age_\text{bl} + Sex_\text{bio} + years_\text{bl}  *  ( \sum_{i=1}^5 simIDP_i^k )
\end{split}
$$

The outcome is $\text{UPDRSX}_{delta}$ indicating change in a given MDS-UPDRS score.  The majority of these variables are as defined previously.  However, we introduce covariates for treatment effects (Levodopa Equivalent Daily Dose, LEDD) as well as baseline values of the given score.  This latter variable approximates a control for subject and domain-specific disease severity.  As such, these models are relatively conservative in terms of their attribution of variance to  IDP values.  The predictor of interest, here, is $years_\text{bl}  *  ( \sum_{i=1}^5 simIDP_i^k )$ which estimates change in the given MDS-UPDRS score (or derived score / subscore) in relation to brain structure (including asymmetry) and function as measured by three modalities.  The $p$-value associated with each of the $k$ in $1 \cdots 100$ models is determined by the amount of additional variance that is explained by the SiMLR IDPs (`R` `anova` function).  We determine significance from the omnibus $p$-value returned by `anova`.  The effect sizes are derived from the single most predictive SiMLR IDP in each model; additional influence by secondary IDPs would augment estimates.  These models are assessed in the range of baseline to `r maxy` years change.  As in the prior section, cross-sectional results are derived with standard regression (`lm`); the outcome in this case, however, is the raw score, not its change.  

The effects are visualized, in Figure 9, through effect plots for select IDPs of interest.  Effect sizes for each significant (fdr or fwe) pair of outcomes and IDPs in Table 7 where S.m1.1 indicates the top IDP feature contributing to the model.  If S.m2.1 is present, this means that a second predictor also contributes significantly to the association (uncorrected $p \le 0.05$ based on the  $t$-value for a given $simIDP_i^k$ where $i$ indexes the individual type of measurement and $k$ indicates the $k^\text{th}$ component). The clinical measurement and its most highly weighted IDP is also listed.  In several cases, two or more distinct modalities contribute effectively.  Moreover, although SiMLR's multivariate feature learning was performed on a separate cohort, several reasonable associations are brought out by this analysis: involvement of hypothalamus FA (`dti.fa.die.hth`) with REM sleep disturbance (rem), connectivity between dopaminergic regions and cognitive control regions (`rsf.p2.conta.2.dopamine`) and MDS-UPDRS-III scores and thickness of substantia nigra pars compacta (`t1.thk.sncdp`) with several measures including postural instability and gait disturbance (PIGD).  Recall that we are only reporting, in Table 7, the top features; each $simIDP_i^k$ involves many regions.  Region names are described in detail online in the [data dictionary and associated documentation.](http://htmlpreview.github.io/?https://github.com/stnava/ANTsPyMM/blob/main/docs/make_dict_table.html)

This SiMLR study demonstrates that brain state -- as measured jointly by these modalities -- may contribute to acceleration/deceleration of changes in MDS-UPDRS and related scores.  However, we accentuate that these models are relatively simple and linear; as such, they yield only rough suggestions that additional modeling effort may be warranted to understand the differential value of these IDPs across the spectrum of PD symptomology.  Furthermore, this analysis grouped all PPMI subjects together (excluding controls); as such, it lacks the specificity that may be needed to parse subgroup relationships or those that only occur within specific stages of PD.  The subjects comprising these results span a variety of PD-related subgroups: `r mycogn` (median across results for the baseline cohort; the longitudinal cohort subjects are fewer as they are required to have two or more visits: `r mycognL`).  Despite these limitations, Table 7 demonstrates that all three modalities studied here may jointly influence clinical presentation and/or symptoms.  Furthermore, several of these models indicate that multiple IDPs are changing in concert with symptom progression.

In summary, these data and reference results demonstrate the potential of multimodal neuroimaging and integrative statistical approaches in PD and neurodegenerative disease research more generally.  This tabulated multi-modality MR IDP dataset for PPMI -- derived from deeply validated open source methods -- represents a valuable opportunity to help standardize as well as advance PD M3RI research. It simplifies -- to the extent that is currently possible -- the analysis of complex imaging data and potentially accelerates the discovery of novel insights into PD progression and effects.  The timing of this data release is critical given the newly available SAA biomarker. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.


# Usage Notes

An example of processing used here is shown in the github respository [https://github.com/stnava/ANTPD_antspymm](https://github.com/stnava/ANTPD_antspymm) where we combine easily accessible multi-view neuroimaging with our open source methods for demonstration purposes.  All images referred to in this research were processed in a style identical to this example.

# Code availability

Core image processing was done with `python 3.9` while document creation was achieved with `R` version `4.3.0` -- "Already Tomorrow".  ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM). The version used for this work is `1.4.0` along with tensorflow `2.11.0`, antspyx `0.5.0`, antspynet `0.2.8` and antspyt1w `0.9.4`. [Subtyper](https://stnava.github.io/subtyper/) `v1.0.0` and [ANTsR](https://antsx.github.io/ANTsR/) `0.6.2` contain many utilities used in the creation of this compilable document which was built with [Rmarkdown](https://rmarkdown.rstudio.com) [@rmarkdown].

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work through MJFF-021144.  Technical development for aspects of the software used in this work are supported by the Office of Naval Reseach ONR Award Number: N00014-23-1-2317.

# Author contributions statement

B.A. conceptualized and designed the study. L.F., O.H., A.R., A.S., X.W. conducted the experiments and collected the data. B.A. and L.B. performed data analysis and interpretation. N.J.T., J.R.S. and P.A.C. contributed to the development of the software framework and methodology. A.S. and A.R. were responsible for the software and computational tools used in the study. L.C., B.M., R.G, K.P. and K.M. supervised the research and provided critical feedback on the manuscript. B.A. wrote the first draft of the manuscript. All authors reviewed and approved the final version of the manuscript.

# Competing interests

BA declares research support and consulting fees from The
Michael J Fox Foundation. LMC declares research support and consulting fees from The Michael J Fox Foundation. KP declares consultancies for Curasen; was
on a scientific advisory board for Curasen and Amprion; honoraria from
invited scientific presentations to universities and professional societies
not exceeding $5000 per year from California Congress of Clinical
Neurology, California Neurological Society, and Johns Hopkins
University; and patents or patent applications numbers 17/314,979 and
63/377,293. KP also declares grants to her institution (Stanford
University School of Medicine) from NIH/NINDS NS115114, NS062684,
NS075097, NIH/NIA U19 AG065156, P30 AG066515, The Michael J Fox
Foundation, Lewy Body Dementia Association, Alzheimerâ€™s Drug
Discovery Foundation, Sue Berghoff LBD Research Fellowship, and the
Knight Initiative for Brain Resilience.
KM declares support to his institution (Institute for Neurodegenerative Disorders) from The Michael J Fox Foundation. KM also declares consultancies for Invicro, The Michael J Fox Foundation, Roche, Calico, Coave, Neuron23,
Orbimed, Biohaven, Anofi, Koneksa, Merck, Lilly, Inhibikase,
Neuramedy, IRLabs, and Prothena. KM participates on DSMB at
Biohaven.

# References







```{r mmm,echo=FALSE,eval=FALSE}
temp=ppmi[ , c("subjectID","imageID", "date", "T1Hier_resnetGrade",'studyName') ] 
temp$u_hier_id=NA
for ( k in 1:nrow(temp) ) {
  temp$u_hier_id[k]=paste0( temp$studyName[k],temp$subjectID[k], temp$date[k], temp$imageID[k], collapse='-') 
}
write.csv( temp, './data/temp.csv')
temp2=read.csv( './data/temp.csv')
temp=temp[ temp$u_hier_id %in% temp2$u_hier_id, ]

```








```{r simlrB,echo=FALSE,eval=FALSE}
presim=read_simlr_data_frames( path.expand(simfile), 
    c("t1","t1a", "dt", "dta", "rsf" ))
npc = ncol(presim[[1]])


# test these things against cog
voist1 = c( 
    getNamesFromDataframe(  "t1PC", mysim$demog ),
    getNamesFromDataframe(  "t1aPC", mysim$demog ) )
voisrs = getNamesFromDataframe(  "rsPC", mysim$demog )
voisdt = c( 
    getNamesFromDataframe(  "dtPC", mysim$demog ),
    getNamesFromDataframe(  "dtaPC", mysim$demog ) )
voisx = c( voist1, voisdt, voisrs )
cogv = paste0( "updrs1_score", c("_BL","_delta"))
bform =paste( cogv[2], " ~ ", cogv[1], "  +  LEDD + age_BL + commonSex + brainVolume_BL + ( yearsbl )   ")
uvform =paste( bform, "   *  ( ", voisx[1] , ")" )
mvform =paste( bform, " + ( yearsbl )  *  ( ", paste(voisx,collapse="+") , ")" )
temp2 = mysim$demog[ !is.na( mysim$demog[,cogv[2]] ) &
    !is.na( mysim$demog[,voist1[1]]) & 
    !is.na( mysim$demog[,voisdt[1]]) &
    !is.na( mysim$demog[,voisrs[1]]) &
  mysim$demog$TDX == "PDSp+" & mysim$demog$yearsbl <= maxy & 
  mysim$demog$T1Hier_resnetGrade_BL > 1.02, ]

m0=lm( bform,data=temp2 )
m1=lm( uvform,data=temp2 )
m2=lm( mvform,data=temp2 )
# summary( lm( mvform,data=temp2 ))
# anova(m0,m2)
library(randomForest)
library(ranger)
temp2$commonID = factor( temp2$commonID )
n=200
mypartrate=0.80
cvdf=data.frame(  )
mymv = randomForest
mymv = lm
mymv2 = randomForest
mymv2 = ranger
for ( jj in 1:n ) {
  train_test = groupdata2::partition( temp2, p = mypartrate, id_col = "commonID") 
  bmdl=suppressMessages(mymv( as.formula(bform), data=train_test[[1]] ))
  mdlu=suppressMessages(mymv( as.formula(uvform), data=train_test[[1]] ))
  mdl=suppressMessages(mymv2( as.formula(mvform), 
    data=train_test[[1]][,all.vars(as.formula(mvform))] ))
  highy=train_test[[2]]$yearsbl >= 0.80 & train_test[[2]]$yearsbl < maxy
  train_test[[2]]=train_test[[2]][highy,]
  if ( nrow(train_test[[2]]) > 5 ) {
#    print( range( train_test[[2]]$yearsbl ) )
  #  print( length( fixef(bmdl)))
    mypredb = predict( bmdl, newdata=train_test[[2]])#, allow.new.levels = TRUE )
    mypredu = predict( mdlu, newdata=train_test[[2]])#, allow.new.levels = TRUE )
    mypred = predict( mdl, data=train_test[[2]][,all.vars(as.formula(mvform))])#, allow.new.levels = TRUE )
  #  plot( train_test[[2]][,paste0(cog,"_delta")], mypred )
    jjj=nrow(cvdf)+1
    cvdf[jjj,'nte']=length(unique(train_test[[2]]$commonID))
    cvdf[jjj,'ntr']=length(unique(train_test[[1]]$commonID))
    cvdf[jjj,'model']='clin'
    cvdf[jjj,'corr']=cor.test( train_test[[2]][,paste0(cog,"_delta")], mypredb )$est
    cvdf[jjj,'err']=mean(abs(train_test[[2]][,paste0(cog,"_delta")]- mypredb ),na.rm=T)
    jjj=nrow(cvdf)+1
    cvdf[jjj,'model']='idp1'
    cvdf[jjj,'corr']=cor.test( train_test[[2]][,paste0(cog,"_delta")], mypredu )$est
    cvdf[jjj,'err']=mean(abs(train_test[[2]][,paste0(cog,"_delta")]- mypredu ),na.rm=T)
    jjj=nrow(cvdf)+1
    cvdf[jjj,'model']='idp3'
    cvdf[jjj,'corr']=cor.test( train_test[[2]][,paste0(cog,"_delta")], mypred )$est
    cvdf[jjj,'err']=mean(abs(train_test[[2]][,paste0(cog,"_delta")]- mypred ),na.rm=T)
    if ( jj > 9 & jj %% 10 == 0 ) {
      g1=cvdf$model =='clin'
      g2=cvdf$model =='idp3'
      print(t.test(  cvdf[g1,'corr'] ,   cvdf[g2,'corr'] ,  paired=TRUE ))
#      print(t.test(  cvdf[g1,'err'] ,   cvdf[g2,'err'] ,  paired=TRUE ))
    }
  }
}
mediann=median( cvdf$nte, na.rm=TRUE)
mediann2=median( cvdf$ntr, na.rm=TRUE)
####################################################
m='corr'
g1=cvdf$model =='clin'
g2=cvdf$model =='idp3'
mvanvp3 = t.test(  cvdf[g1,m] ,   cvdf[g2,m] ,  paired=TRUE )$p.value
g1=cvdf$model =='clin'
g2=cvdf$model =='idp1'
mvanvp1 = t.test(  cvdf[g1,m] ,   cvdf[g2,m] ,  paired=TRUE )$p.value
g1=cvdf$model =='idp1'
g2=cvdf$model =='idp3'
mvanvpu = t.test(  cvdf[g1,m] ,   cvdf[g2,m] ,  paired=TRUE )$p.value
ttl=paste( sum( cvdf$model == 'clin',na.rm=T), 'cross-validation runs with a median of', mediann,'subjects in test data and',mediann2,'in train data.')
print( gghistogram(cvdf[cvdf$model %in% c("clin","idp3"),], 
  x = m, add = "median", rug = TRUE,
  color = "model", fill = "model", palette='jco', title=ttl, xlab='correlation of real to predicted change' ) )
mvanvp3 
train_test = groupdata2::partition( temp2, p = 0.98, id_col = "commonID") 
mdl=randomForest( as.formula(mvform), data=train_test[[1]], importance=TRUE )
if ( class(mdl)[1] != 'ranger' ) {
    importance_matrix <- randomForest::importance(mdl)
    importance_df <- data.frame(
    Feature = rownames(importance_matrix),
    Importance = importance_matrix[, 1]
    )
}
#######
```



```{r simlrimp,echo=FALSE,eval=FALSE,fig.width=12,fig.height=10,message=FALSE,warning=FALSE,fig.cap="Feature importance for the RF model.",cache=TRUE}
# Plot using ggplot2
if ( class(mdl)[1] != 'ranger' ) {
print( ggplot(importance_df, aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Feature Importance", x = "Features", y = "Mean Decrease in Accuracy") )
# varImpPlot(mdl, main = "Feature Importance")
}
# library(vip)
# vis <- vi(mdl, method = "permute",  nsim = 10, target=cogv[2],
#                 metric = "rmse", train=train_test[[1]])
# vip(vis, num_features = 10, geom = "boxplot", include_type = TRUE)

```



```{r mlr3regression,echo=FALSE,eval=FALSE}
library(mlr3verse)
library(mlr3extralearners)
myl = list_mlr3learners(select = c("id", "required_packages"))
myl = myl[ -grep("RWeka",myl$required_packages), ]
subform = gsub("commonSex","1",bform)
subform = gsub("brainVolume_BL","1",subform)
tcols = all.vars(as.formula(subform))
tvar = tcols[1]
temp2 = mysim$demog[ !is.na( mysim$demog[,cogv[2]] ) &
    !is.na( mysim$demog[,voist1[1]]) & 
    !is.na( mysim$demog[,voisdt[1]]) &
    !is.na( mysim$demog[,voisrs[1]]) &
  mysim$demog$TDX == "PDSp+" & mysim$demog$yearsbl <= maxy & 
  mysim$demog$T1Hier_resnetGrade_BL > 1.02, c(tcols,voisx )]

myform = as.formula(paste( tvar, " ~ . " ))
task_penguins = as_task_regr( myform, data = temp2 )
mylcl = myl$id[ grep("regr[.]", myl$id)]
badones = c( "regr.catboost" , "regr.lmer", "regr.mob", "regr.priority_lasso", "regr.bart", "regr.gam", "regr.km" , "regr.nnet")
badones = paste0( "regr.", c("bart", 'catboost','gam','km','nnet','lmer','mob','priority_lasso') )

cvreg = rsmp("cv", folds = 12 )
cvreg$instantiate(task_penguins)

# mylcl = myl2$key[ grep("regr", myl2$task_type)]

mylearners = mylcl[ !(mylcl %in% badones) ]
goodlearners=c("regr.abess", 
    # "regr.cforest", # slow
    "regr.ctree", "regr.cubist", "regr.cv_glmnet", 
    "regr.debug", "regr.earth", "regr.featureless", "regr.fnn", 
    # "regr.gamboost", # slow
    "regr.gausspr", "regr.gbm", "regr.glmboost", "regr.kknn", "regr.ksvm", "regr.liblinear", "regr.lightgbm", 
#    "regr.randomForest", # slow but good
   "regr.ranger", 
#   "regr.rfsrc", # slow
   "regr.rpart", "regr.rvm", "regr.svm", "regr.xgboost")
design = benchmark_grid(
  tasks = task_penguins,
  learners = lrns(goodlearners,predict_sets = c("train", "test")),
  resamplings = cvreg
)
bmr = benchmark(design)
#######################
measures = list(
  msr("regr.mae", id = "test")
)
tab = bmr$aggregate(measures)
print(tab[, .(task_id, learner_id, test)])
autoplot(bmr) + ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 45, hjust = 1))

```



```{r ppmi500,eval=FALSE,echo=FALSE}
zz=read.csv("/Users/stnava/data/PPMI500/repo/PPMI500/ppmi500//ppmi500/data/ppmi500_ids_date.csv")
nna=!is.na( ppmi$rsfMRI_fcnxpro129_FD_mean )
table( zz$subjectID %in% ppmi$subjectID[nna] )
nna=!is.na( ppmi$DTI_dti_FD_mean )
table( zz$subjectID %in% ppmi$subjectID[nna] )
ww=which( ! ( zz$subjectID %in% ppmi$subjectID[nna] ) )
ord=order( zz$date[ww])
zz[ww,][ord,]
```