---
title: "Enhancing Parkinson's Disease Research with Tabulated Multi-Modality MRI for PPMI"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1
  - Leon Fonville^3,†^
  - Olivia Hampton^1,†^
  - Alex Reardon^1,†^
  - Nicholas J. Tustison^2
  - Xue Wang^1,†^
  - Roger Gunn^1
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: University of Virginia, Department of Radiology and Medical Imaging, Charlottesville, VA, FIXME, USE"
  - "3: Invicro, FIMXE, UK"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: 
  pdf_document:
    keep_tex: true
    template: null
    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmi_sci_data.bib
classoption: table
# header-includes:
#  - \usepackage{jabbrv}
linenumbers: true
urlcolor: blue
---

# Abstract

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  Magnetic resonance imaging (MRI) is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. The Parkinson's Progression Markers Initiative (PPMI) provides multiple modality MRI (M3RI) and biomarker-confirmation for PD that provides a prismatic view into the trajectory of this neurodegenerative disorder.  However, the collective and consistent analytical representation of M3RI poses challenges to image analysis and clinical experts alike due to the unique characteristics of T1-weighted, diffusion weighted and resting state functional MRI. This effort systematically applies the open source Advanced Normalization Tools X (ANTsX) ecosystem to the PPMI M3RI to convert these intricate MRI modalities into an organized, tabular format.  We summarize these data, methods and technical validity of this effort.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy Bodies, primarily composed of misfolded alpha-synuclein, and appearing early in the substantia nigra [(Fearnley1991)](https://academic.oup.com/brain/article-abstract/114/5/2283/399854). The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [(Lee & Trojanowski, 2006)](https://www.cell.com/neuron/fulltext/S0896-6273(06)00733-1) [(Dickson et al., 2009)](https://pubmed.ncbi.nlm.nih.gov/20082965/) [(Calabresi, 2023)](https://www.nature.com/articles/s41419-023-05672-9). The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [(Shahnawaz et al., 2020)](https://pubmed.ncbi.nlm.nih.gov/32025029/); [(Siderowf et al., 2023)](https://pubmed.ncbi.nlm.nih.gov/37059509/).

Analyzing the link between SAA status and longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking pathology, symptoms and imaging [(nemmi2019)](https://www.sciencedirect.com/science/article/pii/S2213158219302086) [(dagher2020)](https://academic.oup.com/brain/article/143/10/3052/5912110) [(markello2021)](https://www.nature.com/articles/s41531-020-00144-9).

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI datasets from 2010 to 2023, focusing on T1-weighted, diffusion-weighted, and resting-state functional MRI for analyzing neurodegenerative diseases. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [(avants2015)](https://www.nature.com/articles/sdata20153) [(stone2020)](https://doi.org/10.1089/neu.2020.7141) [(Tustison et al., 2021)](https://www.nature.com/articles/s41598-021-87564-6).   

To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [(hawco2022)](https://www.nature.com/articles/s41597-022-01386-3) [(srpbs)](https://www.nature.com/articles/s41597-021-01004-8) [(dtitravel)](https://doi.org/10.1016/j.mri.2019.02.011) and an additional easily accessible M3RI young control cohort [(avants2015)](https://www.nature.com/articles/sdata20153) .  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate the neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [(schwarz2011)](https://doi.org/10.1002/mds.23722) [(Aquino2013)](https://link.springer.com/article/10.1007/s10072-013-1595-2) [(poston2020)](https://doi.org/10.1016/j.parkreldis.2019.10.002). Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [(peran2010)](https://academic.oup.com/brain/article/133/11/3423/313450) but also in LRRK2-PD [(tolosa2020)](https://www.nature.com/articles/s41582-019-0301-2) [(ross2011)](https://doi.org/10.1016/S1474-4422(11)70175-2). Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [(hacker2012)](https://doi.org/10.1093/brain/aws281) [(kim2017)](https://doi.org/10.1093/brain/awx233). Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain, pointing towards a more integrative approach to understanding PD [(menke2009)](https://doi.org/10.1016/j.neuroimage.2009.05.017) [(markello2021)](https://www.nature.com/articles/s41531-020-00144-9) and the role of alpha-synuclein in these effects [(simuni2024)](https://doi.org/10.1016/S1474-4422(23)00405-2).

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs depend on standard anatomical and functional hierarchies that are well-established in the field but are consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dMwRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables are annotated with the associated demographics, SAA status, clinical data such as the Unified Parkinson's Disease Rating Scale (UPDRS) [(updrs2003)](https://doi.org/10.1002/mds.10473) and standard PPMI DAT-SPECT summary measurements [(Bega2021)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8144619/) [(Droby2022)](https://www.nature.com/articles/s41531-022-00285-z). Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.


# Methods

The Methods should include detailed text describing any steps or procedures used in producing the data...

Resting state functional MRI (rsfMRI) processing builds on prior multi-view techniques performed in this same ecosystem [(avants2015)](https://www.nature.com/articles/sdata20153) [avants2016](https://doi.org/10.1016/j.neurobiolaging.2018.10.002).  Diffusion tensor imaging (DTI) processing leverages best practices from both ANTsX and the collaborative DTI-focused project [DiPy](https://www.frontiersin.org/articles/10.3389/fninf.2014.00008/full). 

## T1-weighted MRI


The article "The ANTsX ecosystem for quantitative biological and medical imaging" by Nicholas J. Tustison et al. presents ANTsX, an open-source software ecosystem designed for processing and analyzing biological and medical imaging data. It highlights the integration of deep learning capabilities through ANTsR and ANTsPy for R and Python, respectively, enhancing computational efficiency and accuracy. The ecosystem includes tools for image registration, segmentation, and analysis, demonstrating superior performance in applications like cortical thickness measurement from MRI data. For further details, visit the [Nature article](https://www.nature.com/articles/s41598-021-87564-6).

The study enhances the UK Biobank neuroimaging structural Imaging-Derived Phenotypes (IDPs) by incorporating measurements from the Advanced Normalization Tools Ecosystem, alongside traditional software libraries like FSL and FreeSurfer. It includes cortical and subcortical measurements, morphological measurements of the hippocampus and cerebellum, among others. Through predictive modeling, the study assesses the clinical utility of these IDPs, exploring their predictive accuracy for various sociodemographic variables. The results highlight differences in performance across software libraries and the combined utility of IDP sets, underscoring the importance of selection and utilization in research.


## diffusion weighted MRI


The function `joint_dti_recon` is designed to conduct a comprehensive reconstruction of Diffusion Tensor Imaging (DTI) data, integrating both left-right (LR) and right-left (RL) acquisitions, with the inclusion of optional motion correction, denoising, dewarping based on fractional anisotropy (FA) or other modalities, and data imputation or censoring. It processes input DTI images alongside b-value and b-vector files, utilizing a 1mm John Hopkins University (JHU) atlas for spatial normalization and labeling. The function supports optional super-resolution modeling, T1-weighted neuroimages for enhanced dewarping, and a brain mask to constrain analysis within the brain region. The workflow includes initial reconstruction and optional motion correction, dewarping using specified modalities or T1-weighted images, reapplication of dewarping to original data, secondary DTI reconstruction, and spatial normalization to the JHU atlas for labeling.

The function's outputs are encapsulated in a dictionary containing the mean fractional anisotropy (FA) image, its summary statistics mapped against JHU labels, the registration to the JHU atlas, dewarping details, and DTI reconstruction parameters. Optional RL image processing is provided, with the function capable of handling either single or combined LR and RL datasets. This allows for flexibility in addressing various data quality issues, such as motion artifacts or distortions inherent in diffusion MRI data. The function highlights the significance of integrating advanced preprocessing steps like super-resolution and dewarping in enhancing the quality of DTI analyses, thereby facilitating more accurate and reliable neuroimaging studies.

### resting state functional MRI

The function `resting_state_fmri_networks` is designed to compute resting-state network correlation maps based on J. Power's labels, aiming to produce a map for each major network system within the brain. It takes as inputs the BOLD fMRI image, a reference fMRI template, a 3-D T1 brain image, and a six-tissue segmentation image, among other parameters. The function incorporates a series of preprocessing steps such as registration, despiking, smoothing, nuisance regression, bandpass filtering, and censoring, tailored to enhance the quality of the resting-state fMRI data analysis.

Key features include the optional upsampling of data, the computation of temporal and spatial derivatives, the application of CompCor for noise reduction, and the implementation of ICA components as part of the nuisance regression. Additionally, the function utilizes bandpass limits for frequency filtering, with parameters adjustable to the user's requirements.

The methodology follows a structured pipeline, commencing with data registration and concluding with the calculation of correlation matrices that capture the functional connectivity between different brain regions. This process also involves the extraction and analysis of motion parameters to address motion-related artifacts, reflecting a comprehensive approach to fMRI data preprocessing and analysis.

By outputting a dictionary containing derived network maps, the function facilitates further studies on the functional architecture of the brain, supporting the advancement of research in neuroimaging. This tool integrates a variety of analytical strategies, drawing upon existing literature and recommended practices to ensure the effective denoising and analysis of resting-state fMRI data.

# Data Records

...

# Technical Validation

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges FIXME. We further this by demonstrating ANTsX reproducibility and reliability through analysis of three traveling subject cohorts and a young control cohort. By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) across different scanner types and imaging modalities. The young control cohort, using the pediatric template of brain perfusion (PTBP) data, validates the utility of combining multi-modality tabular data processed by ANTsX to enhance predictions of population characteristics. In essence, our additional analyses furnish numerical benchmarks for reliability and predictive accuracy and may be extended to other contexts.

## Multi-site reproducibility

## Multi-view prediction 

## PPMI case studies

Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), dMRI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

The tabulated multi-modality MRI dataset derived from deeply validated open source methods represents a significant leap forward in PD M3MRI research. It simplifies the analysis of complex imaging data, potentially accelerating the discovery of novel insights into PD's progression and effects. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.

```{r pkgs,echo=FALSE,eval=TRUE,messages=FALSE,cache=TRUE}
set.seed( 0 )
library( GoodmanKruskal )
library(heatmap3)
library("permute")
library(interactions)
library(reghelper)
library(MGMM) # GMM methods (FIXME)
library(WeightedCluster) # cluster quality (FIXME)
library( kmed ) # silhouette plots and such
library( clustree ) # cluster validation tools
library( factoextra )
library(flexclust)
library(tidyverse)
library(magrittr)
library(cluster)
library(cluster.datasets)
library(cowplot)
library(NbClust)
library(clValid)
library(ggfortify)
library(clustree)
library(dendextend)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="html" )
tblcmd = ztable
buildsci=FALSE
```

```{r functions,echo=FALSE,eval=TRUE,warnings=FALSE,messages=FALSE,cache=FALSE}
scaleqvars <- function( mydf, myeq ) {
  myterms=all.vars(as.formula(myeq))[-1]
  myterms=intersect(myterms,colnames(mydf))
  for ( x in myterms ) {
    if ( is.numeric( mydf[,x] ))
      mydf[,x]=scale(mydf[,x])
  }
  return(mydf)
}

normalizersfmri = function( dd, applyit='none' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE,cache=FALSE}
is_test = TRUE
if ( ! exists( "ppmi" ) ) {

  ppmifn = "../data/latest_ppmi_plus.csv"; myrez='or'
  ppmifn = "../data/latest_ppmi_plus_sr.csv"; myrez='sr'
  ppmifn = "../data/latest_ppmi_plus_sr_fmri_up.csv"; myrez='sr'
  ppmi = read.csv(ppmifn)
  ppmi = fillBaselineColumn( ppmi,
        c('brainVolume','hy','MOCA'), 
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
  mylevs = c( 
    "CN", "ProdromalLRRK2", "ProdromalGBA", "ProdromalSporadic", 
        "PDPRKN", "PDLRRK2", "PDGBA", "PDSporadic",
        "CBSPSP", "L_SD", "SV", "PNFA", "bvFTD",
        "SMC",  "MCI", "AD" ) 
  ppmi$joinedDX = factor( ppmi$joinedDX, levels=mylevs )

}
```

### mixed effects diagnosis

```{r quicklmdx,echo=FALSE,eval=buildsci,fig.width=9,fig.height=3.5,warnings=FALSE,messages=FALSE}
######################################################################
######################################################################
dxform="~  (1|PATNO)+ (1|SITE) + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_mean + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
ysel = ppmi$yearsbl <= 4.5 
dxsel2 = ppmi$DXSubAsyn %in% c(
  negate, posate, ispd ) & ysel 
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
mylevsx1=c( "CN", "ProdromalSporadic", "PDSporadic", "MCI", "AD" )
temp = ppmi[ ppmi$studyName %in% c('PPMI','ADNI') & 
  ppmi$commonAge <= 800 &
#  ppmi$DXSubAsyn %in%  mylevsx0[c(1,2,3)]&  
#  ppmi$joinedDX %in%  mylevsx1[c(1,2,3)] &  
#  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2" ) ) &
  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2","PDSporadic" ) ) &
  ysel & ppmi$T1Hier_resnetGrade > 1.05,]
temp = normalizersfmri( temp )
temp$joinedDX <- fct_relevel(temp$joinedDX, "CN")
temp$DXSubAsyn <- fct_relevel(temp$DXSubAsyn, "CNNegative")
temp$TDX = NA # as.character( temp$DXSubAsyn )
temp$TDX[ temp$AsynStatus == 'Negative' & temp$joinedDX == 'CN' ]='CN'
# temp$TDX[ temp$DXSubAsyn %in% ispd ]='otherPositive'
# temp$TDX[ temp$DXSubAsyn  == 'PDLRRK2Positive' ]='DX'
mydx='PDSpNeg'
temp$TDX[ temp$DXSubAsyn  == 'PDSporadicNegative' ]='DX'
#temp$joinedDX = factor( temp$joinedDX, levels = mylevsx1)
#temp$DXSubAsyn = factor( temp$DXSubAsyn, levels = mylevsx0)
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_n_outliers < 100 ) &
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5 ) &
#  !is.na(ppmi$AsynStatus) & ppmi$T1Hier_resnetGrade > 1.05,]


temp = antspymm_predictors(temp, TRUE )
idps = antspymm_predictors(temp, TRUE, TRUE )
subjectcount = table( temp$commonID )
mysubs = names(  subjectcount > 1 )
temp = temp[ temp$commonID %in% mysubs , ]
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass')
rsfnames = getNamesFromDataframe( c("rsfMRI_fcnxpro"),  ppmi, exclusions=xcl )
rsfnamescnx = getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_"),  ppmi, exclusions=xcl )
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'joinedDX'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
temp = temp[ !is.na( temp[,dxvar]), ]
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), temp ),
  getNamesFromDataframe( c("DTI","Asym"), temp ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),temp, exclusions=c("left","right")), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),temp, exclusions=c("left","right")) )

######################################
# print( table( temp[,dxvar]))
temp = fillBaselineColumn( temp,
        c( idpst1, rsfnamescnx, dtinamesasymlr, 'hy' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
temp$hy_BL[ is.na( temp$hy_BL ) & temp$joinedDX == 'CN' ]=0
temp$hy_BL[ is.na( temp$hy_BL ) & temp$joinedDX != 'CN' ]=2
temp$hy_BL = factor( temp$hy_BL )
######################################
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
  mycorr='none'
}
dxdf=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdf)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( vois[2], " ~ hy_BL + ", vois[1], "+", dxform )
  bform = paste( vois[2], " ~ 1 + ", vois[1], "+", dxform )
  bform = paste( voi, " ~ 1+", dxform )
  newform = paste( bform, " * ", dxvar  )
  temp2 = temp[ !is.na( temp[,voi]), ]
#  temp2[,vois[2]]=psych::winsor( temp2[,vois[2]], 0.005 )
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scaleqvars( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdf[n,'voi']=voi
  dxdf[n,'anv']=anvp
  dxdf[n,'tyears']=mycoffs[ 'yearsbl', 4]
  dxdf[n,'tcross']=mycoffs[ nrow(mycoffs)-1, 4]
  dxdf[n,'tlong']=mycoffs[ nrow(mycoffs), 4]
  dxdf[n,'res']=myrez
  dxdf[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( anvp < 1e-2 ) {
#    print( mycoffs )
#    print( dxdf[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( voi, myrez, " + ", mydx,  " : ", anvp ) )
    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}

psel = subtyper::fs( p.adjust( dxdf$anv, mycorr ) <= 0.05 )
```

```{r dxresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
temp = dxdf[psel,]
temp[,'dx']=mydx
temp$anv = insight::format_p(  temp$anv, digits=4  )
temp[, !(colnames(temp) %in% c("singular"))] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```


### mixed effects UPDRS changes over time

```{r quicklmcog,echo=FALSE,eval=buildsci,fig.width=9,fig.height=4.0,warnings=FALSE,messages=FALSE}
####################################################################
num=c(122,129,134)[1]
signas = c( "SIGNA_Architect", "SIGNA_EXCITE" ,   "GENESIS_SIGNA"  )
ysel = ppmi$yearsbl <= 4.5
mylevsx2=c( "CN", "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "PDSporadic" )
mylevsx2=c(   "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
temp = ppmi[ ppmi$studyName %in% c('PPMI','ADNI') & 
#  !is.na( ppmi[,paste0( 'rsfMRI_fcnxpro',num,'_FD_mean')] ) &
#  subtyper::fs( 
    # ppmi$NM2DMT_NM_substantianigra_z_coordinate >= 0.20 &
    # ppmi$NM2DMT_NM_substantianigra_z_coordinate <= 0.8 & 
#    ppmi$NM2DMT_NM_avg_substantianigra < 1800 )  &
#  subtyper::fs( !(ppmi$mrimodel %in% signas ) ) &
  ppmi$joinedDX %in%  mylevsx2 &
  subtyper::fs(ppmi$AsynStatus == 'Positive') &
  ysel &ppmi$T1Hier_resnetGrade >= 1.05,]
if ( myrez == "sr" ) {
  write.csv( temp[,'u_hier_id'], '/tmp/temp_ids.csv', row.names=FALSE )
} else {
#  tempids = read.csv( '/tmp/temp_ids.csv' )
#  temp = temp[ temp[,'u_hier_id'] %in% tempids$x, ]
}
temp = normalizersfmri( temp )
#########################################################
temp$joinedDX <- fct_relevel(temp$joinedDX, "CN")
temp$DXSubAsyn <- fct_relevel(temp$DXSubAsyn, "CNNegative")
temp$NM2DMT_NM_diff = temp$NM2DMT_NM_avg_substantianigra - temp$NM2DMT_NM_avg_refregion
temp$NM2DMT_NM_range = temp$NM2DMT_NM_q0pt95 - temp$NM2DMT_NM_q0pt05
temp = antspymm_predictors( temp, TRUE )
idps = antspymm_predictors( temp, TRUE, TRUE )
idpst1 = c( 
  idps[ multigrep(c("thk","dktcortex","LRAVG"), idps, intersect=TRUE )],
  idps[ multigrep(c("thk","dktcortex","Asym"), idps, intersect=TRUE )],
  idps[ multigrep(c("vol","cit168","LRAVG"), idps, intersect=TRUE )],
  idps[ multigrep(c("vol","cit168","Asym"), idps, intersect=TRUE )])
nmidps = getNamesFromDataframe( c("NM2DMT"), temp, 
  exclusions=c(xcl,"_q","min","sd","pt","count","_BL","_delta","coordinate"))
subjectcount = table( temp$commonID )
mysubs = names(  subjectcount > 0 )
temp = temp[ temp$commonID %in% mysubs , ]
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass',"_BL", "outlier_threshold")
#########################################################
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
# dxvar = 'joinedDX'
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), temp, exclusions=c('_BL',"_delta" )),
  getNamesFromDataframe( c("DTI","Asym"), temp, exclusions=c('_BL',"_delta") ) )
#######################################################
rsfnames = getNamesFromDataframe( paste0(c("rsfMRI_fcnxpro"),num),  ppmi, exclusions=xcl )
rsfnamescnx = getNamesFromDataframe( c(paste0(c("rsfMRI_fcnxpro"),num),"_2_"),  ppmi, exclusions=xcl )
#######
fdnames = getNamesFromDataframe( "_FD_", temp  )
cogs = getNamesFromDataframe( c("updrs","score"), temp, exclusions=c(4,'_BL',"_delta") )
temp = fillBaselineColumn( temp,
        c(dtinamesasymlr,rsfnames,idpst1, nmidps, fdnames, cogs ), 
        'PATNO', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
#########################################################
#########################################################
temp$hy_BL = factor( temp$hy_BL )
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
stadfrsf=data.frame()
nmstotest = sort( rsfnamescnx )
qth=1e-4
if ( is_test ) {
  nmstotest = sample( nmstotest, 10 )
  qth=0.01
}
for ( cog in sort(cogs) ) {
  for ( voi in nmstotest ) {
    n = nrow(stadfrsf)+1
#    if ( n %% 10 == 0 ) print(stadfrsf[which.min(stadfrsf$anv),])
    voi = paste0(voi,"_BL")
    motname = paste( 
      paste0( "rsfMRI_fcnxpro",num,"_n_outliers_BL"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL") )
    cogformcommon=paste( cog, "  ~ (1|PATNO) + AsynStatus + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + brainVolume_BL + ", motname, " + age_BL + commonSex + AsynStatus + yearsbl" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    temp2 = temp[ !is.na( temp[,voi]) & temp$yearsbl < 5.85, ]
    temp2[,voi]=psych::winsor( temp2[,voi], 0.005)
    temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
#    temp2[,voi]=temp2[,voi]/temp2$NM2DMT_NM_range
    newform = paste(  cogformcommon, " * ", voi )
    temp2 = scaleqvars( temp2, newform )
    bmdl=suppressMessages(lmer( cogformcommon, data=temp2 ))
    mdl=suppressMessages(lmer( newform, data=temp2 ))
    mycoffs = coefficients( summary( mdl ) )
  #  if ( any(  mycoffs[ multigrep( voi,rownames(mycoffs)), 5 ] < 1e-2 ) ) {
    anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
    stadfrsf[n,'cog']=cog
    stadfrsf[n,'voi']=voi
    stadfrsf[n,'anv']=anvp
    stadfrsf[n,'res']=myrez
    stadfrsf[n,'singular']=isSingular(mdl)
    if ( anvp < qth ) {
#      print( mycoffs[ , -c(1:3)] )
  #    print( voi )
      anvp = insight::format_p( anvp, digits=4 )
      ttl=( paste( voi, myrez, " + ", cog,  " : ", anvp ) )
 #     mygg = visreg::visreg( mdl, 'yearsbl', by=voi, gg=T )
 #     threewayinteraction( temp2, 'yearsbl', cog,  'AsynStatus', voi, showpoints=F )
#      print(prplot( mdl,  voi, 'yearsbl',ttl, colorvar='commonSex', addpoints=1))
      print(prplot( mdl, 'yearsbl', voi, ttl, ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      visreg::visreg( mdl, 'yearsbl', by=voi, main=ttl  )
    }
  }
}
#####################
qdf=data.frame()
for ( cog in cogs ) {
  mypvs = stadfrsf$anv
  mypvs[ stadfrsf$cog != cog  ] = NA
  psel = subtyper::fs( p.adjust( mypvs, mycorr ) <= 0.05 )
  siganat = stadfrsf$voi[ psel ]
  if ( sum(psel) > 0 )
    qdf = rbind( qdf, stadfrsf[psel,] )
  }
###########################################################################
###########################################################################
###########################################################################
```

```{r cogresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
qdf$anv = insight::format_p(  qdf$anv, digits=4  )
qdf[,c("cog","voi","anv","res")] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```

### mixed models


```{r lmerextab,echo=FALSE,eval=FALSE,fig.width=12,fig.height=6,messages=FALSE,warnings=FALSE,cache=FALSE}
knitr::opts_chunk$set(cache.path = odir )
###################################################
pvaluedf = tvaluedf = data.frame()
meffdall = data.frame()
ct = 0
subtypes = c( 'LRRK2', 'Sporadic' ) # GBA
# subtypes = c('LRRK2' ) # GBA
for (  subtype in subtypes ) {
    dxs = c("CNNegative", paste0("PD",subtype,c("Negative","Positive") ) )
    ssel = subtyper::fs( clin$DXSubAsyn %in% dxs ) & commonsel
    studydata = clin[ssel,]
    print( table(round(studydata$yearsbl), studydata$DXSubAsyn) )
    sage=data.frame( stats::poly( studydata$age_BL , 2 ) )
    colnames(sage)=c("Age1","Age2")
    studydata=cbind(studydata,sage)
    studydata$SEX = factor( studydata$SEX )
    if ( FALSE ) {
        studydata$DXSubAsyn = paste0( studydata$DXSubAsyn, studydata$SEX )
        dxs2=c()
        for ( dx in dxs ) dxs2=c(dxs2,paste0(dx,levels(studydata$SEX)))
        dxs=dxs2
        }
    studydata[,'DXSubAsyn']=factor(studydata[,'DXSubAsyn'],levels=dxs)
    studydata$duration_yrs = as.numeric( studydata$duration_yrs )
    studydata$cnxtot = rowSums( studydata[,cnxnames] )
    studydata[,cnxnames]=studydata[,cnxnames]/studydata$cnxtot
    normalizeit=FALSE
    if ( normalizeit ) {
        studydata[,mdnames]=studydata[,mdnames]/studydata$meanmd
        studydata[,thknames]=studydata[,thknames]/studydata$meanthick
        }
    testnames = unique( c( t1names, dtinames, rsfnames ) )
    if ( winsval == 0.0 ) {
        isna=is.na( studydata[,testnames] )
        temp = ANTsR::robustMatrixTransform(studydata[,testnames])
        temp[ isna ]=NA
        studydata[,testnames]=temp
        }
    ####################################
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    testnames = c( 
        getNamesFromDataframe( "Asym" , studydata ),
        getNamesFromDataframe( "LRAVG" , studydata ) )
    countdtinz=rep(NA,length(testnames))
    for ( x in 1:length(testnames) ) {
        countdtinz[x]=sum( !is.na(studydata[,testnames[x]]) & studydata[,testnames[x]] > 0)
    }
    testnames=testnames[ countdtinz > 100 ]
#    testnames = testnames[ -grep("Asym",testnames)]
    studydata$meanthick = rowMeans( studydata[,thknames])
    studydata$meanmd = rowMeans( studydata[,mdnames])
    testnames = c( testnames, midnames )
    studydata = fillBaselineColumn( studydata,
        c('meanthick','meanmd','brainVolume',testnames,'hy','MOCA'), 
        'PATNO', 'imaging_EVENT_ID', 'V0', 
        fast=T, verbose=F )[[1]]
    for ( x in  c('meanthick','meanmd','brainVolume',testnames) ) {
#        studydata=baseimpute( studydata, x )
#        studydata=visitimpute( studydata, x, 2 )
        }
    if ( FALSE )
        testnames = c( 
            "T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168",
            'T1Hier_vol_bn_str_pu_LRAVGdeep_cit168','DTI_mean_md_Asym_rostral_middle_frontal')
    for ( testvols in testnames ) {
        ct = ct + 1
        studydata$testvol = studydata[ ,testvols]
        studydata$testvol_BL = studydata[ ,paste0(testvols,"_BL")]
        studydata$testvol_delta = studydata[ ,paste0(testvols,"_delta")]
        studydata$testvol_delta = psych::winsor(studydata$testvol_delta,tr=winsval)
        studydata$SEX = factor( studydata$SEX )
        toscale = c('snr','psnr','EVR','age_BL','DTI_dti_FD_mean','T1Hier_resnetGrade','DTI_dti_tsnr_b0_mean','testvol_BL','brainVolume_BL','EDUCYRS', 'MOCA_BL', 'hy_BL' )
        studydata$EDUCYRS=as.numeric(studydata$EDUCYRS)
        studydata[,toscale]=scale(studydata[,toscale])
        studydata$EDUCYRS = scale(ANTsRCore::antsrimpute(as.numeric( studydata$EDUCYRS )))
        covars=covars0
        covarsx=covars0x
        if ( length(grep("DTI_",testvols)>1 ) ) {
            covars=paste(covars0,dticovars)
            covarsx=paste(covars0x,dticovars)
        }
        bform=paste( covars, " + yearsbl ")
        myform=paste( covars, " + yearsbl * ( DXSubAsyn )")
        # https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3281513/
        # section: Advantages and Disadvantages of Fixed Main Effect for Site
        bformx=paste( "testvol~",covarsx, " + yearsbl ")
        myformx=paste( "testvol~",covarsx, " + yearsbl * ( DXSubAsyn )")
        isblsub = studydata$PATNO[ studydata$imaging_EVENT_ID=='V0' ]
        isfsub = studydata$PATNO[ studydata$imaging_EVENT_ID !='V0' ]
        isboth = intersect( isblsub, isfsub )
        studydatasub = studydata[ studydata$PATNO %in% isboth,]
        bmdl = try( lmer( bform,data=studydata ) )
        mdl = try( lmer( myform,data=studydata ) )
        bmdlx = lmer( bformx,data=studydata )
        mdlx = lmer( myformx,data=studydata )
        if ( FALSE ) {
            # simple regression for BL vs follow
            lmdata = data.frame( )
            fillvars = all.vars( as.formula( myform ) )
            rmers = multigrep( c("testvol_delta","testvol","PATNO",#"yearsbl",
                "DTI_dti_tsnr_b0_mean","mrimfg"), fillvars, intersect=FALSE )
            lmform = paste( fillvars[1], "~(1|PATNO)+testvol_BL+",paste(fillvars[-rmers],collapse="+"))
            mdlLM = lmer( lmform,data=studydatasub)
#            mycoffsX = coefficients(summary( mdlLM ))
#            if ( any(tail(mycoffsX[,"Pr(>|t|)"],2) < 0.005 )) {
#                print( visreg::visreg(mdlLM,'DXSubAsyn',gg=TRUE)+ggtitle(testvols))
#                print( mycoffsX )
#                print( testvols )
#                }
            }
        if ( !is( mdl, "try-error" ) ) {
            mycoffx = coefficients(summary(mdlx))[-c(1:2),-c(1:2)]
            mycoffx = mycoffx[ grep(subtype,rownames(mycoffx)), ]
            mycoffx = mycoffx[ -grep("yearsbl",rownames(mycoffx)),]
            mycoff = coefficients(summary(mdl))[-c(1:2),-c(1:2)]
#            mycoff = mycoff[ grep(subtype,rownames(mycoff)), ]
            mycoff = rbind(
                mycoffx[grep(subtype,rownames(mycoffx)),],
                mycoff[multigrep(c("yearsbl",subtype),rownames(mycoff),intersect=T),])
            if ( nrow( pvaluedf ) == 0 ) {
                myoc = rownames(mycoff)
                myoc = gsub("yearsbl:","y.",myoc)
                myoc = gsub("Negative","Neg",myoc)
                myoc = gsub("Positive","Pos",myoc)
                myoc = gsub("DXSubAsyn","",myoc)
                myoc = gsub(paste0("PD",subtypes[1]),"",myoc)
                outcomes = c("subtype",  myoc )
                noutcomes = length(outcomes)
                pvaluedf = data.frame( matrix(ncol=noutcomes) )
                colnames(pvaluedf )=outcomes
                tvaluedf=pvaluedf
            }
            tvaluedf[ct, outcomes] = c(subtype,mycoff[,"t value"])
            pvaluedf[ct, outcomes] = c(subtype,mycoff[,"Pr(>|t|)"])
            anvx = anova(bmdlx,mdlx)$Pr[2]
            anv = anova(bmdl,mdl)$Pr[2]
            pvaluedf[ct,'anova'] = anv
            pvaluedf[ct,'anovax'] = anvx
            tvaluedf[ct,'anat'] = pvaluedf[ct,'anat']=testvols
            if (  pvaluedf[ct,'anova'] < qthresh | pvaluedf[ct,'anovax'] < qthresh  )
                {
                nstring = getnstring( 'DXSubAsyn')
                pvformattedx=insight::format_p( anvx, stars=TRUE, digits=4 )
                pvformatted=insight::format_p( pvaluedf[ct,'anova'], stars=TRUE, digits=4 )
                cat( paste0( "\n\n****************************************************************\n\n" ) )
                cat( paste0( testvols," anv ", pvaluedf[ct,'anova'], " ****************\n\n" ) )
                print( mycoff[,-1] )
                mydegfree = round( (mycoff[,'df']) )
                meff = effectsize::t_to_d( mycoff[,'t value'], mydegfree )
                rownames(meff) = rownames(mycoff)
                myrownames = rownames(mycoff)
                myrownames = gsub("yearsbl","years",myrownames)
                myrownames = gsub("DXSubAsynPD","",myrownames)
                meffd = data.frame(meff)
                meffd$eff=myrownames
                meffd$anat = testvols
                meffd$dx = "Pos"
                meffd$dx[ grep("Neg",myrownames)]='Neg'
                if ( nrow(meffdall) == 0 ) meffdall=meffd else meffdall = rbind(meffdall,meffd)
                print( ggbarplot( meffd, 'eff','d', color='dx', fill='dx', 
                    palette='npg' ) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Long and cross effect sizes (d):",testvols)) + geom_errorbar(aes(ymin=CI_low, ymax=CI_high), width=.1,
                    position=position_dodge(.5))  )
                mypal = 'lancet'
                (prplot( mdlx,'yearsbl',  'DXSubAsyn',color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformattedx,"\n",nstring))) %>% print()
#                (prplot( mdl,  'yearsbl', 'DXSubAsyn', color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformatted,"\n",unlist(strsplit(nstring,"\n"))[2]))) %>% print()
                studydatasub$yearr=round( studydatasub$yearsbl )
                temp = table( studydatasub[,'PATNO'] )
                tsel = ( studydatasub$yearr %in% c(0,1,2,4) ) & 
                    studydatasub$PATNO %in% names(temp)[temp>=2]
                yername=gsub("T1Hier_","",testvols)
                yername=gsub("DTI_","",yername)
                yername=gsub("dktregions","",yername)
                yername=gsub("jhu","",yername)
                if ( TRUE ) {
                    nlevs = length( levels( studydatasub[,'DXSubAsyn'] ))
                    manualColors = pal_lancet("lanonc", alpha = 0.9)(nlevs)
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol_delta",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : change")) +
                        scale_colour_manual(values = manualColors ) )
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : raw")) +
                        scale_colour_manual(values = manualColors ) )
#                    ggscatter( studydata, 'yearsbl', "brainVolume", facet.by='DXSubAsyn', color='DXSubAsyn', add='reg.line', conf.int=T, cor.coef=T, parse=T, palette=manualColors ) %>% print()

                    # now test the TPL hypotheses
                    testcog=TRUE
                    if ( testcog ) {
                        subcohort = studydatasub[ studydatasub$DXSubAsyn != 'CNNegative',]
                        subcohortbl = studydatasub[ studydatasub$DXSubAsyn !=     
                            'CNNegative' &
                            studydatasub$imaging_EVENT_ID == 'V0', ]
                        myst = trainSubtypeUni( subcohortbl, "testvol",
                            c("Alow","Amid","Ahigh"), quantiles = c(0.33,0.66) )
                        subcohort = predictSubtypeUni( subcohort, myst, 'PATNO', 
                            'imaging_EVENT_ID', 'V0')
                        for ( cog in coggers ) {
                            cogform=paste( cog , "~", commcov, "+AsynStatus+subtype*yearsbl" )
                            cogmdl = try( lmer( cogform, data=subcohort ) )
                            cogcoff=coefficients(summary(cogmdl))
                            cogcoff=cogcoff[grep("subtype",rownames(cogcoff)),]
                            if ( any( cogcoff[,"Pr(>|t|)"] < 0.001 ) ) {
                                message(paste(testvols,cog))
                                print(paste("COGGER",cog))
                                print( cogcoff[,-c(1:2)] )
                                cogpvform = insight::format_p( 
                                    min(cogcoff[,"Pr(>|t|)"]),
                                    stars=TRUE, digits=4 )
                                (prplot( cogmdl,'yearsbl',  'subtype',color='subtype', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,"COGGER",cog,"\n",cogpvform))) %>% print()
                                pvaluedf[ct,cog]=min(cogcoff[,"Pr(>|t|)"])
                            }
                        }
                    }

                }
            }
        }
    }
    cat("****************\n\n")
} # subtype loop
##########################################################
##########################################################
if ( FALSE )
for ( subtype in subtypes[1:2] ) {
    print(subtype)
    pvaluedfsub = pvaluedf[ pvaluedf$subtype == subtype, ]
    sel=p.adjust( pvaluedfsub[,'anova'], corrmet ) <= 0.05
    print( pvaluedfsub[ sel, c("Neg","Pos","Y.Neg","Y.Pos","anat")] )
    cat(">>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<\n\n")
}
##########################################################
##########################################################
```


# Usage Notes

...

# Code availability

ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM).  
The version used for this work is `1.2.7` along with tensorflow `2.11.0`, antspyx `0.4.2`, antspynet `0.2.3` and antspyt1w `0.9.1`.

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work.

# Author contributions statement

...

# Competing interests

...

# Figures & Tables

Figures, tables, and their legends, should be included in the appropriate section of the document. Figures and tables can be referenced using Markdown syntax.

<!-- ![](stream.jpg) -->
Figure: Legend (350 words max). Example legend text.

| Condition | n  | p     |
|-----------|----|-------|
| A         | 5  | 0.1   |
| B         | 10 | 0.01  |
Table: Legend (350 words max). Example legend text.


