---
title: "Magnetic Resonance Imaging Data Phenotypes for the Parkinson's Progression Markers Initiative"
author:
  - Brian B. Avants^1,2^
  - Lino Becerra^1
  - Leon Fonville^3,†^
  - Olivia Hampton^1,†^
  - Alex Reardon^1,†^
  - Nicholas J. Tustison^2
  - Xue Wang^1,†^
  - Linda
  - Zahra
  - Adam
  - Roger Gunn^1
affiliation:
  - "1: Invicro, Boston, MA, FIMXE, USA"
  - "2: University of Virginia, Department of Radiology and Medical Imaging, Charlottesville, VA, FIXME, USE"
  - "3: Invicro, FIMXE, UK"
corresponding_author: "Brian B. Avants (stnava@gmail.com)"
contributed_equally: "† these authors contributed equally to this work"
output: 
  pdf_document:
    keep_tex: true
    template: null
#    citation_package: natbib
biblio-style: naturemag-doi
bibliography: ppmiscidata.bib
classoption: table
# header-includes:
#  - \usepackage{jabbrv}
linenumbers: true
urlcolor: blue
# nocite: '@*'
link-citations: true
---


```{r samplesizes,echo=FALSE,eval=TRUE}
npd=1000
ncn=500
ngpd=750
nprepd=300
nvizmed=3
redomerge=TRUE
```


```{r ppmimerge, echo=FALSE,eval=redomerge}
library(subtyper)
rdir=path.expand('~/code/multidisorder/data/')
curfn=paste0(rdir,'PPMI_Curated_Data_Cut_Public_20230612_rev.csv')
ppmidemog0=read.csv( curfn )
saa=read.csv( paste0(rdir,'PPMI_CSFSAA_09Oct2023/PPMI_CSFSAA_09Oct2023.csv') )
ppmi = merge( ppmidemog0, saa, by=c("PATNO","EVENT_ID"), suffixes = c(".x","") )
ppmi[ppmi=='.']=NA
rm( ppmidemog0 )
# pym = read.csv( paste0( rdir, 'ppmi_matched_qc_mm_processedCSVSRFIRST_v1.2.7.csv') )
pym = read.csv( paste0( rdir, 'ppmi_matched_qc_mm_processedCSV_v1.2.7.csv') )
pymf = pym[ , !(colnames(pym) %in% getNamesFromDataframe("u_hier_id", pym))] # junk
pymf = filterNAcolumns( pymf, 20 ) # remove columns with > 20% missing
pymf[ is.na(pymf$mrimfg), 'mrimfg' ]='Unk'
pymf[ is.na(pymf$mrimodel), 'mrimodel' ]='Unk'
rm(pym)
idcols = c("subjectID","date","subjectIDdate", "imageID",'filename')
head( pymf[ , idcols ] )
idcolsdemog = c("PATNO","visit_date","EVENT_ID")
head( ppmidemog[ , idcolsdemog ] )
clin2 = pymf
clin2$PATNO = pymf$subjectID

udx = sort(unique(ppmi$subgroup))
dxmapper = data.frame( ppmisubgroup=udx )
rownames(dxmapper)=udx
for ( gdx in c("GBA","LRRK2","PINK1","SNCA","PRKN") )
  dxmapper[ udx[grep(gdx,udx)],c('genetictype')]=gdx
dxmapper[is.na(dxmapper$genetictype),'genetictype']='Sporadic'
dxmapper["Healthy Control",'genetictype']='CN'
dxmapper["GBA",'jdx']='PDGBA'         # 1
dxmapper["GBA + Hyposmia",'jdx']='ProdromalGBA'         # 2
dxmapper["GBA + RBD + Hyposmia",'jdx']='ProdromalGBA'   # 3
dxmapper["Healthy Control",'jdx']='CN' # 4
dxmapper["Hyposmia",'jdx']='ProdromalSporadic' # 5
dxmapper["LRRK2",'jdx']='PDLRRK2'     # 6
dxmapper["LRRK2 + GBA",'jdx']='PDLRRK2'     # 7
dxmapper["LRRK2 + GBA + Hyposmia",'jdx']='ProdromalLRRK2'     # 8
dxmapper["LRRK2 + Hyposmia",'jdx']='ProdromalLRRK2'     # 9
dxmapper["PINK1",'jdx']='PDPINK1' # 10
dxmapper["PRKN",'jdx']='PDPRKN'   # 11
dxmapper["RBD",'jdx']='ProdromalSporadic' # 12
dxmapper["RBD + Hyposmia",'jdx']='ProdromalSporadic' # 13
dxmapper["SNCA",'jdx']='PDSNCA' # 14
dxmapper["SNCA + Hyposmia",'jdx']='ProdromalSNCA' # 15
dxmapper["Sporadic",'jdx']='PDSporadic'   # 16
clin2ppmi=unique( clin2$PATNO[ clin2$projectID == 'PPMI' ] )
ppmidx = ppmi[ , c("PATNO", 'COHORT', 'CONCOHORT', "subgroup")]
ppmidx$CONCOHORT[ ppmidx$CONCOHORT == 1  ]='PD'
ppmidx$CONCOHORT[ ppmidx$CONCOHORT == 2  ]='CN'
ppmidx$CONCOHORT[ ppmidx$CONCOHORT == 4  ]='Prodromal'
ppmidx$COHORT[ ppmidx$COHORT == 1  ]='PD'
ppmidx$COHORT[ ppmidx$COHORT == 2  ]='CN'
ppmidx$COHORT[ ppmidx$COHORT == 4  ]='Prodromal'
paireddx = data.frame( PATNO=clin2ppmi )
rownames(  paireddx )=clin2ppmi
clin2$joinedDX=NA
for ( uid in clin2ppmi ) {
        uid = as.character( uid )
        dx2=unique( ppmidx$subgroup[ subtyper::fs(ppmidx$PATNO == uid )])
        dx1=as.character(unique( clin2$joinedDX[ subtyper::fs(clin2$PATNO == uid )]))
        dx1new=dxmapper[dx2,'jdx']
        seluid = subtyper::fs(ppmidx$PATNO == uid )
        if ( sum(seluid) > 0 ) {
          ccdx=unique( ppmidx$CONCOHORT[ subtyper::fs(ppmidx$PATNO == uid )])
          ccdx2=unique( ppmidx$COHORT[ subtyper::fs(ppmidx$PATNO == uid )])
          stopifnot( length(ccdx)==1)
          mygroup=dxmapper[dx2,'genetictype']
          if ( dx2 == "Healthy Control" ) mygroup=""
          if ( !is.na(ccdx)) newjdx = paste0(ccdx,mygroup)
          if ( is.na(ccdx)) newjdx = paste0(ccdx2,mygroup)
          clin2$joinedDX[ subtyper::fs(clin2$PATNO == uid )]=newjdx
          paireddx[uid,c('ppmidx','ccdx', 'ccdx2', 'group', 'joinedDXNew')]=c(dx2,ccdx,ccdx2, mygroup, newjdx)
        }  else print(uid)
    }
paireddx$isConsensus=!is.na(paireddx$ccdx)
table( paireddx$ppmidx, paireddx$joinedDXNew  )
clin2$joinedDX[ clin2$joinedDX == 'CNGBA'] = 'CN'

head(clin2[ is.na(  clin2$ageatimaging ) , c(idcols,'joinedDX') ])

# message("HERE WE DEAL WITH STATS ASYN")
clin2$AsynStatus=NA
ppmi$CSFSAA[ ppmi$CSFSAA %in% c(2,3)]=NA
uids = unique( ppmi$PATNO[ !is.na( ppmi$CSFSAA)] )
for ( u in uids ) {
  clin2sel=clin2$PATNO == as.character(u)
  if ( sum(clin2sel) > 0 ) {
    suppas = unique(ppmi[ ppmi$PATNO == as.character(u), 'CSFSAA'])
    if ( 1 %in% suppas ) {
      suppas='Positive'
    } else if ( 0 %in% suppas ) {
      suppas='Negative'
    } else suppas=NA
    clin2[clin2sel,'AsynStatus']=suppas
  }
}

imagingdate=rep( NA, nrow( clin2 ) )
for ( k in 1:nrow( clin2 ) ) {
  imagingdate[k] = substr( unlist(strsplit( clin2$filename[k], '-' ))[3],0,4)
  }
clin2$imaging_year = imagingdate
demog=read.csv("~/code/multidisorder/data/ppmi_gwas/Demographics_06Feb2024.csv")
demog[demog=='.']=NA
testid="102529"
ppmi$PATNO=as.character(ppmi$PATNO)
demog$PATNO = as.character( demog$PATNO )
commonids = unique( intersect( ppmi$PATNO, demog$PATNO ) )
ppmi = merge( ppmi, demog, by='PATNO', all.x=TRUE )
rmnames=names(ppmi)[ grep("[.]y",names(ppmi))]
ppmi=ppmi[,!(names(ppmi) %in% rmnames)]
# names(ppmi)=gsub("[.]x","",names(ppmi))
ppmi$birthdate=ppmi$BIRTHDT
# convert birtdate to NRG format
for ( k in 1:nrow(ppmi) ) {
        if ( ! is.na( ppmi$BIRTHDT[k] ) ) {
            temp=unlist(strsplit(ppmi$BIRTHDT[k], "/"))
            ppmi$birthdate[k]=as.numeric(paste0(temp[2],temp[1],15)) # add the 15th as the estimated date
        }
    }
# now we can compute age at imaging using imaging date in addition to BIRTHDT
clin2$ageatimaging=NA
clin2$EVENT_ID=NA
clin2$clin_imaging_mismatch=TRUE
for ( k in 1:nrow( clin2 ) ) {
    subjectbdate = unique( ppmi$birthdate[ ppmi$PATNO == clin2$PATNO[k] ] )
    clin2$ageatimaging[k] = as.numeric( 
            difftime( 
                nrgDateToRDate( clin2$date[k] ), 
                nrgDateToRDate( subjectbdate ), units='weeks' )/52.0)
    # find the closest EVENT_ID using ageviz
    agesel=which( ppmi$PATNO == clin2$PATNO[k] )
    if ( length( agesel ) == 0 | is.na( clin2$ageatimaging[k] ) ) {
        next # this is like continue
        }
    locages=ppmi[agesel,'age_at_visit']
    closest=which.min( abs(clin2$ageatimaging[k]-locages))
    wclin = agesel[closest]
    clin2$EVENT_ID[k]=ppmi[wclin,'EVENT_ID.x']
    # select clin
    if ( length(wclin) == 1 ) {
        if ( ! exists("clin2add" ) ) {
            clin2add=names(ppmi)[ !(names(ppmi) %in% names(clin2) )]
            }
        clin2[k,clin2add]=ppmi[wclin,clin2add]
        clin2$clin_imaging_mismatch[k]=FALSE
        } else {
            stop("akred - should not reach this point")
            wclin = which(ppmi$PATNO == clin2$PATNO[k] )
            # find next closest match
            if ( length(wclin) > 0 ) {
                locclin=ppmi[wclin,]
                closest=which.min( abs(clin2$ageatimaging[k]-locclin$age_at_visit))
                clin2[k,clin2add]=locclin[closest,clin2add]
            }
        }
}

clin2$DX = NA
clin2$DX = 'CN'
clin2$DX[ clin2$CONCOHORT == 1 ]='PD'
clin2$DX[ clin2$CONCOHORT == 4 ]='Prodromal'
clin2$DXSubRaw=paste0( clin2$DX, "_", clin2$subgroup )
clin2$DXSub=NA
clin2$DXSub[ clin2$DX == 'CN' ]='CN'
ispd = which( clin2$DX == 'PD' )
ispro = which( clin2$DX == 'Prodromal' )
isgba = grep("GBA",clin2$subgroup)
islrrk2 = grep("LRRK2",clin2$subgroup)
isprkn = grep("PRKN",clin2$subgroup)
issnca = grep("SNCA",clin2$subgroup)
issporadic = grep("Sporadic",clin2$subgroup)
isprodspor = which( clin2$subgroup %in% c("Hyposmia","RBD","Sporadic","RBD + Hyposmia") )
clin2$DXSub[ intersect(ispd,issporadic) ]='PDSporadic'
clin2$DXSub[ intersect(ispd,islrrk2) ]='PDLRRK2'
clin2$DXSub[ intersect(ispd,isgba) ]='PDGBA'
clin2$DXSub[ intersect(ispro,isprodspor) ]='ProdromalSporadic'
clin2$DXSub[ intersect(ispro,islrrk2) ]='ProdromalLRRK2'
clin2$DXSub[ intersect(ispro,isgba) ]='ProdromalGBA'
isbl = clin2$EVENT_ID == 'BL'
print( table( clin2$DXSub[isbl], clin2$AsynStatus[isbl] ) )
isv4 = clin2$EVENT_ID == 'V04'
print( table( clin2$DXSub[isv4], clin2$AsynStatus[isv4] ) )
clin2$DXSubAsyn=NA
nna=!is.na(clin2$AsynStatus)
clin2$DXSubAsyn[ nna ]=paste0( clin2$DXSub[nna], clin2$AsynStatus[nna] )
clin2$DXSubAsyn[ is.na( clin2$AsynStatus)|is.na(clin2$DXSub)]=NA

# get the baseline age for imaging and the change in time
clin2$yearsbl=NA
clin2$age_BL=NA
clin2$imaging_EVENT_ID=NA
usubs=unique(clin2$PATNO)
for ( u in usubs ) {
    seller=clin2$PATNO == u
    losel = clin2[seller, ]
    minage=min(losel$ageatimaging,na.rm=T)
    clin2$age_BL[seller]=minage
    loy=losel$ageatimaging-minage
    clin2$yearsbl[seller]=loy
    clin2$imaging_EVENT_ID[seller]=paste0("V",round(loy*4))
    }
clin2$brainVolume = rowSums( clin2[,getNamesFromDataframe( c("T1Hier","vol","hemis"), clin2 )])
clin2$brainVolume = clin2$brainVolume/mean(clin2$brainVolume,na.rm=T)
clin2$mrimfg[ clin2$mrimfg == ""]="Unk"
clin2$APOE[ clin2$APOE == "" ] = "e3/e3"
clin2$abeta = as.numeric( clin2$abeta )
clin2$tau = as.numeric( clin2$tau )
clin2$DXSubAsyn = NA
nna=!is.na( clin2$AsynStatus )
clin2$DXSubAsyn[nna]=paste0(clin2$joinedDX[nna], clin2$AsynStatus[nna] )
updrsnames = c( getNamesFromDataframe( 'updrs' , clin2), 
  getNamesFromDataframe( 'moca' , clin2) )
for ( u in c(updrsnames,"duration_yrs") ) clin2[,u]=as.numeric( clin2[,u])
clin2bl=clin2[clin2$EVENT_ID=='BL',]
aggregate( updrs_totscore ~ DXSubAsyn, clin2bl, mean, na.rm=T )
negcnids = clin2bl$PATNO[ subtyper::fs(clin2bl$DXSubAsyn == 'CNPositive') ]
table( 
  clin2bl$subgroup[ subtyper::fs(clin2bl$PATNO %in% negcnids)  ],
  clin2bl$DXSub[ subtyper::fs(clin2bl$PATNO %in% negcnids)  ] )


clin2bl$DXSubAsyn[ subtyper::fs(clin2bl$PATNO %in% negcnids)  ]
clin2bl$DXSub[ subtyper::fs(clin2bl$PATNO %in% negcnids)  ]

table( 
  ppmi$subgroup[ subtyper::fs(ppmi$PATNO %in% negcnids)  ],
  ppmi$CONCOHORT[ subtyper::fs(ppmi$PATNO %in% negcnids)  ] )
##########################
clin2$commonID=clin2$PATNO
clin2$commonAge=clin2$age_BL
clin2$commonSex="Male"
clin2$commonSex[clin2$SEX ==0 ]="Female"
clin2$commonEdu=as.numeric( clin2$educ )
clin2$MOCA=clin2$moca
clin2$studyName = clin2$projectID
clin2$hy=as.numeric( clin2$hy )
clin2b = fillBaselineColumn( clin2,
        c('brainVolume','hy','MOCA'), 
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
# write.csv( clin2, '/tmp/ppmi.csv', row.names=FALSE )
# write.csv( clin2b, '/tmp/ppmib.csv', row.names=FALSE )
ppmi = clin2b
```


# Abstract

The Parkinson's Progression Markers Initiative (PPMI) delivers multiple modality MRI (M3RI) and biomarker data for a comprehensive longitudinal study of Parkinson's Disease (PD).  These provide quantitative indices of deep brain and cortical structure (T1-weighted MRI), axonal integrity (diffusion-weighted imaging) and resting brain function (resting state functional MRI).  Integrating and uniformly analyzing M3RI alongside non-imaging biological and clinical data is challenging due to the distinct nature of each modality. This study systematically organizes this complex data into a structured format, provides a PD-focused evaluation of the methodologies and evidence for technical robustness of the approach.  The cohort encompasses `r npd` idiopathic PD, `r ngpd` genetic PD, `r nprepd` presymptomatic PD and `r ncn` control subjects at baseline with a median number of `r nvizmed` followup visits.

# Background & Summary

Parkinson's Disease (PD) is characterized by the progressive accumulation of Lewy bodies, primarily composed of misfolded alpha-synuclein, and appearing in the substantia nigra at an early stage [@fearnley_ageing_1991]. The spread of this pathology correlates with both motor and non-motor symptoms of PD, underscoring alpha-synuclein's pivotal role in disease progression [@lee_mechanisms_2006;@dickson_neuropathology_2009;@calabresi_alpha-synuclein_2023]. The synuclein amplification assay (SAA) significantly advanced PD research by enabling in vivo confirmation for the first time. The Parkinson's Progression Markers Initiative (PPMI) study enhances this development by offering a comprehensive dataset of subjects assessed with SAA and multimodal MRI (M3RI), facilitating the monitoring of PD progression and the impact of synucleinopathy on brain structure and function [@shahnawaz_discriminating_2020; @siderowf_assessment_2023].

Analyzing the link between SAA status and longitudinal M3RI in the PPMI study necessitates accessible data representations for the PD research community. While each MRI modality provides distinct insights, their combined analysis is challenging due to the data's high dimensionality and computational demands. Therefore, creating clear, accessible data representations is crucial for advancing PD research and fostering new discoveries in particular using multi-view data linking pathology, symptoms and imaging [@nemmi_totally_2019; @tremblay_sex_2020; @markello_multimodal_2021].

The study utilizes the Advanced Normalization Tools X (ANTsX) ecosystem to process PPMI MRI from 2010 to 2023, focusing on T1-weighted, diffusion-weighted, and resting-state functional MRI for analyzing neurodegenerative diseases. The extended duration of data collection underscores the necessity for robust processing techniques that manage the resultant heterogeneity in images. ANTsX, leveraging decades of MRI analysis expertise, employs advanced techniques and integrates open science, deep learning, and machine learning for efficient multi-site M3RI data processing [@avants_pediatric_2015; 
@stone_functional_2020; @tustison_antsx_2020]

To establish face validity, this study leverages not only PPMI M3RI, but also traveling subject data in three cohorts [@hawco_longitudinal_2022; @tanaka_multi-site_2021; @tong_reproducibility_2019] and an additional easily accessible M3RI young control cohort [@avants_pediatric_2015].  We collectively analyze these data in a uniform manner to establish reliability benchmarks and demonstrate the empirical significance of multi-view data in predicting population characteristics from neuroimaging.  Additionally, we illustrate statistical models using PPMI data that are appropriate for unlocking key questions relevant to biomarker-confirmed PD. 

Historically, MRI research on PD has primarily utilized T1-weighted (T1w) structural imaging to investigate the neuroanatomical changes. A consistent finding across these studies has been the identification of early neurodegeneration in mid-brain regions, particularly the substantia nigra  [@schwarz_t1-weighted_2011;@aquino_substantia_2014;@ryman_mri_2020]. Diffusion-weighted MRI (dwMRI) has further enhanced our understanding by allowing for the investigation of white matter microstructural integrity which may be impacted not only in sporadic PD [@peran_magnetic_2010] but also in LRRK2-PD [@tolosa_lrrk2_2020]. Similarly, resting state functional MRI (rsfMRI) has unveiled alterations in network connectivity in PD patients, highlighting changes in the functional integration and segregation of brain networks involved in motor and cognitive functions [@hacker_resting_2012;@kim_abnormal_2017]. Taken together, these findings suggest that PD impacts both the structural and functional aspects of the brain, pointing towards a more integrative approach to understanding PD [@menke_mri_2009;@markello_multimodal_2021] and the role of alpha-synuclein in these effects [@simuni_biological_2024].

The present study extends previous foundations by providing standardized imaging data phenotypes (IDPs) for PPMI with a particular emphasis on an accessible tabular representation.  The summary IDPs depend on standard anatomical and functional hierarchies that are well-established in the field but are consistently integrated in this work across modalities.  This approach supports investigations based on T1w structural imaging, dMwRI, and rsfMRI either independently or collectively.  Importantly, these imaging variables easily merge with the associated demographics, SAA status, clinical data such as the Unified Parkinson's Disease Rating Scale (UPDRS) [@disease_unified_2003] and standard PPMI DAT-SPECT summary measurements [@bega_clinical_2021; @droby_aberrant_2022]. Through this integrative methodology, we aim to contribute to a deeper understanding of PD, facilitating the development of more effective diagnostic and therapeutic strategies and accelerating PD research.


# Methods

The Methods should include detailed text describing any steps or procedures used in producing the data...

## MRI data collection 

## Semi-automated quality assessment

Maybe this should not appear here ...

## Neuroanatomical coordinate systems

Neuroanatomical coordinate systems, such as Yeo's functional parcellations, the Desikan-Killiany-Tourville (DKT) system, and the Johns Hopkins University (JHU) white matter labels, play a critical role in brain imaging research. Yeo's parcellations categorize the cortex into distinct functional areas based on resting-state functional connectivity, facilitating the study of brain networks. The DKT system offers a detailed anatomical framework for cortical structures, enhancing morphological studies. JHU white matter labels provide essential references for analyzing white matter tracts, crucial for understanding brain connectivity and pathology.

Resting state functional MRI (rsfMRI) processing builds on prior multi-view techniques performed in this same ecosystem [(avants2015)](https://www.nature.com/articles/sdata20153) [avants2016](https://doi.org/10.1016/j.neurobiolaging.2018.10.002).  Diffusion tensor imaging (DTI) processing leverages best practices from both ANTsX and the collaborative DTI-focused project [DiPy](https://www.frontiersin.org/articles/10.3389/fninf.2014.00008/full). 

### T1-weighted MRI

The article "The ANTsX ecosystem for quantitative biological and medical imaging" by Nicholas J. Tustison et al. presents ANTsX, an open-source software ecosystem designed for processing and analyzing biological and medical imaging data. It highlights the integration of deep learning capabilities through ANTsR and ANTsPy for R and Python, respectively, enhancing computational efficiency and accuracy. The ecosystem includes tools for image registration, segmentation, and analysis, demonstrating superior performance in applications like cortical thickness measurement from MRI data. For further details, visit the [Nature article](https://www.nature.com/articles/s41598-021-87564-6).

The study enhances the UK Biobank neuroimaging structural Imaging-Derived Phenotypes (IDPs) by incorporating measurements from the Advanced Normalization Tools Ecosystem, alongside traditional software libraries like FSL and FreeSurfer. It includes cortical and subcortical measurements, morphological measurements of the hippocampus and cerebellum, among others. Through predictive modeling, the study assesses the clinical utility of these IDPs, exploring their predictive accuracy for various sociodemographic variables. The results highlight differences in performance across software libraries and the combined utility of IDP sets, underscoring the importance of selection and utilization in research.


### diffusion weighted MRI


The `joint_dti_recon` function embodies a comprehensive pipeline designed for the reconstruction and analysis of Diffusion Tensor Imaging (DTI) data, integrating several advanced neuroimaging preprocessing and analysis steps. This pipeline is particularly geared towards leveraging both left-right (LR) and right-left (RL) diffusion-weighted imaging (DWI) acquisitions, although the use of RL images is optional. The function is developed to accommodate various preprocessing needs, including motion correction, denoising, dewarping, and super-resolution enhancement, followed by DTI fitting. Furthermore, it incorporates atlas-based labeling and registration, facilitating anatomical interpretation of the DTI metrics.

### Technical Overview and Processing Steps

1. **Input Preparation**: The pipeline accepts DWI data in the LR direction as mandatory input, with optional RL direction data. It also requires associated b-values and b-vectors for each direction, alongside a T1-weighted image and a brain mask for improved spatial accuracy.

2. **Initial Reconstruction and Motion Correction**: The function initiates by optionally denoising the DWI data and performing motion correction, if specified. Motion correction aligns DWI volumes within and across acquisitions to a reference B0 image, reducing artifacts due to subject movement.

3. **Dewarping and Super-Resolution**: Dewarping is applied to correct for distortions using a specified modality (e.g., FA, average DWI), or a T1-weighted image. Optionally, a super-resolution model can be applied to enhance image quality, particularly useful when dealing with lower-resolution DWI data.

4. **Reconstruction of DTI Metrics**: The function employs a chosen fitting method (e.g., Weighted Least Squares - WLS) to reconstruct DTI metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD) from the preprocessed DWI data. This step is pivotal in quantifying the diffusion properties of brain tissue.

5. **Atlas-Based Labeling and Registration**: Utilizing the Johns Hopkins University (JHU) atlas and corresponding labels, the pipeline performs spatial registration of the DTI metrics to the atlas space. This process facilitates anatomical localization and quantification of DTI metrics within predefined brain regions.

6. **Output Generation**: The pipeline yields a comprehensive output including the reconstructed DTI metrics, summary statistics of these metrics within atlas-defined regions, the spatial registration information, and additional diagnostic metrics such as framewise displacement and signal-to-noise ratio (SNR) assessments.

### Advanced Features and Considerations

- **Denosing**: Incorporates a preliminary step to reduce noise in the DWI data, which is crucial for improving the quality of subsequent DTI metric reconstruction.

- **Imputation and Censoring**: Offers options to impute missing or corrupt data and to censor volumes with excessive motion, enhancing the robustness of the analysis against artifacts.

- **Atlas Registration**: Employs the JHU atlas for anatomical labeling, leveraging advanced registration techniques to accurately map DTI metrics onto anatomically defined regions, enhancing interpretability.

- **Super-Resolution Modeling**: Optionally applies a super-resolution model to the DWI data, aiming to improve spatial resolution and potentially uncover finer anatomical details not visible in the original data.

- **Customizability and Diagnostic Outputs**: Provides extensive customizability through parameters like the choice of dewarping modality and DTI fitting method, along with generating diagnostic outputs such as motion metrics and SNR, which are invaluable for quality assessment and troubleshooting.

### Academic Context and Implications

This function represents a sophisticated approach to DTI data analysis, integrating state-of-the-art neuroimaging techniques to address common challenges such as motion artifacts, spatial resolution limitations, and anatomical localization of diffusion metrics. By offering a pipeline that combines preprocessing, reconstruction, and atlas-based analysis within a single framework, it significantly streamlines the workflow for researchers and clinicians working with DTI data. Furthermore, the inclusion of diagnostic outputs facilitates a deeper understanding of data quality and analysis reliability, which are critical for rigorous neuroimaging research. The `joint_dti_recon` function, thus, not only enhances the efficiency and accuracy of DTI analysis but also contributes to the advancement of neuroscientific research and clinical diagnostics.

### resting state functional MRI
The function `resting_state_fmri_networks` is designed to compute correlation maps of resting-state networks from functional magnetic resonance imaging (fMRI) data, utilizing the J. Power labels to delineate major network systems. The function is structured to perform a sequence of preprocessing steps critical for resting-state fMRI analysis, including registration, despiking, anatomical segmentation, spatial and temporal smoothing, nuisance signal regression, band-pass filtering, censoring, fractional amplitude of low-frequency fluctuations (fALFF) calculation, and correlation analysis. This sequence is intended to enhance the signal-to-noise ratio and reduce artifacts, thereby isolating true neural signal fluctuations related to resting-state networks.

### Function Parameters and Their Academic Justification

- **fMRI Inputs**: The function accepts BOLD fMRI data (`fmri`), a reference fMRI template (`fmri_template`), and T1-weighted anatomical images (`t1` and `t1segmentation`). These inputs are foundational for aligning functional data with anatomical landmarks and for ensuring that subsequent analyses are anatomically informed.

- **Frequency Filtering (`f`)**: Implements band-pass filtering within the specified frequency range, typically between 0.03 and 0.08 Hz, following Shirer et al. (2015), to focus on the frequency band most relevant to resting-state fluctuations.

- **Spatial and Temporal Smoothing (`spa`, `spt`)**: Applies Gaussian smoothing kernels to the spatial and temporal dimensions of the data to increase the signal-to-noise ratio, an essential step for improving the reliability of resting-state network detection.

- **Component-Based Noise Correction (`nc`)**: Determines the number of components for CompCor, a method for reducing noise related to physiological and other non-neural signals, as per the methodology described by Shirer et al. (2015).

- **Independent Component Analysis (`ica_components`)**: Optionally includes ICA components to identify and remove sources of noise, enhancing the specificity of resting-state network identification.

- **Censoring and Despiking (`censor`, `despike`)**: Implements strategies to mitigate the impact of motion artifacts, including voxel-wise despiking and the exclusion of time points with excessive motion (Frame Displacement, `FD_threshold`).

- **Nuisance Regression (`motion_as_nuisance`)**: Incorporates motion parameters and their derivatives as nuisance regressors to control for motion-related artifacts, a critical step for isolating neural signals of interest.

- **Frequency Upsampling (`upsample`)**: Provides an option to isotropically upsample the data to a specified resolution during the registration process, facilitating improved alignment with the reference template.

### Computational Workflow

The computational workflow integrates several advanced neuroimaging analysis techniques:

1. **Preprocessing**: Initial steps include motion correction, application of a despiking algorithm akin to AFNI's 3dDespike, and anatomical registration to align the fMRI data with the T1-weighted image.
   
2. **Noise Reduction**: Techniques such as aCompCor and ICA-AROMA are used to mitigate physiological and other noise sources. This is based on recommendations from studies examining the impact of preprocessing strategies on functional connectivity (Ciric et al., 2017; Parkes et al., 2018).

3. **Band-pass Filtering**: The application of a specific frequency range for filtering aligns with recommendations from Shirer et al. (2015) and Parkes et al. (2018), emphasizing the importance of selecting appropriate frequency bands for resting-state analysis.

4. **Network Correlation Analysis**: The final step involves calculating correlation matrices for identified resting-state networks, utilizing labels from the J. Power atlas or the Yeo 17-network parcellation, depending on the user's selection.

### Theoretical Foundations and Empirical Support

The methodology implemented by `resting_state_fmri_networks` is grounded in the contemporary understanding of resting-state fMRI analysis. It incorporates recommendations from seminal works in the field, including Shirer et al. (2015) for component-based noise reduction, and leverages empirical findings regarding the optimal preprocessing strategies for minimizing motion artifacts and other sources of noise (Ciric et al., 2017; Parkes et al., 2018). The function's design reflects a comprehensive approach to resting-state fMRI preprocessing, aiming to facilitate the reliable extraction of functional connectivity patterns that are consistent with underlying neural mechanisms.

### Conclusion

In summary, the `resting_state_fmri_networks` function embodies a robust and empirically informed pipeline for the preprocessing and analysis of resting-state fMRI data. Through its sophisticated integration of noise reduction, artifact mitigation, and network analysis techniques, it offers a powerful tool for the exploration of resting-state neural networks, contributing to the broader understanding of brain connectivity patterns in health and disease.

# Data Records

The neuroimaging and associated standard PPMI demographics and clinical data is hosted in the LONI Imaging Data Archive (LONI IDA). The former is stored in DICOM format and the latter in tabular .csv format.  Additionally, data dictionaries describing all column headers are available on the LONI IDA.

We attach the neuroimaging data to the PPMI Curated Data Cut Curated (v.2023-06-12 `PPMI_Curated_Data_Cut_Public_20230612_rev`) available on the LONI IDA.  Code for this merging process is available.


# Technical Validation

The technical validity of these methods is supported by previous work, including various open quantitative MRI analysis challenges FIXME. We further this by demonstrating ANTsX reproducibility and reliability through analysis of three traveling subject cohorts and a young control cohort. By aggregating data from the traveling subject cohorts, we offer precise, reproducible reliability estimates (via intra-class correlation) across different scanner types and imaging modalities. The young control cohort, using the pediatric template of brain perfusion (PTBP) data, validates the utility of combining multi-modality tabular data processed by ANTsX to enhance predictions of population characteristics. In essence, our additional analyses furnish numerical benchmarks for reliability and predictive accuracy and may be extended to other contexts.

Symptoms of Parkinson's disease (PD) exhibit heterogeneity both across individuals and within a single patient over time.  Magnetic resonance imaging (MRI) is suited to objective *in vivo* characterization of the neural basis of these changes longitudinally with a variety of structural and functional measurements. 

## Multi-site reproducibility

## Multi-view prediction 

## PPMI case studies

Through metrics such as Fractional Anisotropy (FA) and Mean Diffusivity (MD), dMRI has provided evidence of altered white matter connectivity in PD, supporting the hypothesis of widespread neurodegenerative processes beyond the substantia nigra [(Talai2018)](https://www.sciencedirect.com/science/article/pii/S2213158218303036). 

The tabulated multi-modality MRI dataset derived from deeply validated open source methods represents a significant leap forward in PD M3MRI research. It simplifies the analysis of complex imaging data, potentially accelerating the discovery of novel insights into PD's progression and effects. Additionally, this methodology holds promise for broader applications, potentially benefiting research into other neurological conditions.

### effect of PRS

something here.  Linda?


```{r pkgs,echo=FALSE,eval=TRUE,messages=FALSE,cache=TRUE}
set.seed( 0 )
library( GoodmanKruskal )
library(heatmap3)
library("permute")
library(interactions)
library(reghelper)
library(MGMM) # GMM methods (FIXME)
library(WeightedCluster) # cluster quality (FIXME)
library( kmed ) # silhouette plots and such
library( clustree ) # cluster validation tools
library( factoextra )
library(flexclust)
library(tidyverse)
library(magrittr)
library(cluster)
library(cluster.datasets)
library(cowplot)
library(NbClust)
library(clValid)
library(ggfortify)
library(clustree)
library(dendextend)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(GGally)
library(ANTsR)
library(subtyper)
library(plyr)
library(data.table)
library(ztable)
library(moonBook)
library(kableExtra)
library(flextable)
library(plotly)
library( ztable )
library(ggpubr)
library(gridExtra)
library(ggsci)
options(digits=3)
library(lmerTest)
library(lme4)
library(mlr3verse)
library(Evacluster)
library( caret )
library( optmatch )
library( globaltest )
library(emmeans)
library(analyzer)
library(forcats)
options( ztable.type="html" )
tblcmd = ztable
buildsci=TRUE
```

```{r functions,echo=FALSE,eval=TRUE,warnings=FALSE,messages=FALSE,cache=FALSE}
scaleqvars <- function( mydf, myeq ) {
  myterms=all.vars(as.formula(myeq))[-1]
  myterms=intersect(myterms,colnames(mydf))
  for ( x in myterms ) {
    if ( is.numeric( mydf[,x] ))
      mydf[,x]=scale(mydf[,x])
  }
  return(mydf)
}

normalizersfmri = function( dd, applyit='none' ) {
  nums=c(122,129,134)
  t=c('_2_', "_falff", "_alff", "_peraf")
  tnm=c("fcnxmean" ,'falffmean', 'alffmean', 'perafmean')
  tns=c("fcnxsd" ,'falffsd', 'alffsd', 'perafsd')
  for ( k in 1:length(nums) ) {
    ct=0
    for ( tt in t ) {
      ct=ct+1
      protype=paste0("fcnxpro",nums[k])
      srch=c(t[ct],protype)
#      print( srch )
      mycolnm=getNamesFromDataframe( srch , dd )
#      print(head(mycolnm,2))
#      print(mycolnm  )
      mnnm=paste0( tnm[ct],"_",nums[k])
      sdnm=paste0( tns[ct],"_",nums[k])
#      print(paste(mnnm))
      dd[,mnnm]=apply( dd[, mycolnm], FUN=mean,MARGIN=1)
#      print(paste(sdnm))
      dd[,sdnm]=apply( dd[, mycolnm], FUN=sd,MARGIN=1)
#      print( paste( " apply ", applyit, mnnm ) )
      if ( applyit == 'mean' ) dd[,mycolnm]=dd[,mycolnm]-dd[,mnnm]
      if ( applyit == 'dividemean' ) dd[,mycolnm]=dd[,mycolnm]/dd[,mnnm]
      if ( applyit == 'meansd' ) {
        dd[,mycolnm]=(dd[,mycolnm]-dd[,mnnm])/dd[,sdnm]
      }
    }
  }
  return( dd )
}
```

```{r readdata,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE,cache=FALSE}
is_test = TRUE
if ( ! exists( "ppmi" ) ) {

  ppmifn = "../data/latest_ppmi_plus.csv"; myrez='or'
  ppmifn = "../data/latest_ppmi_plus_sr.csv"; myrez='sr'
  ppmifn = "../data/latest_ppmi_plus_sr_fmri_up.csv"; myrez='sr'
  ppmifn = '/tmp/ppmi.csv'
  ppmi = read.csv(ppmifn)
  ppmi = fillBaselineColumn( ppmi,
        c('brainVolume','hy','MOCA'), 
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
  mylevs = c( 
    "CN", "ProdromalLRRK2", "ProdromalGBA", "ProdromalSporadic", 
        "PDPRKN", "PDLRRK2", "PDGBA", "PDSporadic",
        "CBSPSP", "L_SD", "SV", "PNFA", "bvFTD",
        "SMC",  "MCI", "AD" ) 
  ppmi$joinedDX[ !(ppmi$joinedDX %in% mylevs) ]=NA
  ppmi$joinedDX = factor( ppmi$joinedDX, levels=mylevs )

}
```

### mixed effects diagnosis

```{r quicklmdx,echo=FALSE,eval=buildsci,fig.width=9,fig.height=3.5,warnings=FALSE,messages=FALSE}
######################################################################
######################################################################
dxform="~  (1|PATNO)+ (1|SITE) + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="~  (1|PATNO) + studyName + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform="  (1|PATNO)  + commonEdu +  age_BL + commonSex + brainVolume_BL "
dxform = paste( dxform, "  + yearsbl ")
# dxform = paste( dxform, " + DTI_dti_FD_mean + yearsbl ")
# dxform = paste( dxform, " + yearsbl ")
dxsel = c( "CN", "ProdromalSporadic",  "PDSporadic", "MCI", "AD" )
negate = c( "CNNegative",# "PDGBANegative",  #"PDLRRK2Negative", "PDSporadicNegative", 
  "ProdromalGBANegative", "ProdromalSporadicNegative" , "ProdromalLRRK2Negative")
posate = c( #"CNPositive",  
"ProdromalGBAPositive", "ProdromalLRRK2Positive", "ProdromalSporadicPositive" )
posate = c( "ProdromalSporadicPositive","PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive" )
ispd = c(   "PDSporadicPositive"  )
ispd = c( "PDGBAPositive", "PDLRRK2Positive",  "PDSporadicPositive", "MCIPositive"  )
ysel = ppmi$yearsbl <= 4.5 
dxsel2 = ppmi$DXSubAsyn %in% c(
  negate, posate, ispd ) & ysel 
mylevsx0=c( "CNNegative", "PDSporadicPositive", "MCINegative", "ADNegative" )
mylevsx1=c( "CN", "ProdromalSporadic", "PDSporadic", "MCI", "AD" )
temp = ppmi[ ppmi$studyName %in% c('PPMI','ADNI') & 
  ppmi$commonAge <= 800 &
#  ppmi$DXSubAsyn %in%  mylevsx0[c(1,2,3)]&  
#  ppmi$joinedDX %in%  mylevsx1[c(1,2,3)] &  
#  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2" ) ) &
  subtyper::fs( ppmi$joinedDX %in% c( "CN","PDLRRK2","PDSporadic" ) ) &
  ysel & ppmi$T1Hier_resnetGrade > 1.05,]
temp = normalizersfmri( temp )
temp$joinedDX <- fct_relevel(temp$joinedDX, "CN")
temp$DXSubAsyn <- fct_relevel(temp$DXSubAsyn, "CNNegative")
temp$TDX = NA # as.character( temp$DXSubAsyn )
temp$TDX[ temp$AsynStatus == 'Negative' & temp$joinedDX == 'CN' ]='CN'
# temp$TDX[ temp$DXSubAsyn %in% ispd ]='otherPositive'
# temp$TDX[ temp$DXSubAsyn  == 'PDLRRK2Positive' ]='DX'
mydx='PDSpNeg'
temp$TDX[ temp$DXSubAsyn  == 'PDSporadicNegative' ]='DX'
#temp$joinedDX = factor( temp$joinedDX, levels = mylevsx1)
#temp$DXSubAsyn = factor( temp$DXSubAsyn, levels = mylevsx0)
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_n_outliers < 100 ) &
#  subtyper::fs( ppmi$rsfMRI_fcnxpro122_FD_mean <= 0.5 ) &
#  !is.na(ppmi$AsynStatus) & ppmi$T1Hier_resnetGrade > 1.05,]


temp = antspymm_predictors(temp, TRUE )
idps = antspymm_predictors(temp, TRUE, TRUE )
subjectcount = table( temp$commonID )
mysubs = names(  subjectcount > 1 )
temp = temp[ temp$commonID %in% mysubs , ]
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass')
rsfnames = getNamesFromDataframe( c("rsfMRI_fcnxpro"),  ppmi, exclusions=xcl )
rsfnamescnx = getNamesFromDataframe( c("rsfMRI_fcnxpro","_2_"),  ppmi, exclusions=xcl )
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
idps = unique( c( rsfnames, dtinames ) ) 
dxvar = 'AsynStatus'
dxvar = 'joinedDX'
dxvar = 'DXSubAsyn'
dxvar = 'TDX'
temp = temp[ !is.na( temp[,dxvar]), ]
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), temp ),
  getNamesFromDataframe( c("DTI","Asym"), temp ) )
idpst1 = c( getNamesFromDataframe(c("T1Hier","cit168","vol"),temp, exclusions=c("left","right")), getNamesFromDataframe(c("T1Hier","dktcortex","thk"),temp, exclusions=c("left","right")) )

######################################
# print( table( temp[,dxvar]))
temp = fillBaselineColumn( temp,
        c( idpst1, rsfnamescnx, dtinamesasymlr, 'hy' ),
        'commonID', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
temp$hy_BL[ is.na( temp$hy_BL ) & temp$joinedDX == 'CN' ]=0
temp$hy_BL[ is.na( temp$hy_BL ) & temp$joinedDX != 'CN' ]=2
temp$hy_BL = factor( temp$hy_BL )
######################################
nmstotest = idpst1
mycorr = 'BY'
if ( is_test ) {
  nmstotest = idpst1[ grep("_gp",idpst1)]
  mycorr='none'
}
dxdf=data.frame()
for ( voi in nmstotest ) {
  n=nrow(dxdf)+1
  vois = paste0( voi, c("_BL", "_delta" ) )
  bform = paste( vois[2], " ~ hy_BL + ", vois[1], "+", dxform )
  bform = paste( vois[2], " ~ 1 + ", vois[1], "+", dxform )
  bform = paste( voi, " ~ 1+", dxform )
  newform = paste( bform, " * ", dxvar  )
  temp2 = temp[ !is.na( temp[,voi]), ]
#  temp2[,vois[2]]=psych::winsor( temp2[,vois[2]], 0.005 )
  mdl=lmer( newform, data=temp2 )
  temp3 = temp2[ names(predict(mdl)),]
  temp3 = scaleqvars( temp3, newform )
  mdl=lmer( newform, data=temp3 )
  bmdl=lmer( bform, data=temp3 )
  mycoffs = coefficients( summary( mdl ) )
  anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
  dxdf[n,'voi']=voi
  dxdf[n,'anv']=anvp
  dxdf[n,'tyears']=mycoffs[ 'yearsbl', 4]
  dxdf[n,'tcross']=mycoffs[ nrow(mycoffs)-1, 4]
  dxdf[n,'tlong']=mycoffs[ nrow(mycoffs), 4]
  dxdf[n,'res']=myrez
  dxdf[n,'singular']=isSingular(mdl)
#  if ( any(  mycoffs[ multigrep( c("PD","MCI"),rownames(mycoffs)), 5 ] < 1e-3 ) ) {
  if ( anvp < 1e-2 ) {
#    print( mycoffs )
#    print( dxdf[n,] )
    anvp = insight::format_p( anvp, digits=4 )
    ttl=( paste( voi, myrez, " + ", mydx,  " : ", anvp ) )
    print(prplot( mdl, 'yearsbl', dxvar, ttl, colorvar='commonSex', addpoints=1))
  }
}

psel = subtyper::fs( p.adjust( dxdf$anv, mycorr ) <= 0.05 )
```

```{r dxresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
temp = dxdf[psel,]
temp[,'dx']=mydx
temp$anv = insight::format_p(  temp$anv, digits=4  )
temp[, !(colnames(temp) %in% c("singular"))] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```


### mixed effects UPDRS changes over time

```{r quicklmcog,echo=FALSE,eval=buildsci,fig.width=9,fig.height=4.0,warnings=FALSE,messages=FALSE}
####################################################################
num=c(122,129,134)[1]
signas = c( "SIGNA_Architect", "SIGNA_EXCITE" ,   "GENESIS_SIGNA"  )
ysel = ppmi$yearsbl <= 4.5
mylevsx2=c( "CN", "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "ProdromalSporadic", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "PDSporadic" )
mylevsx2=c(   "PDLRRK2", "PDGBA", "PDSporadic" )
mylevsx2=c(  "CN", "ProdromalSporadic", "PDLRRK2", "PDGBA", "PDSporadic" )
temp = ppmi[ ppmi$studyName %in% c('PPMI','ADNI') & 
#  !is.na( ppmi[,paste0( 'rsfMRI_fcnxpro',num,'_FD_mean')] ) &
#  subtyper::fs( 
    # ppmi$NM2DMT_NM_substantianigra_z_coordinate >= 0.20 &
    # ppmi$NM2DMT_NM_substantianigra_z_coordinate <= 0.8 & 
#    ppmi$NM2DMT_NM_avg_substantianigra < 1800 )  &
#  subtyper::fs( !(ppmi$mrimodel %in% signas ) ) &
  ppmi$joinedDX %in%  mylevsx2 &
  subtyper::fs(ppmi$AsynStatus == 'Positive') &
  ysel &ppmi$T1Hier_resnetGrade >= 1.05,]
if ( myrez == "sr" ) {
#  write.csv( temp[,'filename'], '/tmp/temp_ids.csv', row.names=FALSE )
} else {
#  tempids = read.csv( '/tmp/temp_ids.csv' )
#  temp = temp[ temp[,'u_hier_id'] %in% tempids$x, ]
}
temp = normalizersfmri( temp )
#########################################################
temp$joinedDX <- fct_relevel(temp$joinedDX, "CN")
temp$DXSubAsyn <- fct_relevel(temp$DXSubAsyn, "CNNegative")
temp$NM2DMT_NM_diff = temp$NM2DMT_NM_avg_substantianigra - temp$NM2DMT_NM_avg_refregion
temp$NM2DMT_NM_range = temp$NM2DMT_NM_q0pt95 - temp$NM2DMT_NM_q0pt05
temp = antspymm_predictors( temp, TRUE )
idps = antspymm_predictors( temp, TRUE, TRUE )
idpst1 = c( 
  idps[ multigrep(c("thk","dktcortex","LRAVG"), idps, intersect=TRUE )],
  idps[ multigrep(c("thk","dktcortex","Asym"), idps, intersect=TRUE )],
  idps[ multigrep(c("vol","cit168","LRAVG"), idps, intersect=TRUE )],
  idps[ multigrep(c("vol","cit168","Asym"), idps, intersect=TRUE )])
nmidps = getNamesFromDataframe( c("NM2DMT"), temp, 
  exclusions=c(xcl,"_q","min","sd","pt","count","_BL","_delta","coordinate"))
subjectcount = table( temp$commonID )
mysubs = names(  subjectcount > 0 )
temp = temp[ temp$commonID %in% mysubs , ]
xcl = c( "evr", "snr", "dvars","FD","motion","file","wide","SNR","_nc_",'paramset','u_hier_','censor', 'bandpass',"_BL", "outlier_threshold")
#########################################################
dtinames = getNamesFromDataframe( c("DTI_"), ppmi, exclusions=c( xcl, 'cnx','volume') )
fdnames = getNamesFromDataframe( "_FD_", ppmi  )
# dxvar = 'joinedDX'
dtinamesasymlr = c( 
  getNamesFromDataframe( c("DTI","LRAVG"), temp, exclusions=c('_BL',"_delta" )),
  getNamesFromDataframe( c("DTI","Asym"), temp, exclusions=c('_BL',"_delta") ) )
#######################################################
rsfnames = getNamesFromDataframe( paste0(c("rsfMRI_fcnxpro"),num),  ppmi, exclusions=xcl )
rsfnamescnx = getNamesFromDataframe( c(paste0(c("rsfMRI_fcnxpro"),num),"_2_"),  ppmi, exclusions=xcl )
#######
fdnames = getNamesFromDataframe( "_FD_", temp  )
cogs = getNamesFromDataframe( c("updrs","score"), temp, exclusions=c(4,'_BL',"_delta") )
temp = fillBaselineColumn( temp,
        c(dtinamesasymlr,rsfnames,idpst1, nmidps, fdnames, cogs ), 
        'PATNO', 'yearsbl', 0, 
        fast=T, verbose=F )[[1]]
#########################################################
#########################################################
temp$hy_BL = factor( temp$hy_BL )
# for ( voi in sample( c(rsfnames,dtinamesasymlr) ) ) {
stadfrsf=data.frame()
nmstotest = sort( rsfnamescnx )
qth=1e-4
if ( is_test ) {
  nmstotest = sample( nmstotest, 10 )
  qth=0.01
}
for ( cog in sort(cogs) ) {
  for ( voi in nmstotest ) {
    n = nrow(stadfrsf)+1
#    if ( n %% 10 == 0 ) print(stadfrsf[which.min(stadfrsf$anv),])
    voi = paste0(voi,"_BL")
    motname = paste( 
      paste0( "rsfMRI_fcnxpro",num,"_n_outliers_BL"), " + ",
      paste0( "rsfMRI_fcnxpro",num,"_FD_mean_BL") )
    cogformcommon=paste( cog, "  ~ (1|PATNO) + AsynStatus + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + brainVolume_BL + ", motname, " + age_BL + commonSex + AsynStatus + yearsbl" )
    cogformcommon=paste( paste0(cog,"_delta"), "~ ",paste0(cog,"_BL"),"+ (1|PATNO) + joinedDX  + duration_yrs + LEDD + commonEdu + age_BL + commonSex + brainVolume_BL + ( yearsbl )" )
#    cogformcommon=paste( cog  , "~  (1|PATNO) + commonSex + brainVolume_BL + ( yearsbl )")
    temp2 = temp[ !is.na( temp[,voi]) & temp$yearsbl < 5.85, ]
    temp2[,voi]=psych::winsor( temp2[,voi], 0.005)
    temp2[,paste0(cog,"_delta")]=psych::winsor( temp2[,paste0(cog,"_delta")], 0.005)
#    temp2[,voi]=temp2[,voi]/temp2$NM2DMT_NM_range
    newform = paste(  cogformcommon, " * ", voi )
    temp2 = scaleqvars( temp2, newform )
    bmdl=suppressMessages(lmer( cogformcommon, data=temp2 ))
    mdl=suppressMessages(lmer( newform, data=temp2 ))
    mycoffs = coefficients( summary( mdl ) )
  #  if ( any(  mycoffs[ multigrep( voi,rownames(mycoffs)), 5 ] < 1e-2 ) ) {
    anvp = suppressMessages( anova(bmdl,mdl)$Pr[2] )
    stadfrsf[n,'cog']=cog
    stadfrsf[n,'voi']=voi
    stadfrsf[n,'anv']=anvp
    stadfrsf[n,'res']=myrez
    stadfrsf[n,'singular']=isSingular(mdl)
    if ( anvp < qth ) {
#      print( mycoffs[ , -c(1:3)] )
  #    print( voi )
      anvp = insight::format_p( anvp, digits=4 )
      ttl=( paste( voi, myrez, " + ", cog,  " : ", anvp ) )
 #     mygg = visreg::visreg( mdl, 'yearsbl', by=voi, gg=T )
 #     threewayinteraction( temp2, 'yearsbl', cog,  'AsynStatus', voi, showpoints=F )
#      print(prplot( mdl,  voi, 'yearsbl',ttl, colorvar='commonSex', addpoints=1))
      print(prplot( mdl, 'yearsbl', voi, ttl, ystring=paste('change in',cog), colorvar='commonSex', addpoints=1))
#      visreg::visreg( mdl, 'yearsbl', by=voi, main=ttl  )
    }
  }
}
#####################
qdf=data.frame()
for ( cog in cogs ) {
  mypvs = stadfrsf$anv
  mypvs[ stadfrsf$cog != cog  ] = NA
  psel = subtyper::fs( p.adjust( mypvs, mycorr ) <= 0.05 )
  siganat = stadfrsf$voi[ psel ]
  if ( sum(psel) > 0 )
    qdf = rbind( qdf, stadfrsf[psel,] )
  }
###########################################################################
###########################################################################
###########################################################################
```

```{r cogresults,echo=FALSE,eval=buildsci,warnings=FALSE,messages=FALSE}
qdf$anv = insight::format_p(  qdf$anv, digits=4  )
qdf[,c("cog","voi","anv","res")] %>%
  knitr::kable("latex", booktabs = TRUE) %>%
  kableExtra::kable_styling(latex_options = c("striped", "scale_down"))
```

### mixed models


```{r lmerextab,echo=FALSE,eval=FALSE,fig.width=12,fig.height=6,messages=FALSE,warnings=FALSE,cache=FALSE}
knitr::opts_chunk$set(cache.path = odir )
###################################################
pvaluedf = tvaluedf = data.frame()
meffdall = data.frame()
ct = 0
subtypes = c( 'LRRK2', 'Sporadic' ) # GBA
# subtypes = c('LRRK2' ) # GBA
for (  subtype in subtypes ) {
    dxs = c("CNNegative", paste0("PD",subtype,c("Negative","Positive") ) )
    ssel = subtyper::fs( clin$DXSubAsyn %in% dxs ) & commonsel
    studydata = clin[ssel,]
    print( table(round(studydata$yearsbl), studydata$DXSubAsyn) )
    sage=data.frame( stats::poly( studydata$age_BL , 2 ) )
    colnames(sage)=c("Age1","Age2")
    studydata=cbind(studydata,sage)
    studydata$SEX = factor( studydata$SEX )
    if ( FALSE ) {
        studydata$DXSubAsyn = paste0( studydata$DXSubAsyn, studydata$SEX )
        dxs2=c()
        for ( dx in dxs ) dxs2=c(dxs2,paste0(dx,levels(studydata$SEX)))
        dxs=dxs2
        }
    studydata[,'DXSubAsyn']=factor(studydata[,'DXSubAsyn'],levels=dxs)
    studydata$duration_yrs = as.numeric( studydata$duration_yrs )
    studydata$cnxtot = rowSums( studydata[,cnxnames] )
    studydata[,cnxnames]=studydata[,cnxnames]/studydata$cnxtot
    normalizeit=FALSE
    if ( normalizeit ) {
        studydata[,mdnames]=studydata[,mdnames]/studydata$meanmd
        studydata[,thknames]=studydata[,thknames]/studydata$meanthick
        }
    testnames = unique( c( t1names, dtinames, rsfnames ) )
    if ( winsval == 0.0 ) {
        isna=is.na( studydata[,testnames] )
        temp = ANTsR::robustMatrixTransform(studydata[,testnames])
        temp[ isna ]=NA
        studydata[,testnames]=temp
        }
    ####################################
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_l_", testnames) ], '_l_', "_r_" )
    studydata=mapAsymVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    studydata=mapLRAverageVar( studydata, 
        testnames[ grep("_left", testnames) ] )
    testnames = c( 
        getNamesFromDataframe( "Asym" , studydata ),
        getNamesFromDataframe( "LRAVG" , studydata ) )
    countdtinz=rep(NA,length(testnames))
    for ( x in 1:length(testnames) ) {
        countdtinz[x]=sum( !is.na(studydata[,testnames[x]]) & studydata[,testnames[x]] > 0)
    }
    testnames=testnames[ countdtinz > 100 ]
#    testnames = testnames[ -grep("Asym",testnames)]
    studydata$meanthick = rowMeans( studydata[,thknames])
    studydata$meanmd = rowMeans( studydata[,mdnames])
    testnames = c( testnames, midnames )
    studydata = fillBaselineColumn( studydata,
        c('meanthick','meanmd','brainVolume',testnames,'hy','MOCA'), 
        'PATNO', 'imaging_EVENT_ID', 'V0', 
        fast=T, verbose=F )[[1]]
    for ( x in  c('meanthick','meanmd','brainVolume',testnames) ) {
#        studydata=baseimpute( studydata, x )
#        studydata=visitimpute( studydata, x, 2 )
        }
    if ( FALSE )
        testnames = c( 
            "T1Hier_vol_bn_gp_gpe_LRAVGdeep_cit168",
            'T1Hier_vol_bn_str_pu_LRAVGdeep_cit168','DTI_mean_md_Asym_rostral_middle_frontal')
    for ( testvols in testnames ) {
        ct = ct + 1
        studydata$testvol = studydata[ ,testvols]
        studydata$testvol_BL = studydata[ ,paste0(testvols,"_BL")]
        studydata$testvol_delta = studydata[ ,paste0(testvols,"_delta")]
        studydata$testvol_delta = psych::winsor(studydata$testvol_delta,tr=winsval)
        studydata$SEX = factor( studydata$SEX )
        toscale = c('snr','psnr','EVR','age_BL','DTI_dti_FD_mean','T1Hier_resnetGrade','DTI_dti_tsnr_b0_mean','testvol_BL','brainVolume_BL','EDUCYRS', 'MOCA_BL', 'hy_BL' )
        studydata$EDUCYRS=as.numeric(studydata$EDUCYRS)
        studydata[,toscale]=scale(studydata[,toscale])
        studydata$EDUCYRS = scale(ANTsRCore::antsrimpute(as.numeric( studydata$EDUCYRS )))
        covars=covars0
        covarsx=covars0x
        if ( length(grep("DTI_",testvols)>1 ) ) {
            covars=paste(covars0,dticovars)
            covarsx=paste(covars0x,dticovars)
        }
        bform=paste( covars, " + yearsbl ")
        myform=paste( covars, " + yearsbl * ( DXSubAsyn )")
        # https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3281513/
        # section: Advantages and Disadvantages of Fixed Main Effect for Site
        bformx=paste( "testvol~",covarsx, " + yearsbl ")
        myformx=paste( "testvol~",covarsx, " + yearsbl * ( DXSubAsyn )")
        isblsub = studydata$PATNO[ studydata$imaging_EVENT_ID=='V0' ]
        isfsub = studydata$PATNO[ studydata$imaging_EVENT_ID !='V0' ]
        isboth = intersect( isblsub, isfsub )
        studydatasub = studydata[ studydata$PATNO %in% isboth,]
        bmdl = try( lmer( bform,data=studydata ) )
        mdl = try( lmer( myform,data=studydata ) )
        bmdlx = lmer( bformx,data=studydata )
        mdlx = lmer( myformx,data=studydata )
        if ( FALSE ) {
            # simple regression for BL vs follow
            lmdata = data.frame( )
            fillvars = all.vars( as.formula( myform ) )
            rmers = multigrep( c("testvol_delta","testvol","PATNO",#"yearsbl",
                "DTI_dti_tsnr_b0_mean","mrimfg"), fillvars, intersect=FALSE )
            lmform = paste( fillvars[1], "~(1|PATNO)+testvol_BL+",paste(fillvars[-rmers],collapse="+"))
            mdlLM = lmer( lmform,data=studydatasub)
#            mycoffsX = coefficients(summary( mdlLM ))
#            if ( any(tail(mycoffsX[,"Pr(>|t|)"],2) < 0.005 )) {
#                print( visreg::visreg(mdlLM,'DXSubAsyn',gg=TRUE)+ggtitle(testvols))
#                print( mycoffsX )
#                print( testvols )
#                }
            }
        if ( !is( mdl, "try-error" ) ) {
            mycoffx = coefficients(summary(mdlx))[-c(1:2),-c(1:2)]
            mycoffx = mycoffx[ grep(subtype,rownames(mycoffx)), ]
            mycoffx = mycoffx[ -grep("yearsbl",rownames(mycoffx)),]
            mycoff = coefficients(summary(mdl))[-c(1:2),-c(1:2)]
#            mycoff = mycoff[ grep(subtype,rownames(mycoff)), ]
            mycoff = rbind(
                mycoffx[grep(subtype,rownames(mycoffx)),],
                mycoff[multigrep(c("yearsbl",subtype),rownames(mycoff),intersect=T),])
            if ( nrow( pvaluedf ) == 0 ) {
                myoc = rownames(mycoff)
                myoc = gsub("yearsbl:","y.",myoc)
                myoc = gsub("Negative","Neg",myoc)
                myoc = gsub("Positive","Pos",myoc)
                myoc = gsub("DXSubAsyn","",myoc)
                myoc = gsub(paste0("PD",subtypes[1]),"",myoc)
                outcomes = c("subtype",  myoc )
                noutcomes = length(outcomes)
                pvaluedf = data.frame( matrix(ncol=noutcomes) )
                colnames(pvaluedf )=outcomes
                tvaluedf=pvaluedf
            }
            tvaluedf[ct, outcomes] = c(subtype,mycoff[,"t value"])
            pvaluedf[ct, outcomes] = c(subtype,mycoff[,"Pr(>|t|)"])
            anvx = anova(bmdlx,mdlx)$Pr[2]
            anv = anova(bmdl,mdl)$Pr[2]
            pvaluedf[ct,'anova'] = anv
            pvaluedf[ct,'anovax'] = anvx
            tvaluedf[ct,'anat'] = pvaluedf[ct,'anat']=testvols
            if (  pvaluedf[ct,'anova'] < qthresh | pvaluedf[ct,'anovax'] < qthresh  )
                {
                nstring = getnstring( 'DXSubAsyn')
                pvformattedx=insight::format_p( anvx, stars=TRUE, digits=4 )
                pvformatted=insight::format_p( pvaluedf[ct,'anova'], stars=TRUE, digits=4 )
                cat( paste0( "\n\n****************************************************************\n\n" ) )
                cat( paste0( testvols," anv ", pvaluedf[ct,'anova'], " ****************\n\n" ) )
                print( mycoff[,-1] )
                mydegfree = round( (mycoff[,'df']) )
                meff = effectsize::t_to_d( mycoff[,'t value'], mydegfree )
                rownames(meff) = rownames(mycoff)
                myrownames = rownames(mycoff)
                myrownames = gsub("yearsbl","years",myrownames)
                myrownames = gsub("DXSubAsynPD","",myrownames)
                meffd = data.frame(meff)
                meffd$eff=myrownames
                meffd$anat = testvols
                meffd$dx = "Pos"
                meffd$dx[ grep("Neg",myrownames)]='Neg'
                if ( nrow(meffdall) == 0 ) meffdall=meffd else meffdall = rbind(meffdall,meffd)
                print( ggbarplot( meffd, 'eff','d', color='dx', fill='dx', 
                    palette='npg' ) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=0.5))+ggtitle(paste("Long and cross effect sizes (d):",testvols)) + geom_errorbar(aes(ymin=CI_low, ymax=CI_high), width=.1,
                    position=position_dodge(.5))  )
                mypal = 'lancet'
                (prplot( mdlx,'yearsbl',  'DXSubAsyn',color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformattedx,"\n",nstring))) %>% print()
#                (prplot( mdl,  'yearsbl', 'DXSubAsyn', color='DXSubAsyn', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,pvformatted,"\n",unlist(strsplit(nstring,"\n"))[2]))) %>% print()
                studydatasub$yearr=round( studydatasub$yearsbl )
                temp = table( studydatasub[,'PATNO'] )
                tsel = ( studydatasub$yearr %in% c(0,1,2,4) ) & 
                    studydatasub$PATNO %in% names(temp)[temp>=2]
                yername=gsub("T1Hier_","",testvols)
                yername=gsub("DTI_","",yername)
                yername=gsub("dktregions","",yername)
                yername=gsub("jhu","",yername)
                if ( TRUE ) {
                    nlevs = length( levels( studydatasub[,'DXSubAsyn'] ))
                    manualColors = pal_lancet("lanonc", alpha = 0.9)(nlevs)
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol_delta",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : change")) +
                        scale_colour_manual(values = manualColors ) )
                    print( plotSubtypeChange( studydatasub[tsel,],
                        idvar='PATNO', 'DXSubAsyn',
                        measurement="testvol",
                        vizname='yearr', 'se', xlab='yr from v0' ) + 
                        ggtitle(paste(yername," : raw")) +
                        scale_colour_manual(values = manualColors ) )
#                    ggscatter( studydata, 'yearsbl', "brainVolume", facet.by='DXSubAsyn', color='DXSubAsyn', add='reg.line', conf.int=T, cor.coef=T, parse=T, palette=manualColors ) %>% print()

                    # now test the TPL hypotheses
                    testcog=TRUE
                    if ( testcog ) {
                        subcohort = studydatasub[ studydatasub$DXSubAsyn != 'CNNegative',]
                        subcohortbl = studydatasub[ studydatasub$DXSubAsyn !=     
                            'CNNegative' &
                            studydatasub$imaging_EVENT_ID == 'V0', ]
                        myst = trainSubtypeUni( subcohortbl, "testvol",
                            c("Alow","Amid","Ahigh"), quantiles = c(0.33,0.66) )
                        subcohort = predictSubtypeUni( subcohort, myst, 'PATNO', 
                            'imaging_EVENT_ID', 'V0')
                        for ( cog in coggers ) {
                            cogform=paste( cog , "~", commcov, "+AsynStatus+subtype*yearsbl" )
                            cogmdl = try( lmer( cogform, data=subcohort ) )
                            cogcoff=coefficients(summary(cogmdl))
                            cogcoff=cogcoff[grep("subtype",rownames(cogcoff)),]
                            if ( any( cogcoff[,"Pr(>|t|)"] < 0.001 ) ) {
                                message(paste(testvols,cog))
                                print(paste("COGGER",cog))
                                print( cogcoff[,-c(1:2)] )
                                cogpvform = insight::format_p( 
                                    min(cogcoff[,"Pr(>|t|)"]),
                                    stars=TRUE, digits=4 )
                                (prplot( cogmdl,'yearsbl',  'subtype',color='subtype', addpoints=1, palette=mypal )+ ggtitle(paste(testvols,"COGGER",cog,"\n",cogpvform))) %>% print()
                                pvaluedf[ct,cog]=min(cogcoff[,"Pr(>|t|)"])
                            }
                        }
                    }

                }
            }
        }
    }
    cat("****************\n\n")
} # subtype loop
##########################################################
##########################################################
if ( FALSE )
for ( subtype in subtypes[1:2] ) {
    print(subtype)
    pvaluedfsub = pvaluedf[ pvaluedf$subtype == subtype, ]
    sel=p.adjust( pvaluedfsub[,'anova'], corrmet ) <= 0.05
    print( pvaluedfsub[ sel, c("Neg","Pos","Y.Neg","Y.Pos","anat")] )
    cat(">>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<\n\n")
}
##########################################################
##########################################################
```


# Usage Notes

...

# Code availability

ANTsPyMM is installable via `pypi` and available at [github](https://github.com/stnava/ANTsPyMM).  
The version used for this work is `1.2.7` along with tensorflow `2.11.0`, antspyx `0.4.2`, antspynet `0.2.3` and antspyt1w `0.9.1`.

# Acknowledgements

Our sincere appreciation to the Michael J. Fox Foundation (MJFF) for supporting this work.

# Author contributions statement

...

# Competing interests

...

# Figures & Tables

Figures, tables, and their legends, should be included in the appropriate section of the document. Figures and tables can be referenced using Markdown syntax.

<!-- ![](stream.jpg) -->
Figure: Legend (350 words max). Example legend text.

| Condition | n  | p     |
|-----------|----|-------|
| A         | 5  | 0.1   |
| B         | 10 | 0.01  |
Table: Legend (350 words max). Example legend text.


